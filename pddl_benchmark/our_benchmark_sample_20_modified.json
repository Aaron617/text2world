[
    {
        "file_name": "soartech_soar_grid.pddl",
        "pddl_domain": "(define (domain grid)\n  (:requirements :strips)\n  (:predicates (conn ?x ?y) (key-shape ?k ?s) (lock-shape ?x ?s)\n\t       (at ?r ?x ) (at-robot ?x) (place ?p) (key ?k) (shape ?s)\n\t       (locked ?x) (holding ?k)  (open ?x)  (arm-empty ))\n\n  (:action unlock\n    :parameters (?curpos ?lockpos ?key ?shape)\n    :precondition (and (place ?curpos) (place ?lockpos) (key ?key)\n\t\t       (shape ?shape) (conn ?curpos ?lockpos)\n\t\t       (key-shape ?key ?shape) (lock-shape ?lockpos ?shape)\n\t\t       (at-robot ?curpos) (locked ?lockpos) (holding ?key))\n    :effect (and (open ?lockpos) (not (locked ?lockpos))))\n\n  (:action move\n    :parameters (?curpos ?nextpos)\n    :precondition (and (place ?curpos) (place ?nextpos) (at-robot ?curpos)\n\t\t       (conn ?curpos ?nextpos) (open ?nextpos))\n    :effect (and (at-robot ?nextpos) (not (at-robot ?curpos))))\n\n  (:action pickup\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (at ?key ?curpos) (arm-empty ))\n    :effect (and (holding ?key) (not (at ?key ?curpos)) (not (arm-empty ))))\n\n  (:action pickup-and-loose\n    :parameters (?curpos ?newkey ?oldkey)\n    :precondition (and (place ?curpos) (key ?newkey) (key ?oldkey)\n\t\t       (at-robot ?curpos) (holding ?oldkey)\n\t\t       (at ?newkey ?curpos))\n    :effect (and (holding ?newkey) (at ?oldkey ?curpos)\n\t\t (not (holding ?oldkey)) (not (at ?newkey ?curpos))))\n\n  (:action putdown\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (holding ?key))\n    :effect (and (arm-empty ) (at ?key ?curpos) (not (holding ?key))))\n  )\n",
        "batch_id": 1,
        "id": 0,
        "tokens": 5527,
        "corrected_description": "### General\nThis domain models a robot navigating a grid environment with the objective of unlocking doors and moving through the grid. The robot can carry keys that match the shape of locks to unlock doors. The environment includes places, keys with specific shapes, and doors (locks) with corresponding shapes that need to be unlocked.\n\n### Predicates\n- (conn ?x ?y): Indicates a connection between two places ?x and ?y, allowing movement between them.\n- (key-shape ?k ?s): Indicates that key ?k has shape ?s.\n- (lock-shape ?x ?s): Indicates that lock (or door) at place ?x has shape ?s.\n- (at ?r ?x): Indicates that key ?r is at place ?x.\n- (at-robot ?x): Indicates that the robot is at place ?x.\n- (place ?p): Indicates that ?p is a place in the grid.\n- (key ?k): Indicates that ?k is a key.\n- (shape ?s): Indicates that ?s is a shape.\n- (locked ?x): Indicates that the place ?x is locked.\n- (holding ?k): Indicates that the robot is holding key ?k.\n- (open ?x): Indicates that the place ?x is open.\n- (arm-empty): Indicates that the robot's arm is empty.\n\n### Actions\n- unlock <?curpos> <?lockpos> <?key> <?shape>: Allows the robot to unlock a door at place <?lockpos> using a key of a specific shape.\n- move <?curpos> <?nextpos>: Allows the robot to move from place <?curpos> to place <?nextpos>.\n- pickup <?curpos> <?key>: Allows the robot to pick up a key at its current location.\n- pickup-and-loose <?curpos> <?newkey> <?oldkey>: Allows the robot to pick up a new key while dropping the one it was holding.\n- putdown <?curpos> <?key>: Allows the robot to put down a key it is holding.",
        "pddl_domain_processed": "(define (domain grid)\n  (:requirements :strips)\n  (:predicates (conn ?x ?y) (key-shape ?k ?s) (lock-shape ?x ?s)\n\t       (at ?r ?x ) (at-robot ?x) (place ?p) (key ?k) (shape ?s)\n\t       (locked ?x) (holding ?k)  (open ?x)  (arm-empty ))\n\n  (:action unlock\n    :parameters (?curpos ?lockpos ?key ?shape)\n    :precondition (and (place ?curpos) (place ?lockpos) (key ?key)\n\t\t       (shape ?shape) (conn ?curpos ?lockpos)\n\t\t       (key-shape ?key ?shape) (lock-shape ?lockpos ?shape)\n\t\t       (at-robot ?curpos) (locked ?lockpos) (holding ?key))\n    :effect (and (open ?lockpos) (not (locked ?lockpos))))\n\n  (:action move\n    :parameters (?curpos ?nextpos)\n    :precondition (and (place ?curpos) (place ?nextpos) (at-robot ?curpos)\n\t\t       (conn ?curpos ?nextpos) (open ?nextpos))\n    :effect (and (at-robot ?nextpos) (not (at-robot ?curpos))))\n\n  (:action pickup\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (at ?key ?curpos) (arm-empty ))\n    :effect (and (holding ?key) (not (at ?key ?curpos)) (not (arm-empty ))))\n\n  (:action pickup-and-loose\n    :parameters (?curpos ?newkey ?oldkey)\n    :precondition (and (place ?curpos) (key ?newkey) (key ?oldkey)\n\t\t       (at-robot ?curpos) (holding ?oldkey)\n\t\t       (at ?newkey ?curpos))\n    :effect (and (holding ?newkey) (at ?oldkey ?curpos)\n\t\t (not (holding ?oldkey)) (not (at ?newkey ?curpos))))\n\n  (:action putdown\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (holding ?key))\n    :effect (and (arm-empty ) (at ?key ?curpos) (not (holding ?key))))\n  )\n"
    },
    {
        "file_name": "TheUnholyPear_PDDL-Basic_domainP2.pddl",
        "pddl_domain": ";Header and description\n\n(define (domain taxi_simplest2)\n\n    ;remove requirements that are not needed\n    (:requirements :strips :equality :typing :conditional-effects :negative-preconditions)\n\n    (:types \n        taxi\n        location\n        person\n    )\n\n\n    (:predicates \n        (plocation ?p - person ?l - location)  \n        (tlocation ?t - taxi ?l - location)   \n        (inTaxi ?p - person ?t - taxi) \n        (connects ?l1 - location ?l2)  \n        (empty ?t - taxi) \n\n    )\n\n    (:action get_in\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and\n            (plocation ?p ?l)\n            (tlocation ?t ?l)\n            (not (inTaxi ?p ?t))\n            (empty ?t)\n         )\n        :effect (and \n            (inTaxi ?p ?t)\n            (not (plocation ?p ?l))\n            (not (empty ?t))\n        )\n    )\n\n    (:action get_out\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and \n            (inTaxi ?p ?t)\n            (tlocation ?t ?l)\n            (not (empty ?t))\n        )\n        :effect (and \n            (not (inTaxi ?p ?t))\n            (plocation ?p ?l)\n            (empty ?t)\n        )\n    )\n\n    (:action move\n    :parameters (?t - taxi ?l1 - location ?l2 - location)\n    :precondition (and \n        (tlocation ?t ?l1)\n        (connects ?l1 ?l2)\n    )\n    :effect (and \n        (not (tlocation ?t ?l1)) \n        (tlocation ?t ?l2)\n    )\n)\n \n\n)",
        "batch_id": 1,
        "id": 16,
        "tokens": 5297,
        "corrected_description": "### General\nThis domain models a simplified taxi service where taxis can move between locations, and people can get in and out of taxis. The goal is to transport people from their current locations to their desired destinations using taxis.\n\n### Types\n- **taxi**: Represents the taxis available for transporting people.\n- **location**: Represents the different locations within the domain.\n- **person**: Represents individuals who need transportation.\n\n### Predicates\n- **(plocation ?p - person ?l - location)**: Indicates that person ?p is at location ?l.\n- **(tlocation ?t - taxi ?l - location)**: Indicates that taxi ?t is at location ?l.\n- **(inTaxi ?p - person ?t - taxi)**: Indicates that person ?p is inside taxi ?t.\n- **(connects ?l1 - location ?l2 - location)**: Indicates that there is a direct path from location ?l1 to location ?l2.\n- **(empty ?t - taxi)**: Indicates that taxi ?t is empty and can take passengers.\n\n### Actions\n- **get_in <?p> <?t> <?l>**: Allows a person to get into a taxi at their current location.  \n  \n- **get_out <?p> <?t> <?l>**: Allows a person to get out of a taxi at a location.  \n  \n- **move <?t> <?l1> <?l2>**: Allows a taxi to move from one location to another if there is a direct path between the two locations.",
        "pddl_domain_processed": "\n\n(define (domain taxi_simplest2)\n\n    (:requirements :strips :equality :typing :conditional-effects :negative-preconditions)\n\n    (:types \n        taxi\n        location\n        person\n    )\n\n    (:predicates \n        (plocation ?p - person ?l - location)  \n        (tlocation ?t - taxi ?l - location)   \n        (inTaxi ?p - person ?t - taxi) \n        (connects ?l1 - location ?l2)  \n        (empty ?t - taxi) \n\n    )\n\n    (:action get_in\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and\n            (plocation ?p ?l)\n            (tlocation ?t ?l)\n            (not (inTaxi ?p ?t))\n            (empty ?t)\n         )\n        :effect (and \n            (inTaxi ?p ?t)\n            (not (plocation ?p ?l))\n            (not (empty ?t))\n        )\n    )\n\n    (:action get_out\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and \n            (inTaxi ?p ?t)\n            (tlocation ?t ?l)\n            (not (empty ?t))\n        )\n        :effect (and \n            (not (inTaxi ?p ?t))\n            (plocation ?p ?l)\n            (empty ?t)\n        )\n    )\n\n    (:action move\n    :parameters (?t - taxi ?l1 - location ?l2 - location)\n    :precondition (and \n        (tlocation ?t ?l1)\n        (connects ?l1 ?l2)\n    )\n    :effect (and \n        (not (tlocation ?t ?l1)) \n        (tlocation ?t ?l2)\n    )\n)\n\n)"
    },
    {
        "file_name": "seanlanepgh_Tile-Cleaning-Robot-PDDL_domain .pddl",
        "pddl_domain": ";;Domain for cleaning floor tiles\n;; Define the name for this domain (needs to match the domain definition\n;;   in the problem files)\n\n(define (domain floor-tile)\n\n\t;; We only require some typing to make this plan faster. We can do without!\n\t(:requirements :typing)\n\n\t;; We have two types: robots and the tiles, both are objects\n\t(:types robot tile - object)\n\n\t;; define all the predicates as they are used in the problem files\n\t(:predicates  \n\n    ;; described what tile a robot is at\n    (robot-at ?robot - robot ?robotTile - tile)\n\n    ;; indicates that tile ?tileAbove is above tile ?tileBelow\n    (up ?tileAbove - tile ?tileBelow - tile)\n\n    ;; indicates that tile ?tileBelow is below tile ?tileAbove\n    (down ?tileBelow - tile ?tileAbove - tile)\n\n    ;; indicates that tile ?tileOnRight is right of tile ?tileOnLeft\n    (right ?tileOnRight - tile ?tileOnLeft - tile)\n\n    ;; indicates that tile ?tileOnLeft is left of tile ?tileOnRight\n    (left ?tileOnLeft - tile ?tileOnRight - tile)\n    \n    ;; indicates that a tile is clear (robot can move there)\n    (clear ?clearedTile - tile)\n\n    ;; indicates that a tile is cleaned\n    (cleaned ?cleanedTile - tile)\n \t)\n  \n  ;; actions\n  ;; clean-up action  \n  (:action clean-up\n        ;; clean-up action takes a robot object called robot and it takes two tile objects called tileToBeCleaned and robotTile\n        :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile)\n        ;; Preconditions for the action clean-up\n        :precondition (and\n                       ;; The clean-up action uses the predicate called robot-at to check a robot is on a tile\n                       (robot-at ?robot ?robotTile) \n                       ;; The predicate called up is used to check if the tileToBeCleaned is above the tile that the robot is on\n                       (up ?tileToBeCleaned ?robotTile) \n                       ;;The predicate clear is used to check if the tileToBeCleaned is clear\n                       (clear ?tileToBeCleaned)\n                       ;; This precondition uses the predicate cleaned,this  is used to check if the tileToBeCleaned is not cleaned\n                       (not(cleaned ?tileToBeCleaned))\n                  )\n    ;;Effects of the action clean-up \t\t\t\t\t\n    :effect (and \n              ;; The action clean-up causes the tileToBeCleaned to be cleaned and so the predicate cleaned is used to show the tileToBeCleaned is cleaned\n               ( cleaned ?tileToBeCleaned)\n              ;; As the tile is now clean it is also not clear as the robot cannot move on clean tiles\n               (not(clear ?tileToBeCleaned))\n            )\n  )\n  \n  ;;clean-down action\n  (:action clean-down\n      ;; clean-down action takes a robot object called robot and it takes two tile objects called tileToBeCleaned and robotTile\n     :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile )\n   ;; Preconditions for the action clean-down \n   :precondition (and \n                       ;; The clean-down action uses the predicate called robot-at to check a robot is on a tile\n                      (robot-at ?robot ?robotTile)\n                       ;; The predicate called up is used to check if the tileToBeCleaned is above the tile that the robot is on\n                      (down ?tileToBeCleaned ?robotTile)\n                       ;;The predicate clear is used to check if the tileToBeCleaned is clear\n                      (clear ?tileToBeCleaned) \n                       ;; This precondition uses the predicate cleaned,this  is used to check if the tileToBeCleaned is not cleaned\n                      (not(cleaned ?tileToBeCleaned))\n                  )\n   ;;Effects of the action clean-down \t\n    :effect (and \n              ;; The action clean-down causes the tileToBeCleaned to be cleaned and so the predicate cleaned is used to show the tileToBeCleaned is cleaned\n              ( cleaned ?tileToBeCleaned)\n              ;; As the tile is now clean it is also not clear as the robot cannot move on clean tiles\n              (not(clear ?tileToBeCleaned))\n          )\n  )\n  \n  ;; up action\n  (:action up\n          ;; up action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action up\n         :precondition (and \n                      ;; The up action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       ;; The predicate called up is used to check if the moveToNextTile is above the tile that the robot is on \n                        (up ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                         ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n          ;;Effects of the action up\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; down action\n  (:action down\n         ;; down action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action down\n         :precondition (and \n                      \t;; The down action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       \t;; The predicate called down is used to check if the moveToNextTile is below the tile that the robot is on \n                        (down ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n          ;;Effects of the action down\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; right action\n  (:action right\n         ;; right action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action right\n         :precondition (and \n                      \t;; The right action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                      \t;; The predicate called right is used to check if the moveToNextTile is below the tile that the robot is on \n                        (right ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n         ;;Effects of the action right\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; left action\n  (:action left\n         ;; left action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action left\n         :precondition (and \n                     \t ;; The left action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       \t;; The predicate called left is used to check if the moveToNextTile is below the tile that the robot is on \n                        (left ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n         ;;Effects of the action left\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n)\n\n  \n\n\n",
        "batch_id": 1,
        "id": 28,
        "tokens": 7837,
        "corrected_description": "### General\nThis domain is designed for a robot tasked with cleaning floor tiles. The robot can move in four directions (up, down, right, left) relative to its current position on a grid of tiles. The goal is to clean all the specified tiles by moving to them and performing a cleaning action.\n\n### Types\n- **robot**: Represents the robot that performs the cleaning.\n- **tile**: Represents the individual tiles on the floor that may need to be cleaned.\n\n### Predicates\n- **(robot-at ?robot - robot ?robotTile - tile)**: Indicates that the robot is currently at a specific tile.\n- **(up ?tileAbove - tile ?tileBelow - tile)**: Indicates that one tile is directly above another.\n- **(down ?tileBelow - tile ?tileAbove - tile)**: Indicates that one tile is directly below another.\n- **(right ?tileOnRight - tile ?tileOnLeft - tile)**: Indicates that one tile is directly to the right of another.\n- **(left ?tileOnLeft - tile ?tileOnRight - tile)**: Indicates that one tile is directly to the left of another.\n- **(clear ?clearedTile - tile)**: Indicates that a tile is clear and robot can move there.\n- **(cleaned ?cleanedTile - tile)**: Indicates that a tile has been cleaned.\n\n### Actions\n- **clean-up <?robot> <?robotTile> <?tileToBeCleaned>**: Allows the robot (?robot) to clean a tile (?tileToBeCleaned) that is directly above its current position (?robotTile).  \n\n- **clean-down <?robot> <?robotTile> <?tileToBeCleaned>**: Allows the robot (?robot) to clean a tile (?tileToBeCleaned) that is directly below its current position (?robotTile).  \n\n- **up <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly above its current position (?robotTile).  \n\n- **down <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly below its current position (?robotTile).  \n\n- **right <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly to the right of its current position (?robotTile).  \n\n- **left <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly to the left of its current position (?robotTile).",
        "pddl_domain_processed": "\n\n(define (domain floor-tile)\n\n\t(:requirements :typing)\n\n\t(:types robot tile - object)\n\n\t(:predicates  \n\n    (robot-at ?robot - robot ?robotTile - tile)\n\n    (up ?tileAbove - tile ?tileBelow - tile)\n\n    (down ?tileBelow - tile ?tileAbove - tile)\n\n    (right ?tileOnRight - tile ?tileOnLeft - tile)\n\n    (left ?tileOnLeft - tile ?tileOnRight - tile)\n\n    (clear ?clearedTile - tile)\n\n    (cleaned ?cleanedTile - tile)\n \t)\n\n  (:action clean-up\n\n        :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile)\n\n        :precondition (and\n\n                       (robot-at ?robot ?robotTile) \n\n                       (up ?tileToBeCleaned ?robotTile) \n\n                       (clear ?tileToBeCleaned)\n\n                       (not(cleaned ?tileToBeCleaned))\n                  )\n\n    :effect (and \n\n               ( cleaned ?tileToBeCleaned)\n\n               (not(clear ?tileToBeCleaned))\n            )\n  )\n\n  (:action clean-down\n\n     :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile )\n\n   :precondition (and \n\n                      (robot-at ?robot ?robotTile)\n\n                      (down ?tileToBeCleaned ?robotTile)\n\n                      (clear ?tileToBeCleaned) \n\n                      (not(cleaned ?tileToBeCleaned))\n                  )\n\n    :effect (and \n\n              ( cleaned ?tileToBeCleaned)\n\n              (not(clear ?tileToBeCleaned))\n          )\n  )\n\n  (:action up\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (up ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action down\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (down ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action right\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (right ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action left\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (left ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n)\n\n"
    },
    {
        "file_name": "HAPILab_GoalAlignment_domain_new.pddl",
        "pddl_domain": "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Domain file automatically generated by the Tarski FSTRIPS writer\n;;; \n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain test_domain)\n    (:requirements :typing :equality)\n    (:types\n        tealeavesquality - object\n        object\n    )\n\n    (:constants\n        \n    )\n\n    (:predicates\n        (extendedarm )\n        (tea-made )\n        (tea-made-with ?x1 - tealeavesquality)\n        (on-upper-shelf ?x1 - tealeavesquality)\n        (on-lower-shelf ?x1 - tealeavesquality)\n        (in-kitchen )\n        (has-tealeaves ?x1 - tealeavesquality)\n        (can_climb )\n        (ladder-next-pantry )\n        (ladder-used )\n        (dummy )\n    )\n\n    (:functions\n        \n    )\n\n    \n\n    \n    (:action bring_ladder\n     :parameters ()\n     :precondition (in-kitchen )\n     :effect (and\n        (ladder-next-pantry ))\n    )\n\n\n    (:action grab_tealeaves\n     :parameters (?n - tealeavesquality)\n     :precondition (and (on-lower-shelf ?n) (in-kitchen ))\n     :effect (and\n        (has-tealeaves ?n))\n    )\n\n\n    (:action reach_tealeaves_extend_arm\n     :parameters (?g - tealeavesquality)\n     :precondition (and (on-upper-shelf ?g) (in-kitchen ))\n     :effect (and\n        (extendedarm )\n        (has-tealeaves ?g))\n    )\n\n\n    (:action reach_tealeaves_ladder\n     :parameters (?g - tealeavesquality)\n     :precondition (and (ladder-next-pantry ) (on-upper-shelf ?g) (can_climb ))\n     :effect (and\n        (has-tealeaves ?g)\n        (ladder-used ))\n    )\n\n\n    (:action make_tea\n     :parameters (?t - tealeavesquality)\n     :precondition (has-tealeaves ?t)\n     :effect (and\n        (tea-made )\n        (tea-made-with ?t))\n    )\n\n)",
        "batch_id": 1,
        "id": 48,
        "tokens": 5582,
        "corrected_description": "### General\nThis domain is designed for a scenario involving the preparation of tea with different qualities of tea leaves. The actions include moving a ladder, grabbing tea leaves from shelves, and making tea. The domain models the environment of a kitchen with upper and lower shelves where tea leaves are stored and a process for making tea with the selected tea leaves.\n\n### Types\n- **tealeavesquality**: Represents different qualities of tea leaves.\n- **object**: A general type for objects in the domain.\n\n### Predicates\n- **(extendedarm)**: Indicates that the robot's arm is extended.\n- **(tea-made)**: Indicates that tea has been made.\n- **(tea-made-with ?x1 - tealeavesquality)**: Indicates that tea has been made with a specific quality of tea leaves, denoted by ?x1.\n- **(on-upper-shelf ?x1 - tealeavesquality)**: Indicates that tea leaves of a specific quality are on the upper shelf.\n- **(on-lower-shelf ?x1 - tealeavesquality)**: Indicates that tea leaves of a specific quality are on the lower shelf.\n- **(in-kitchen)**: Indicates that the robot is in the kitchen.\n- **(has-tealeaves ?x1 - tealeavesquality)**: Indicates that the robot has tea leaves of a specific quality.\n- **(can_climb)**: Indicates that the robot can climb.\n- **(ladder-next-pantry)**: Indicates that the ladder is next to the pantry.\n- **(ladder-used)**: Indicates that the ladder has been used.\n- **(dummy)**: A placeholder predicate with no specific meaning.\n\n### Actions\n- **bring_ladder**: Moves the ladder next to the pantry if the robot is in the kitchen. The precondition for this action is that the robot is in the kitchen. The effect of this action is that the ladder is next to the pantry.\n\n- **grab_tealeaves <?n>**: Allows the robot to grab tea leaves from the lower shelf if it is in the kitchen. The precondition for this action is that the tea leaves are on the lower shelf and the robot is in the kitchen. The effect of this action is that the robot has the tea leaves.\n\n- **reach_tealeaves_extend_arm <?g>**: Allows the robot to reach and grab tea leaves from the upper shelf by extending its arm if it is in the kitchen.  \n\n- **reach_tealeaves_ladder <?g>**: Allows the robot to reach and grab tea leaves from the upper shelf using a ladder if the ladder is next to the pantry and the robot can climb.  \n\n- **make_tea <?t>**: Allows the robot to make tea with the tea leaves it has.",
        "pddl_domain_processed": "\n\n(define (domain test_domain)\n    (:requirements :typing :equality)\n    (:types\n        tealeavesquality - object\n        object\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n        (extendedarm )\n        (tea-made )\n        (tea-made-with ?x1 - tealeavesquality)\n        (on-upper-shelf ?x1 - tealeavesquality)\n        (on-lower-shelf ?x1 - tealeavesquality)\n        (in-kitchen )\n        (has-tealeaves ?x1 - tealeavesquality)\n        (can_climb )\n        (ladder-next-pantry )\n        (ladder-used )\n        (dummy )\n    )\n\n    (:functions\n\n    )\n\n    (:action bring_ladder\n     :parameters ()\n     :precondition (in-kitchen )\n     :effect (and\n        (ladder-next-pantry ))\n    )\n\n    (:action grab_tealeaves\n     :parameters (?n - tealeavesquality)\n     :precondition (and (on-lower-shelf ?n) (in-kitchen ))\n     :effect (and\n        (has-tealeaves ?n))\n    )\n\n    (:action reach_tealeaves_extend_arm\n     :parameters (?g - tealeavesquality)\n     :precondition (and (on-upper-shelf ?g) (in-kitchen ))\n     :effect (and\n        (extendedarm )\n        (has-tealeaves ?g))\n    )\n\n    (:action reach_tealeaves_ladder\n     :parameters (?g - tealeavesquality)\n     :precondition (and (ladder-next-pantry ) (on-upper-shelf ?g) (can_climb ))\n     :effect (and\n        (has-tealeaves ?g)\n        (ladder-used ))\n    )\n\n    (:action make_tea\n     :parameters (?t - tealeavesquality)\n     :precondition (has-tealeaves ?t)\n     :effect (and\n        (tea-made )\n        (tea-made-with ?t))\n    )\n\n)"
    },
    {
        "batch_id": 2,
        "file_name": "driverlog",
        "pddl_domain": "(define (domain driverlog)\n  (:requirements :typing) \n  (:types         location locatable - object\n\t\tdriver truck obj - locatable\n  \n  )\n  (:predicates \n\t\t(at ?obj - locatable ?loc - location)\n\t\t(in ?obj1 - obj ?obj - truck)\n\t\t(driving ?d - driver ?v - truck)\n\t\t(link ?x ?y - location) (path ?x ?y - location)\n\t\t(empty ?v - truck)\n)\n\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action BOARD-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?driver ?loc) (empty ?truck))\n  :effect\n   (and (not (at ?driver ?loc)) (driving ?driver ?truck) (not (empty ?truck))))\n\n(:action DISEMBARK-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (driving ?driver ?truck))\n  :effect\n   (and (not (driving ?driver ?truck)) (at ?driver ?loc) (empty ?truck)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck - truck\n    ?loc-from - location\n    ?loc-to - location\n    ?driver - driver)\n  :precondition\n   (and (at ?truck ?loc-from)\n   (driving ?driver ?truck) (link ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action WALK\n  :parameters\n   (?driver - driver\n    ?loc-from - location\n    ?loc-to - location)\n  :precondition\n   (and (at ?driver ?loc-from) (path ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?driver ?loc-from)) (at ?driver ?loc-to)))\n\n \n)\n",
        "id": 61,
        "tokens": 5790,
        "corrected_description": "### General\nThe domain models a logistics scenario where drivers can load objects into trucks, drive trucks between locations, and unload objects. Drivers can also move between locations independently of the trucks. The goal is to efficiently manage the transportation of objects and the movement of drivers to achieve specific logistical objectives.\n\n### Types\n- **location**: Represents geographical locations.\n- **locatable**: A superclass for all entities that can be located somewhere, including drivers, trucks, and objects.\n- **driver**: Represents individuals capable of driving trucks and carrying objects.\n- **truck**: Represents vehicles used for transporting objects.\n- **obj**: Represents objects that need to be transported.\n\n### Predicates\n- **(at ?obj - locatable ?loc - location)**: Indicates that a locatable entity (?obj) is at a specific location (?loc).\n- **(in ?obj1 - obj ?obj - truck)**: Indicates that an object (?obj1) is inside a truck (?obj).\n- **(driving ?d - driver ?v - truck)**: Indicates that a driver (?d) is driving a truck (?v).\n- **(link ?x ?y - location)**: Represents a direct route between two locations (?x and ?y).\n- **(path ?x ?y - location)**: Represents a walkable path between two locations (?x and ?y).\n- **(empty ?v - truck)**: Indicates that a truck (?v) is empty.\n\n### Actions\n- **LOAD-TRUCK <?obj> <?truck> <?loc>**: Loads an object into a truck at a location.  \n  \n- **UNLOAD-TRUCK <?obj> <?truck> <?loc>**: Unloads an object from a truck at a location.  \n  \n- **BOARD-TRUCK <?driver> <?truck> <?loc>**: A driver boards a truck at a location, preparing to drive it.  \n  \n- **DISEMBARK-TRUCK <?driver> <?truck> <?loc>**: A driver disembarks from a truck at a location.  \n  \n- **DRIVE-TRUCK <?truck> <?loc-from> <?loc-to> <?driver>**: Moves a truck from one location to another under the control of a driver.  \n  \n- **WALK <?driver> <?loc-from> <?loc-to>**: A driver walks from one location to another.",
        "pddl_domain_processed": "(define (domain driverlog)\n  (:requirements :typing) \n  (:types         location locatable - object\n\t\tdriver truck obj - locatable\n\n  )\n  (:predicates \n\t\t(at ?obj - locatable ?loc - location)\n\t\t(in ?obj1 - obj ?obj - truck)\n\t\t(driving ?d - driver ?v - truck)\n\t\t(link ?x ?y - location) (path ?x ?y - location)\n\t\t(empty ?v - truck)\n)\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action BOARD-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?driver ?loc) (empty ?truck))\n  :effect\n   (and (not (at ?driver ?loc)) (driving ?driver ?truck) (not (empty ?truck))))\n\n(:action DISEMBARK-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (driving ?driver ?truck))\n  :effect\n   (and (not (driving ?driver ?truck)) (at ?driver ?loc) (empty ?truck)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck - truck\n    ?loc-from - location\n    ?loc-to - location\n    ?driver - driver)\n  :precondition\n   (and (at ?truck ?loc-from)\n   (driving ?driver ?truck) (link ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action WALK\n  :parameters\n   (?driver - driver\n    ?loc-from - location\n    ?loc-to - location)\n  :precondition\n   (and (at ?driver ?loc-from) (path ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?driver ?loc-from)) (at ?driver ?loc-to)))\n\n)\n"
    },
    {
        "batch_id": 2,
        "file_name": "schedule",
        "pddl_domain": ";; Schedule World\n;;\n\n(define (domain schedule)\n  (:requirements :adl :typing)\n  (:types temperature-type\n\t  ashape\n\t  surface\n\t  machine\n\t  part\n\t  colour\n\t  width\n\t  anorient)\n\n  (:constants cold hot - temperature-type\n\t      cylindrical - ashape \n\t      polisher roller lathe grinder punch drill-press\n\t      spray-painter immersion-painter - machine\n              polished rough smooth - surface)\n\n  (:predicates (temperature ?obj - part ?temp - temperature-type)\n\t       (busy ?machine - machine)\n\t       (scheduled ?obj - part)\n\t       (objscheduled)\n\t       (surface-condition ?obj - part ?surface-cond - surface)\n\t       (shape ?obj - part ?shape - ashape)\n\t       (painted ?obj - part ?colour - colour)\n\t       (has-hole ?obj - part ?width - width ?orientation - anorient)\n\t       (has-bit ?machine - machine ?width - width)\n\t       (can-orient ?machine - machine ?orientation - anorient)\n\t       (has-paint ?machine - machine ?colour - colour))\n\n  (:action do-polish\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy polisher))\n\t\t\t      (not (scheduled ?x))\n\t\t\t      (temperature ?x cold))\n\t   :effect (and (busy polisher)\n\t\t\t(scheduled ?x)\n\t\t\t(surface-condition ?x polished)\n\t\t\t(when (not (objscheduled))\n\t\t\t  (objscheduled))\n\t\t\t(forall (?oldsurface - surface)\n\t\t\t\t(when (and (surface-condition ?x ?oldsurface)\n                                           (not (= ?oldsurface polished)))\n\t\t\t\t  (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-roll\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy roller))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy roller)\n\t\t    (scheduled ?x)\n\t\t    (temperature ?x hot)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))\n\t\t    (forall (?oldwidth - width ?oldorient - anorient)\n\t\t\t    (when (has-hole ?x ?oldwidth ?oldorient)\n\t\t\t      (not (has-hole ?x ?oldwidth ?oldorient))))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldtemp - temperature-type)\n\t\t\t    (when (and (temperature ?x ?oldtemp)\n                                       (not (= ?oldtemp hot)))\n\t\t\t      (not (temperature ?x ?oldtemp))))))\n\n  (:action do-lathe\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy lathe))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and \n\t\t    (busy lathe)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x rough)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t    (not (painted ?x ?oldpaint))))))\n\n  (:action do-grind\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy grinder))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy GRINDER)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x smooth)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface smooth)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-punch\n\t   :parameters (?x - part ?width - width  ?orient - anorient)  \n\t   :precondition (and\n\t\t\t  (has-bit punch ?width)\n\t\t\t  (can-orient punch ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy punch))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy punch)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (surface-condition ?x rough)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface) \n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-drill-press\n\t   :parameters (?x - part ?width - width ?orient - anorient)\n\t   :precondition (and\n\t\t\t  (has-bit drill-press ?width)\n\t\t\t  (can-orient drill-press ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy drill-press))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy drill-press)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))))\n\n  (:action do-spray-paint\n\t   :parameters (?x - part ?newpaint - colour) \n\t   :precondition (and\n\t\t\t  (has-paint spray-painter ?newpaint)\n\t\t\t  (not (busy spray-painter))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (temperature ?x COLD))\n\t   :effect (and\n\t\t    (busy spray-painter)\n\t\t    (scheduled ?x)\n\t\t    (painted ?x ?newpaint)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n\t\t\t      (not (painted ?x ?oldpaint))))))\n  \n  (:action do-immersion-paint     \n           :parameters (?x - part ?newpaint - colour) \n           :precondition (and\n                          (has-paint immersion-painter ?newpaint)\n                          (not (busy immersion-painter))\n                          (not (scheduled ?x)))\n           :effect (and\n                    (busy immersion-painter)\n                    (scheduled ?x)\n                    (painted ?x ?newpaint)\n                    (when (not (objscheduled))\n                      (objscheduled))\n                    (forall (?oldpaint - colour)\n                            (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n                              (not (painted ?x ?oldpaint))))))\n  \n  (:action do-time-step\n           :parameters ()\n           :precondition (objscheduled)\n           :effect (and\n                    (forall (?x - part)\n                            (when (scheduled ?x)\n                              (not (scheduled ?x))))\n                    (forall (?m - machine)\n                            (when (busy ?m)\n                              (not (busy ?m)))))))\n\n\n\n\n\n\n",
        "id": 63,
        "tokens": 6990,
        "corrected_description": "### General\nThis domain is designed for scheduling tasks in a manufacturing environment. It involves managing parts, machines, and operations such as polishing, rolling, lathe work, grinding, punching, drilling, and painting. The goal is to efficiently schedule various operations on parts while managing the state of machines (busy or not) and ensuring parts go through the necessary processes to meet their final specifications.\n\n### Types\n- **temperature-type**: Represents the temperature states of parts, such as cold or hot.\n- **ashape**: Represents the shapes of parts, such as cylindrical.\n- **surface**: Represents the surface conditions of parts, such as polished, rough, or smooth.\n- **machine**: Represents different machines used in the manufacturing process, such as polishers, rollers, lathes, grinders, punch presses, drill presses, spray painters, and immersion painters.\n- **part**: Represents the items being manufactured.\n- **colour**: Represents the colors that parts can be painted.\n- **width**: Represents the width of holes that can be punched or drilled into parts.\n- **anorient**: Represents the orientation of holes in parts.\n\n### Predicates\n- **(temperature ?obj - part ?temp - temperature-type)**: Indicates the temperature state of a part.\n- **(busy ?machine - machine)**: Indicates whether a machine is currently busy.\n- **(scheduled ?obj - part)**: Indicates whether a part has been scheduled for an operation.\n- **(objscheduled)**: Indicates that at least one part has been scheduled for an operation.\n- **(surface-condition ?obj - part ?surface-cond - surface)**: Indicates the surface condition of a part.\n- **(shape ?obj - part ?shape - ashape)**: Indicates the shape of a part.\n- **(painted ?obj - part ?colour - colour)**: Indicates the color a part has been painted.\n- **(has-hole ?obj - part ?width - width ?orientation - anorient)**: Indicates that a part has a hole of a certain width and orientation.\n- **(has-bit ?machine - machine ?width - width)**: Indicates that a machine has a bit of a certain width for operations like punching or drilling.\n- **(can-orient ?machine - machine ?orientation - anorient)**: Indicates that a machine can orient its operations in a certain way.\n- **(has-paint ?machine - machine ?colour - colour)**: Indicates that a machine has paint of a certain color for painting operations.\n\n### Actions\n- **do-polish <?x>**: Polishes a part using the polisher machine if it is not busy, the part is cold, and not already scheduled.  \n\n- **do-roll <?x>**: Rolls a part to make it cylindrical and hot using the roller machine if it is not busy and the part is not already scheduled.  \n\n- **do-lathe <?x>**: Performs lathe work on a part to make it cylindrical and rough using the lathe machine if it is not busy and the part is not already scheduled.  \n\n- **do-grind <?x>**: Grinds a part to make its surface smooth using the grinder machine if it is not busy and the part is not already scheduled.  \n\n- **do-punch <?x> <?width> <?orient>**: Punches a hole in a part using the punch machine if it has the correct bit and orientation, the part is cold, not busy, not already scheduled, and does not already have a hole of the specified width and orientation.  \n\n- **do-drill-press <?x> <?width> <?orient>**: Drills a hole in a part using the drill press if it has the correct bit and orientation, the part is cold, not busy, not already scheduled, and does not already have a hole of the specified width and orientation.  \n\n- **do-spray-paint <?x> <?newpaint>**: Spray paints a part with a new color using the spray painter if it has the paint, is not busy, the part is cold, and not already scheduled.  \n\n- **do-immersion-paint <?x> <?newpaint>**: Paints a part with a new color using the immersion painter if it has the paint, is not busy, and the part is not already scheduled.  \n\n- **do-time-step**: Advances time, resetting the scheduled status of parts and the busy status of machines if at least one part has been scheduled.",
        "pddl_domain_processed": "\n\n(define (domain schedule)\n  (:requirements :adl :typing)\n  (:types temperature-type\n\t  ashape\n\t  surface\n\t  machine\n\t  part\n\t  colour\n\t  width\n\t  anorient)\n\n  (:constants cold hot - temperature-type\n\t      cylindrical - ashape \n\t      polisher roller lathe grinder punch drill-press\n\t      spray-painter immersion-painter - machine\n              polished rough smooth - surface)\n\n  (:predicates (temperature ?obj - part ?temp - temperature-type)\n\t       (busy ?machine - machine)\n\t       (scheduled ?obj - part)\n\t       (objscheduled)\n\t       (surface-condition ?obj - part ?surface-cond - surface)\n\t       (shape ?obj - part ?shape - ashape)\n\t       (painted ?obj - part ?colour - colour)\n\t       (has-hole ?obj - part ?width - width ?orientation - anorient)\n\t       (has-bit ?machine - machine ?width - width)\n\t       (can-orient ?machine - machine ?orientation - anorient)\n\t       (has-paint ?machine - machine ?colour - colour))\n\n  (:action do-polish\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy polisher))\n\t\t\t      (not (scheduled ?x))\n\t\t\t      (temperature ?x cold))\n\t   :effect (and (busy polisher)\n\t\t\t(scheduled ?x)\n\t\t\t(surface-condition ?x polished)\n\t\t\t(when (not (objscheduled))\n\t\t\t  (objscheduled))\n\t\t\t(forall (?oldsurface - surface)\n\t\t\t\t(when (and (surface-condition ?x ?oldsurface)\n                                           (not (= ?oldsurface polished)))\n\t\t\t\t  (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-roll\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy roller))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy roller)\n\t\t    (scheduled ?x)\n\t\t    (temperature ?x hot)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))\n\t\t    (forall (?oldwidth - width ?oldorient - anorient)\n\t\t\t    (when (has-hole ?x ?oldwidth ?oldorient)\n\t\t\t      (not (has-hole ?x ?oldwidth ?oldorient))))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldtemp - temperature-type)\n\t\t\t    (when (and (temperature ?x ?oldtemp)\n                                       (not (= ?oldtemp hot)))\n\t\t\t      (not (temperature ?x ?oldtemp))))))\n\n  (:action do-lathe\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy lathe))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and \n\t\t    (busy lathe)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x rough)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t    (not (painted ?x ?oldpaint))))))\n\n  (:action do-grind\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy grinder))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy GRINDER)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x smooth)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface smooth)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-punch\n\t   :parameters (?x - part ?width - width  ?orient - anorient)  \n\t   :precondition (and\n\t\t\t  (has-bit punch ?width)\n\t\t\t  (can-orient punch ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy punch))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy punch)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (surface-condition ?x rough)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface) \n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-drill-press\n\t   :parameters (?x - part ?width - width ?orient - anorient)\n\t   :precondition (and\n\t\t\t  (has-bit drill-press ?width)\n\t\t\t  (can-orient drill-press ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy drill-press))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy drill-press)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))))\n\n  (:action do-spray-paint\n\t   :parameters (?x - part ?newpaint - colour) \n\t   :precondition (and\n\t\t\t  (has-paint spray-painter ?newpaint)\n\t\t\t  (not (busy spray-painter))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (temperature ?x COLD))\n\t   :effect (and\n\t\t    (busy spray-painter)\n\t\t    (scheduled ?x)\n\t\t    (painted ?x ?newpaint)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-immersion-paint     \n           :parameters (?x - part ?newpaint - colour) \n           :precondition (and\n                          (has-paint immersion-painter ?newpaint)\n                          (not (busy immersion-painter))\n                          (not (scheduled ?x)))\n           :effect (and\n                    (busy immersion-painter)\n                    (scheduled ?x)\n                    (painted ?x ?newpaint)\n                    (when (not (objscheduled))\n                      (objscheduled))\n                    (forall (?oldpaint - colour)\n                            (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n                              (not (painted ?x ?oldpaint))))))\n\n  (:action do-time-step\n           :parameters ()\n           :precondition (objscheduled)\n           :effect (and\n                    (forall (?x - part)\n                            (when (scheduled ?x)\n                              (not (scheduled ?x))))\n                    (forall (?m - machine)\n                            (when (busy ?m)\n                              (not (busy ?m)))))))\n\n"
    },
    {
        "batch_id": 2,
        "file_name": "data-network",
        "pddl_domain": ";; Distributed Computing Planning Domain\n;; Authors: Manuel Heusner, Florian Pommerening, Alvaro Torralba\n;;\n;; In a given network of servers, each server can produce data by processing\n;; existing data and send the data to connected servers. Each server has a disk\n;; and random access memory (RAM). Data that is saved on the disk of a server\n;; must be loaded into RAM of the server in order to be processed or sent to the\n;; RAM of another server.\n;;\n;; The ability to process and distribute the data in the network is constrained\n;; by\n;;     - the connections between servers,\n;;     - the capacity of server's RAM,\n;;     - the availability of scripts on servers, and\n;;     - the cost of\n;;         - load and save actions, which depends on the data size and the (disk's io performance of a) server,\n;;         - send action, which depends on the data size and (bandwidth of a) connection, and\n;;         - process action, which depends on the script and (clock rate and numbers of processors of a) server.\n\n\n(define (domain data-network)\n(:requirements :adl :typing :negative-preconditions :equality :action-costs)\n\n(:types data script server numbers)\n\n(:predicates (SCRIPT-IO ?s - script ?in1 - data ?in2 - data ?out - data)\n             (CONNECTED ?from - server ?to - server)\n             (DATA-SIZE ?d - data ?n - numbers)\n             (CAPACITY ?s - server ?n - numbers)\n             (SUM ?n1 - numbers ?n2 - numbers ?sum - numbers)\n             (LESS-EQUAL ?n1 - numbers ?n2 - numbers)\n             (saved ?d - data ?s - server)\n             (cached ?d - data ?s - server)\n             (usage ?s - server ?n - numbers))\n\n(:functions (total-cost) - number\n            (process-cost ?sc - script ?s - server) - number\n            (send-cost ?from ?to - server ?size - numbers) - number\n            (io-cost ?s - server ?size - numbers) - number)\n\n\n;; Release data from RAM.\n(:action release\n :parameters (?d - data ?s - server ?size ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (SUM ?after ?size ?before)\n                    (cached ?d ?s)\n                    (usage ?s ?before))\n :effect (and (not (cached ?d ?s))\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) 0)))\n\n;; Save data from RAM to disk.\n(:action save\n :parameters (?d - data ?size - numbers ?s - server)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (cached ?d ?s))\n :effect (and (saved ?d ?s)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n;; Load data from disk into RAM.\n(:action load\n :parameters (?d - data ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (saved ?d ?s)\n                    (not (cached ?d ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?d ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n;; Send data from RAM of one server to RAM of another server.\n(:action send\n :parameters (?d - data ?from ?to - server  ?size ?limit ?before ?after - numbers)\n :precondition (and (CONNECTED ?from ?to)\n                    (DATA-SIZE ?d ?size)\n                    (CAPACITY ?to ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?d ?from)\n                    (not (cached ?d ?to))\n                    (usage ?to ?before))\n :effect (and (cached ?d ?to)\n              (not (usage ?to ?before))\n              (usage ?to ?after)\n              (increase (total-cost) (send-cost ?from ?to ?size))))\n\n;; Executes a script that processes two data items from RAM and produces another data item in RAM.\n(:action process\n :parameters (?in1 ?in2 ?out - data ?sc - script ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (SCRIPT-IO ?sc ?in1 ?in2 ?out)\n                    (DATA-SIZE ?out ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?in1 ?s)\n                    (cached ?in2 ?s)\n                    (not (cached ?out ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?out ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (process-cost ?sc ?s))))\n)\n",
        "id": 67,
        "tokens": 6552,
        "corrected_description": "### General\nThis domain models a distributed computing environment where servers process and exchange data. Servers have limited RAM and disk space. Data must be loaded into RAM from a server's disk to be processed or sent to another server. The domain includes actions for loading, saving, sending, and processing data, with costs associated with each action based on data size, server capacity, and network bandwidth.\n\n### Types\n- **data**: Represents individual pieces of data that can be processed or transferred.\n- **script**: Represents processing scripts that can transform data items.\n- **server**: Represents computing servers in the network.\n- **numbers**: Represents numerical values, such as data sizes and capacities.\n\n### Predicates\n- **SCRIPT-IO (?s - script ?in1 - data ?in2 - data ?out - data)**: Indicates that script ?s takes inputs ?in1 and ?in2 to produce output ?out.\n- **CONNECTED (?from - server ?to - server)**: Indicates that there is a network connection from server ?from to server ?to.\n- **DATA-SIZE (?d - data ?n - numbers)**: Relates a piece of data ?d to its size ?n.\n- **CAPACITY (?s - server ?n - numbers)**: Relates a server ?s to its RAM capacity ?n.\n- **SUM (?n1 - numbers ?n2 - numbers ?sum - numbers)**: Represents the sum of ?n1 and ?n2 is ?sum.\n- **LESS-EQUAL (?n1 - numbers ?n2 - numbers)**: Indicates that ?n1 is less than or equal to ?n2.\n- **saved (?d - data ?s - server)**: Indicates that data ?d is saved on the disk of server ?s.\n- **cached (?d - data ?s - server)**: Indicates that data ?d is loaded into the RAM of server ?s.\n- **usage (?s - server ?n - numbers)**: Relates a server ?s to the amount of RAM in use ?n.\n\n### Actions\n- **release <?d> <?s> <?size> <?before> <?after>**: Releases data from a server's RAM, freeing up space.   \n\n- **save <?d> <?size> <?s>**: Saves data from RAM to a server's disk.  \n\n- **load <?d> <?s> <?size> <?limit> <?before> <?after>**: Loads data from a server's disk into RAM.  \n\n- **send <?d> <?from> <?to> <?size> <?limit> <?before> <?after>**: Sends data from the RAM of one server to another.  \n\n- **process <?in1> <?in2> <?out> <?sc> <?s> <?size> <?limit> <?before> <?after>**: Processes two data items to produce a new data item.",
        "pddl_domain_processed": "\n\n(define (domain data-network)\n(:requirements :adl :typing :negative-preconditions :equality :action-costs)\n\n(:types data script server numbers)\n\n(:predicates (SCRIPT-IO ?s - script ?in1 - data ?in2 - data ?out - data)\n             (CONNECTED ?from - server ?to - server)\n             (DATA-SIZE ?d - data ?n - numbers)\n             (CAPACITY ?s - server ?n - numbers)\n             (SUM ?n1 - numbers ?n2 - numbers ?sum - numbers)\n             (LESS-EQUAL ?n1 - numbers ?n2 - numbers)\n             (saved ?d - data ?s - server)\n             (cached ?d - data ?s - server)\n             (usage ?s - server ?n - numbers))\n\n(:functions (total-cost) - number\n            (process-cost ?sc - script ?s - server) - number\n            (send-cost ?from ?to - server ?size - numbers) - number\n            (io-cost ?s - server ?size - numbers) - number)\n\n(:action release\n :parameters (?d - data ?s - server ?size ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (SUM ?after ?size ?before)\n                    (cached ?d ?s)\n                    (usage ?s ?before))\n :effect (and (not (cached ?d ?s))\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) 0)))\n\n(:action save\n :parameters (?d - data ?size - numbers ?s - server)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (cached ?d ?s))\n :effect (and (saved ?d ?s)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n(:action load\n :parameters (?d - data ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (saved ?d ?s)\n                    (not (cached ?d ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?d ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n(:action send\n :parameters (?d - data ?from ?to - server  ?size ?limit ?before ?after - numbers)\n :precondition (and (CONNECTED ?from ?to)\n                    (DATA-SIZE ?d ?size)\n                    (CAPACITY ?to ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?d ?from)\n                    (not (cached ?d ?to))\n                    (usage ?to ?before))\n :effect (and (cached ?d ?to)\n              (not (usage ?to ?before))\n              (usage ?to ?after)\n              (increase (total-cost) (send-cost ?from ?to ?size))))\n\n(:action process\n :parameters (?in1 ?in2 ?out - data ?sc - script ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (SCRIPT-IO ?sc ?in1 ?in2 ?out)\n                    (DATA-SIZE ?out ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?in1 ?s)\n                    (cached ?in2 ?s)\n                    (not (cached ?out ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?out ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (process-cost ?sc ?s))))\n)\n"
    },
    {
        "batch_id": 2,
        "file_name": "floortile",
        "pddl_domain": ";;Created by Tomas de la Rosa\n;;Domain for painting floor tiles with two colors\n;;See MIT License attached\n\n(define (domain floor-tile)\n(:requirements :typing :action-costs)\n(:types robot tile color - object)\n\n(:predicates \t\n\t\t(robot-at ?r - robot ?x - tile)\n\t\t(up ?x - tile ?y - tile)\n\t\t(down ?x - tile ?y - tile)\n\t\t(right ?x - tile ?y - tile)\n\t\t(left ?x - tile ?y - tile)\n\t\t\n\t\t(clear ?x - tile)\n                (painted ?x - tile ?c - color)\n\t\t(robot-has ?r - robot ?c - color)\n                (available-color ?c - color)\n                (free-color ?r - robot))\n\n(:functions (total-cost) - number)\n\n(:action change-color\n  :parameters (?r - robot ?c - color ?c2 - color)\n  :precondition (and (robot-has ?r ?c) (available-color ?c2))\n  :effect (and (not (robot-has ?r ?c)) (robot-has ?r ?c2)\n               (increase (total-cost) 5))\n) \n\n\n(:action paint-up\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n               (increase (total-cost) 2))\n)\n\n\n(:action paint-down\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n(increase (total-cost) 2))\n)\n\n\n; Robot movements\n(:action up \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 3))\n)\n\n\n(:action down \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n(:action right \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (right ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n\t       (increase (total-cost) 1))\n)\n\n(:action left \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (left ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n)\n",
        "id": 82,
        "tokens": 5870,
        "corrected_description": "### General\nThis domain is designed for a scenario where robots are tasked with painting floor tiles in two colors. It includes actions for robots to change colors, paint tiles in different directions, and move around the grid of tiles. The domain supports action costs, allowing for the calculation of the total cost associated with a sequence of actions.\n\n### Types\n- **robot**: Represents the robots that will perform the painting and moving actions.\n- **tile**: Represents the individual tiles on the floor that can be painted.\n- **color**: Represents the colors available for painting the tiles.\n\n### Predicates\n- **(robot-at ?r - robot ?x - tile)**: Indicates that robot ?r is located at tile ?x.\n- **(up ?x - tile ?y - tile)**: Indicates that tile ?x is directly above tile ?y.\n- **(down ?x - tile ?y - tile)**: Indicates that tile ?x is directly below tile ?y.\n- **(right ?x - tile ?y - tile)**: Indicates that tile ?x is directly to the right of tile ?y.\n- **(left ?x - tile ?y - tile)**: Indicates that tile ?x is directly to the left of tile ?y.\n- **(clear ?x - tile)**: Indicates that tile ?x is clear and can be painted or moved onto.\n- **(painted ?x - tile ?c - color)**: Indicates that tile ?x has been painted with color ?c.\n- **(robot-has ?r - robot ?c - color)**: Indicates that robot ?r is currently holding paint of color ?c.\n- **(available-color ?c - color)**: Indicates that color ?c is available for painting.\n- **(free-color ?r - robot)**: Indicates that the robot ?r is not currently holding any paint color.\n\n### Functions\n- **(total-cost)**: Represents the total cost accumulated through actions performed by the robots.\n\n### Actions\n- **change-color <?r> <?c> <?c2>**: Allows a robot to change the color it is currently holding to another available color. This action increases the total cost by 5.  \n\n- **paint-up <?r> <?y> <?x> <?c>**: Allows a robot to paint the tile directly above its current position, provided the tile is clear. This action increases the total cost by 2.  \n\n- **paint-down <?r> <?y> <?x> <?c>**: Allows a robot to paint the tile directly below its current position, provided the tile is clear. This action increases the total cost by 2.  \n\n- **up <?r> <?x> <?y>**: Moves the robot to the tile directly above its current position if the tile is clear. This action increases the total cost by 3.  \n\n- **down <?r> <?x> <?y>**: Moves the robot to the tile directly below its current position if the tile is clear. This action increases the total cost by 1.  \n\n- **right <?r> <?x> <?y>**: Moves the robot to the tile directly to its right if the tile is clear. This action increases the total cost by 1.  \n\n- **left <?r> <?x> <?y>**: Moves the robot to the tile directly to its left if the tile is clear. This action increases the total cost by 1.",
        "pddl_domain_processed": "\n\n(define (domain floor-tile)\n(:requirements :typing :action-costs)\n(:types robot tile color - object)\n\n(:predicates \t\n\t\t(robot-at ?r - robot ?x - tile)\n\t\t(up ?x - tile ?y - tile)\n\t\t(down ?x - tile ?y - tile)\n\t\t(right ?x - tile ?y - tile)\n\t\t(left ?x - tile ?y - tile)\n\n\t\t(clear ?x - tile)\n                (painted ?x - tile ?c - color)\n\t\t(robot-has ?r - robot ?c - color)\n                (available-color ?c - color)\n                (free-color ?r - robot))\n\n(:functions (total-cost) - number)\n\n(:action change-color\n  :parameters (?r - robot ?c - color ?c2 - color)\n  :precondition (and (robot-has ?r ?c) (available-color ?c2))\n  :effect (and (not (robot-has ?r ?c)) (robot-has ?r ?c2)\n               (increase (total-cost) 5))\n) \n\n(:action paint-up\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n               (increase (total-cost) 2))\n)\n\n(:action paint-down\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n(increase (total-cost) 2))\n)\n\n(:action up \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 3))\n)\n\n(:action down \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n(:action right \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (right ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n\t       (increase (total-cost) 1))\n)\n\n(:action left \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (left ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n)\n"
    },
    {
        "batch_id": 2,
        "file_name": "satellite",
        "pddl_domain": "(define (domain satellite)\n  (:requirements :strips :typing)\n  (:types satellite direction instrument mode)\n  (:predicates \n\t(on_board ?i - instrument ?s - satellite)\n\t(supports ?i - instrument ?m - mode)\n\t(pointing ?s - satellite ?d - direction)\n\t(power_avail ?s - satellite)\n\t(power_on ?i - instrument)\n\t(calibrated ?i - instrument)\n\t(have_image ?d - direction ?m - mode)\n\t(calibration_target ?i - instrument ?d - direction))\n \n  (:action turn_to\n   :parameters (?s - satellite ?d_new - direction ?d_prev - direction)\n   :precondition (and (pointing ?s ?d_prev))\n   :effect (and  (pointing ?s ?d_new)\n                 (not (pointing ?s ?d_prev))))\n \n  (:action switch_on\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s) \n                      (power_avail ?s))\n   :effect (and (power_on ?i)\n                (not (calibrated ?i))\n                (not (power_avail ?s))))\n\n  (:action switch_off\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s)\n                      (power_on ?i))\n   :effect (and (not (power_on ?i))\n                (power_avail ?s)))\n\n  (:action calibrate\n   :parameters (?s - satellite ?i - instrument ?d - direction)\n   :precondition (and (on_board ?i ?s)\n\t\t      (calibration_target ?i ?d)\n                      (pointing ?s ?d)\n                      (power_on ?i))\n   :effect (calibrated ?i))\n\n  (:action take_image\n   :parameters (?s - satellite ?d - direction ?i - instrument ?m - mode)\n   :precondition (and (calibrated ?i)\n                      (on_board ?i ?s)\n                      (supports ?i ?m)\n                      (power_on ?i)\n                      (pointing ?s ?d))\n   :effect (have_image ?d ?m)))\n\n",
        "id": 89,
        "tokens": 5489,
        "corrected_description": "### General\nThis domain models a satellite system where satellites can turn to point in different directions, switch instruments on and off, calibrate instruments, and take images in various modes. The goal is to manage the satellite's operations to ensure it captures required images while managing its power and instrument calibration.\n\n### Types\n- **satellite**: Represents the satellites in the domain.\n- **direction**: Represents the directions in which the satellite can point.\n- **instrument**: Represents the instruments onboard the satellite.\n- **mode**: Represents the modes in which the satellite can capture images.\n\n### Predicates\n- **(on_board ?i - instrument ?s - satellite)**: Indicates that instrument ?i is on board satellite ?s.\n- **(supports ?i - instrument ?m - mode)**: Indicates that instrument ?i supports capturing images in mode ?m.\n- **(pointing ?s - satellite ?d - direction)**: Indicates that satellite ?s is pointing in direction ?d.\n- **(power_avail ?s - satellite)**: Indicates that there is power available on satellite ?s.\n- **(power_on ?i - instrument)**: Indicates that instrument ?i is powered on.\n- **(calibrated ?i - instrument)**: Indicates that instrument ?i is calibrated.\n- **(have_image ?d - direction ?m - mode)**: Indicates that an image has been captured in direction ?d in mode ?m.\n- **(calibration_target ?i - instrument ?d - direction)**: Indicates that direction ?d is a calibration target for instrument ?i.\n\n### Actions\n- **turn_to <?s> <?d_new> <?d_prev>**: Allows a satellite to turn from one direction to another. \n  \n- **switch_on <?i> <?s>**: Allows turning on an instrument on a satellite. \n  \n- **switch_off <?i> <?s>**: Allows turning off an instrument on a satellite. \n  \n- **calibrate <?s> <?i> <?d>**: Allows calibrating an instrument on a satellite if the instrument is on board, the satellite is pointing at the calibration target, and the instrument is powered on. The effect is that the instrument is calibrated.\n  \n- **take_image <?s> <?d> <?i> <?m>**: Allows a satellite to take an image in a specific direction and mode if the instrument is calibrated, on board, supports the mode, is powered on, and the satellite is pointing in the direction. The effect is that an image has been captured in the specified direction and mode.",
        "pddl_domain_processed": "(define (domain satellite)\n  (:requirements :strips :typing)\n  (:types satellite direction instrument mode)\n  (:predicates \n\t(on_board ?i - instrument ?s - satellite)\n\t(supports ?i - instrument ?m - mode)\n\t(pointing ?s - satellite ?d - direction)\n\t(power_avail ?s - satellite)\n\t(power_on ?i - instrument)\n\t(calibrated ?i - instrument)\n\t(have_image ?d - direction ?m - mode)\n\t(calibration_target ?i - instrument ?d - direction))\n\n  (:action turn_to\n   :parameters (?s - satellite ?d_new - direction ?d_prev - direction)\n   :precondition (and (pointing ?s ?d_prev))\n   :effect (and  (pointing ?s ?d_new)\n                 (not (pointing ?s ?d_prev))))\n\n  (:action switch_on\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s) \n                      (power_avail ?s))\n   :effect (and (power_on ?i)\n                (not (calibrated ?i))\n                (not (power_avail ?s))))\n\n  (:action switch_off\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s)\n                      (power_on ?i))\n   :effect (and (not (power_on ?i))\n                (power_avail ?s)))\n\n  (:action calibrate\n   :parameters (?s - satellite ?i - instrument ?d - direction)\n   :precondition (and (on_board ?i ?s)\n\t\t      (calibration_target ?i ?d)\n                      (pointing ?s ?d)\n                      (power_on ?i))\n   :effect (calibrated ?i))\n\n  (:action take_image\n   :parameters (?s - satellite ?d - direction ?i - instrument ?m - mode)\n   :precondition (and (calibrated ?i)\n                      (on_board ?i ?s)\n                      (supports ?i ?m)\n                      (power_on ?i)\n                      (pointing ?s ?d))\n   :effect (have_image ?d ?m)))\n\n"
    },
    {
        "batch_id": 2,
        "file_name": "cavediving",
        "pddl_domain": ";; Cave Diving ADL\n;; Authors: Nathan Robinson,\n;;          Christian Muise, and\n;;          Charles Gretton\n\n(define (domain cave-diving-adl)\n  (:requirements :typing :action-costs :adl :conditional-effects)\n  (:types location diver tank quantity)\n  (:predicates\n    (at-tank ?t - tank ?l - location)\n    (in-storage ?t - tank)\n    (full ?t - tank)\n    (next-tank ?t1 - tank ?t2 - tank)\n    (at-diver ?d - diver ?l - location)\n    (available ?d - diver)\n    (at-surface ?d - diver)\n    (decompressing ?d - diver)\n    (precludes ?d1 - diver ?d2 - diver)\n    (cave-entrance ?l - location)\n    (connected ?l1 - location ?l2 - location)\n    (next-quantity ?q1 - quantity ?q2 - quantity)\n    (holding ?d - diver ?t - tank)\n    (capacity ?d - diver ?q - quantity)\n    (have-photo ?l - location)\n    (in-water )\n  )\n\n  (:functions\n    (hiring-cost ?d - diver) - number\n    (other-cost) - number\n    (total-cost) - number\n  )\n\n  (:action hire-diver\n    :parameters (?d1 - diver)\n    :precondition (and      (available ?d1)\n                       (not (in-water)) \n                  )\n    :effect (and (at-surface ?d1)\n                 (not (available ?d1))\n                 (forall (?d2 - diver)\n                     (when (precludes ?d1 ?d2) (not (available ?d2))))\n                 (in-water)\n                 (increase (total-cost) (hiring-cost ?d1))\n            )\n  )\n\n  (:action prepare-tank\n    :parameters (?d - diver ?t1 ?t2 - tank ?q1 ?q2 - quantity)\n    :precondition (and (at-surface ?d)\n                       (in-storage ?t1)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                       (next-tank ?t1 ?t2)\n                  )\n    :effect (and (not (in-storage ?t1))\n                 (not (capacity ?d ?q2))\n                      (in-storage ?t2)\n                      (full ?t1)\n                      (capacity ?d ?q1)\n                      (holding ?d ?t1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action enter-water\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-surface ?d)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-surface ?d))\n                      (at-diver ?d ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action pickup-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (at-tank ?t ?l)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                  )\n    :effect (and (not (at-tank ?t ?l))\n                 (not (capacity ?d ?q2))\n                      (holding ?d ?t)\n                      (capacity ?d ?q1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action drop-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q1)\n                  )\n    :effect (and (not (holding ?d ?t))\n                 (not (capacity ?d ?q1))\n                      (at-tank ?t ?l)\n                      (capacity ?d ?q2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action swim\n    :parameters (?d - diver ?t - tank ?l1 ?l2 - location)\n    :precondition (and (at-diver ?d ?l1)\n                       (holding ?d ?t)\n                       (full ?t)\n                       (connected ?l1 ?l2)\n                  )\n    :effect (and (not (at-diver ?d ?l1))\n                 (not (full ?t))\n                      (at-diver ?d ?l2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action photograph\n    :parameters (?d - diver ?l - location ?t - tank)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (full ?t)\n                  )\n    :effect (and (not (full ?t))\n                      (have-photo ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action decompress\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-diver ?d ?l)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-diver ?d ?l))\n                      (decompressing ?d)\n                 (not (in-water))\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n)\n",
        "id": 106,
        "tokens": 6400,
        "corrected_description": "### General\nThis domain models the activities involved in cave diving, including hiring divers, preparing and managing air tanks, entering water, picking up and dropping tanks, swimming between locations, taking photographs underwater, and decompressing after a dive. It incorporates advanced planning features such as action costs and conditional effects.\n\n### Types\n- **location**: Represents different locations in the cave diving scenario.\n- **diver**: Represents the divers involved in the cave diving.\n- **tank**: Represents air tanks used by divers.\n- **quantity**: Represents different quantities of air or capacity.\n\n### Predicates\n- **(at-tank ?t - tank ?l - location)**: Indicates that tank ?t is at location ?l.\n- **(in-storage ?t - tank)**: Indicates that tank ?t is in storage.\n- **(full ?t - tank)**: Indicates that tank ?t is full.\n- **(next-tank ?t1 - tank ?t2 - tank)**: Indicates that tank ?t2 is the next tank after ?t1 in some predefined ordering.\n- **(at-diver ?d - diver ?l - location)**: Indicates that diver ?d is at location ?l.\n- **(available ?d - diver)**: Indicates that diver ?d is available for hire.\n- **(at-surface ?d - diver)**: Indicates that diver ?d is at the surface.\n- **(decompressing ?d - diver)**: Indicates that diver ?d is decompressing.\n- **(precludes ?d1 - diver ?d2 - diver)**: Indicates that hiring diver ?d1 precludes hiring diver ?d2.\n- **(cave-entrance ?l - location)**: Indicates that location ?l is a cave entrance.\n- **(connected ?l1 - location ?l2 - location)**: Indicates that location ?l1 is connected to location ?l2.\n- **(next-quantity ?q1 - quantity ?q2 - quantity)**: Indicates that quantity ?q2 is the next quantity after ?q1 in some predefined ordering.\n- **(holding ?d - diver ?t - tank)**: Indicates that diver ?d is holding tank ?t.\n- **(capacity ?d - diver ?q - quantity)**: Indicates the capacity of air that diver ?d can carry is ?q.\n- **(have-photo ?l - location)**: Indicates that a photo has been taken at location ?l.\n- **(in-water)**: Indicates that some activity is happening in the water.\n\n### Functions\n- **(hiring-cost ?d - diver)**: Represents the cost of hiring diver ?d.\n- **(other-cost)**: Represents other costs associated with actions.\n- **(total-cost)**: Represents the total cost accumulated through actions.\n\n### Actions\n- **hire-diver <?d1>**: Hires a diver (?d1) and increases the total cost by the hiring cost of the diver.  \n\n- **prepare-tank <?d> <?t1> <?t2> <?q1> <?q2>**: Prepares a tank (?t1) for a diver (?d) and increases the total cost by other cost.  \n\n- **enter-water <?d> <?l>**: Enters the water at a cave entrance (?l) and increases the total cost by other cost.  \n\n- **pickup-tank <?d> <?t> <?l> <?q1> <?q2>**: Picks up a tank (?t) at a location (?l) and increases the total cost by other cost.  \n\n- **drop-tank <?d> <?t> <?l> <?q1> <?q2>**: Drops a tank (?t) at a location (?l) and increases the total cost by other cost.  \n\n- **swim <?d> <?t> <?l1> <?l2>**: Swims from one location (?l1) to another location (?l2) while holding a tank (?t) and increases the total cost by other cost.  \n\n- **photograph <?d> <?l> <?t>**: Takes a photograph at a location (?l) while holding a tank (?t) and increases the total cost by other cost.  \n\n- **decompress <?d> <?l>**: Decompresses at a cave entrance (?l) and increases the total cost by other cost.",
        "pddl_domain_processed": "\n\n(define (domain cave-diving-adl)\n  (:requirements :typing :action-costs :adl :conditional-effects)\n  (:types location diver tank quantity)\n  (:predicates\n    (at-tank ?t - tank ?l - location)\n    (in-storage ?t - tank)\n    (full ?t - tank)\n    (next-tank ?t1 - tank ?t2 - tank)\n    (at-diver ?d - diver ?l - location)\n    (available ?d - diver)\n    (at-surface ?d - diver)\n    (decompressing ?d - diver)\n    (precludes ?d1 - diver ?d2 - diver)\n    (cave-entrance ?l - location)\n    (connected ?l1 - location ?l2 - location)\n    (next-quantity ?q1 - quantity ?q2 - quantity)\n    (holding ?d - diver ?t - tank)\n    (capacity ?d - diver ?q - quantity)\n    (have-photo ?l - location)\n    (in-water )\n  )\n\n  (:functions\n    (hiring-cost ?d - diver) - number\n    (other-cost) - number\n    (total-cost) - number\n  )\n\n  (:action hire-diver\n    :parameters (?d1 - diver)\n    :precondition (and      (available ?d1)\n                       (not (in-water)) \n                  )\n    :effect (and (at-surface ?d1)\n                 (not (available ?d1))\n                 (forall (?d2 - diver)\n                     (when (precludes ?d1 ?d2) (not (available ?d2))))\n                 (in-water)\n                 (increase (total-cost) (hiring-cost ?d1))\n            )\n  )\n\n  (:action prepare-tank\n    :parameters (?d - diver ?t1 ?t2 - tank ?q1 ?q2 - quantity)\n    :precondition (and (at-surface ?d)\n                       (in-storage ?t1)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                       (next-tank ?t1 ?t2)\n                  )\n    :effect (and (not (in-storage ?t1))\n                 (not (capacity ?d ?q2))\n                      (in-storage ?t2)\n                      (full ?t1)\n                      (capacity ?d ?q1)\n                      (holding ?d ?t1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action enter-water\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-surface ?d)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-surface ?d))\n                      (at-diver ?d ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action pickup-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (at-tank ?t ?l)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                  )\n    :effect (and (not (at-tank ?t ?l))\n                 (not (capacity ?d ?q2))\n                      (holding ?d ?t)\n                      (capacity ?d ?q1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action drop-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q1)\n                  )\n    :effect (and (not (holding ?d ?t))\n                 (not (capacity ?d ?q1))\n                      (at-tank ?t ?l)\n                      (capacity ?d ?q2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action swim\n    :parameters (?d - diver ?t - tank ?l1 ?l2 - location)\n    :precondition (and (at-diver ?d ?l1)\n                       (holding ?d ?t)\n                       (full ?t)\n                       (connected ?l1 ?l2)\n                  )\n    :effect (and (not (at-diver ?d ?l1))\n                 (not (full ?t))\n                      (at-diver ?d ?l2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action photograph\n    :parameters (?d - diver ?l - location ?t - tank)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (full ?t)\n                  )\n    :effect (and (not (full ?t))\n                      (have-photo ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action decompress\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-diver ?d ?l)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-diver ?d ?l))\n                      (decompressing ?d)\n                 (not (in-water))\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n)\n"
    },
    {
        "batch_id": 2,
        "file_name": "snake",
        "pddl_domain": "; Snake is not a game where everything is known a priori. \n; Therefore we make two modifications: \n; 1. The player knows where points will spawn. \n; 2. Points can spawn inside the snake, but they can only be collected by the head of the snake.\n; 3. There is a constant number of points at a time and no two points can spawn in the same location\n; Based on the submission\n\n(define (domain snake)\n\t(:requirements :strips :negative-preconditions)\n\n\t(:constants dummyPoint)\n\n\t(:predicates \n\t\t(isAdjacent ?x ?y) ;up down left right of a field\n\t\t(tailSnake ?x) ;the last field of the snake\n\t\t(headSnake ?x) ;the first field of the snake\n                (nextSnake ?x ?y) ;pieces of the snake that are connected. from front to back\n\t\t(blocked ?x) ;a field that is occupied by the snake or by an obstacle\n\t\t(spawn ?x) ;next point that will spawn\n\t\t(nextSpawn ?x ?y) ;point y will spawn after point x\n\t\t(isPoint ?x) ;a field that has a point that can be collected by the snake\n\t)\n\n\t(:action move\n\t\t:parameters (?head ?newHead ?tail ?newTail)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n         \t\t(tailSnake ?tail)\n\t\t\t(nextSnake ?newTail ?tail)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(not (isPoint ?newHead))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (blocked ?tail))\n\t\t\t(not (tailSnake ?tail))\n\t\t\t(not (nextSnake ?newTail ?tail))\n\t\t\t(tailSnake ?newTail)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-spawn\n\t\t:parameters  (?head ?newHead ?spawnPoint ?nextSpawnPoint)\n\t\t:precondition (and\n\t\t\t      (headSnake ?head)\n\t\t\t      (isAdjacent ?head ?newHead)\n\t\t\t      (not (blocked ?newHead))\n\t\t\t      (isPoint ?newHead)\n\t\t\t      (spawn ?spawnPoint)\n\t\t\t      (nextSpawn ?spawnPoint ?nextSpawnPoint)\n\t\t\t      (not (= ?spawnPoint dummyPoint))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t(isPoint ?spawnPoint)\n\t\t\t(not (spawn ?spawnPoint))\n\t\t\t(spawn ?nextSpawnPoint)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-no-spawn\n\t\t:parameters  (?head ?newHead)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(isPoint ?newHead)\n\t\t\t(spawn dummyPoint)\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t)\n\t)\n)",
        "id": 109,
        "tokens": 5864,
        "corrected_description": "### General\nThis domain models a simplified version of the classic Snake game, incorporating elements such as the snake's movement, point collection, and the spawning of points on the game field. The game is adapted to a planning environment by assuming the player knows where and in what order points will spawn. Points can spawn inside the snake but are only collectible by the snake's head. The domain ensures a constant number of points at any time and prevents points from spawning in the same location.\n\n### Predicates\n- (isAdjacent ?x ?y): Determines if two fields are adjacent (up, down, left, right) to each other.\n- (tailSnake ?x): Identifies the tail (last field) of the snake.\n- (headSnake ?x): Identifies the head (first field) of the snake.\n- (nextSnake ?x ?y): Connects pieces of the snake from front to back, indicating which piece follows which.\n- (blocked ?x): Marks a field as occupied by the snake or an obstacle, making it impassable.\n- (spawn ?x): Marks the next point that will spawn on the field.\n- (nextSpawn ?x ?y): Indicates that point y will spawn after point x, establishing an order of spawning.\n- (isPoint ?x): Marks a field as containing a point that can be collected by the snake.\n\n### Actions\n- **move <?head> <?newHead> <?tail> <?newTail>**: Allows the snake to move to a new position by updating the head and tail positions. \n\n- **move-and-eat-spawn <?head> <?newHead> <?spawnPoint> <?nextSpawnPoint>**: Allows the snake to move to a new position and eat a spawn point, while also updating the spawn points.  \n\n- **move-and-eat-no-spawn <?head> <?newHead>**: Allows the snake to move to a new position and eat a point when no new spawn points are available.",
        "pddl_domain_processed": "\n\n(define (domain snake)\n\t(:requirements :strips :negative-preconditions)\n\n\t(:constants dummyPoint)\n\n\t(:predicates \n\t\t(isAdjacent ?x ?y) \n\t\t(tailSnake ?x) \n\t\t(headSnake ?x) \n                (nextSnake ?x ?y) \n\t\t(blocked ?x) \n\t\t(spawn ?x) \n\t\t(nextSpawn ?x ?y) \n\t\t(isPoint ?x) \n\t)\n\n\t(:action move\n\t\t:parameters (?head ?newHead ?tail ?newTail)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n         \t\t(tailSnake ?tail)\n\t\t\t(nextSnake ?newTail ?tail)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(not (isPoint ?newHead))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (blocked ?tail))\n\t\t\t(not (tailSnake ?tail))\n\t\t\t(not (nextSnake ?newTail ?tail))\n\t\t\t(tailSnake ?newTail)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-spawn\n\t\t:parameters  (?head ?newHead ?spawnPoint ?nextSpawnPoint)\n\t\t:precondition (and\n\t\t\t      (headSnake ?head)\n\t\t\t      (isAdjacent ?head ?newHead)\n\t\t\t      (not (blocked ?newHead))\n\t\t\t      (isPoint ?newHead)\n\t\t\t      (spawn ?spawnPoint)\n\t\t\t      (nextSpawn ?spawnPoint ?nextSpawnPoint)\n\t\t\t      (not (= ?spawnPoint dummyPoint))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t(isPoint ?spawnPoint)\n\t\t\t(not (spawn ?spawnPoint))\n\t\t\t(spawn ?nextSpawnPoint)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-no-spawn\n\t\t:parameters  (?head ?newHead)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(isPoint ?newHead)\n\t\t\t(spawn dummyPoint)\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t)\n\t)\n)"
    },
    {
        "batch_id": 3,
        "file_name": "itl-ed_llm-dp_alfworld_domain.pddl",
        "pddl_domain": "(define (domain alfred)\n    (:predicates\n        (isReceptacle ?o - object) ; true if the object is a receptacle\n        (atReceptacleLocation ?r - object) ; true if the robot is at the receptacle location\n        (inReceptacle ?o - object ?r - object) ; true if object ?o is in receptacle ?r\n        (openable ?r - object) ; true if a receptacle is openable\n        (opened ?r - object) ; true if a receptacle is opened\n        (isLight ?o - object) ; true if an object is light source\n        (examined ?o - object ?l - object) ; whether the object has been looked at with light\n        (holds ?o - object) ; object ?o is held by robot\n        (isClean ?o - object) ; true if the object has been cleaned in sink\n        (isHot ?o - object) ; true if the object has been heated up\n        (isCool ?o - object) ; true if the object has been cooled\n        (isSink ?o - object) ; true if the object is a sink\n        (isMicrowave ?o - object) ; true if the object is a microwave\n        (isFridge ?o - object) ; true if the object is a fridge\n    )\n\n    ;; Examine an object (being held) using light source at location\n    (:action examineObjectInLight\n        :parameters (?o - object ?l - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isLight ?l) ; is light source\n            (holds ?o) ; agent holds object\n            (atReceptacleLocation ?r) ; agent is at receptacle\n            (inReceptacle ?l ?r) ; light source is in receptacle\n            (or\n                (not (openable ?r)) ; receptacle is not openable\n                (opened ?r) ; object is in receptacle and receptacle is open\n            )\n        )\n        :effect (examined ?o ?l)\n    )\n\n    ;; robot goes to receptacle\n    (:action GotoReceptacle\n        :parameters (?rEnd - object)\n        :precondition (isReceptacle ?rEnd)\n        :effect (and\n            (atReceptacleLocation ?rEnd)\n            (forall\n                (?r - object)\n                (when\n                    (and\n                        (isReceptacle ?r)\n                        (not (= ?r ?rEnd))\n                    )\n                    (not (atReceptacleLocation ?r))\n                )\n            )\n        )\n    )\n\n    ; ;; robot opens receptacle\n    (:action OpenReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (not (opened ?r))\n        )\n        :effect (opened ?r)\n    )\n\n    ;; robot closes receptacle\n    (:action CloseReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n\n    ;; robot picks up  object  from a receptacle\n    (:action PickupObjectFromReceptacle\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r) ; agent is at receptacle\n            (inReceptacle ?o ?r) ; object is in/on receptacle\n            (not (isLight ?o)) ; object is not light source\n            (forall ; agent's hands are empty.\n                (?t - object)\n                (not (holds ?t))\n            )\n            (or\n                (not (openable ?r)) ; receptacle is not openable\n                (opened ?r) ; object is in receptacle and receptacle is open\n            )\n        )\n        :effect (and\n            (not (inReceptacle ?o ?r)) ; object is not in receptacle\n            (holds ?o) ; agent holds object\n        )\n    )\n\n    ;; robot puts down an object\n    (:action PutObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n            (or (not (openable ?r)) (opened ?r)) ; receptacle is opened if it is openable\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n            (not (holds ?o))\n        )\n    )\n\n    ; ;; agent cleans some object\n    (:action CleanObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isSink ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (isClean ?o)\n    )\n\n    ;; robot heats-up some object\n    (:action HeatObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isMicrowave ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isHot ?o)\n            (not (isCool ?o))\n        )\n    )\n\n    ;; robot cools some object\n    (:action CoolObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isFridge ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isCool ?o)\n            (not (isHot ?o))\n        )\n    )\n)",
        "id": 119,
        "tokens": 6438,
        "corrected_description": "### General\nYou are a robot named Alfred involved in various household tasks such as cleaning, heating, cooling objects, and managing items within receptacles like sinks, microwaves, and fridges. The domain focuses on the manipulation of objects and receptacles, including opening and closing receptacles, examining objects with light, and changing the state of objects (clean, hot, cool).\n\n### Predicates\n- (isReceptacle ?o): True if the object is a receptacle.\n- (atReceptacleLocation ?r): True if the robot is at the receptacle location.\n- (inReceptacle ?o ?r): True if object ?o is in receptacle ?r.\n- (openable ?r): True if a receptacle is openable.\n- (opened ?r): True if a receptacle is opened.\n- (isLight ?o): True if an object is a light source.\n- (examined ?o ?l): True if the object has been examined with light.\n- (holds ?o): True if the robot is holding object ?o.\n- (isClean ?o): True if the object has been cleaned in a sink.\n- (isHot ?o): True if the object has been heated up.\n- (isCool ?o): True if the object has been cooled.\n- (isSink ?o): True if the object is a sink.\n- (isMicrowave ?o): True if the object is a microwave.\n- (isFridge ?o): True if the object is a fridge.\n\n### Actions\n- **examineObjectInLight <?o> <?l> <?r>**: Allows the robot to examine an object it is holding using a light source at a receptacle location. The object is considered examined after this action.  \n\n- **GotoReceptacle <?rEnd>**: Moves the robot to a specified receptacle location. This action ensures the robot is no longer at any other receptacle locations.  \n\n- **OpenReceptacle <?r>**: Opens a receptacle.  \n\n- **CloseReceptacle <?r>**: Closes an openable receptacle.  \n\n- **PickupObjectFromReceptacle <?o> <?r>**: Allows the robot to pick up an object from a receptacle which is open or not openable.  \n\n- **PutObject <?o> <?r>**: Places an object the robot is holding into a receptacle which is open or not openable.  \n\n- **CleanObject <?o> <?r>**: Cleans an object the robot is holding, provided the robot is at a sink.  \n\n- **HeatObject <?o> <?r>**: Heats an object the robot is holding, provided the robot is at a microwave.  \n\n- **CoolObject <?o> <?r>**: Cools an object the robot is holding, provided the robot is at a fridge.",
        "pddl_domain_processed": "(define (domain alfred)\n    (:predicates\n        (isReceptacle ?o - object) \n        (atReceptacleLocation ?r - object) \n        (inReceptacle ?o - object ?r - object) \n        (openable ?r - object) \n        (opened ?r - object) \n        (isLight ?o - object) \n        (examined ?o - object ?l - object) \n        (holds ?o - object) \n        (isClean ?o - object) \n        (isHot ?o - object) \n        (isCool ?o - object) \n        (isSink ?o - object) \n        (isMicrowave ?o - object) \n        (isFridge ?o - object) \n    )\n\n    (:action examineObjectInLight\n        :parameters (?o - object ?l - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isLight ?l) \n            (holds ?o) \n            (atReceptacleLocation ?r) \n            (inReceptacle ?l ?r) \n            (or\n                (not (openable ?r)) \n                (opened ?r) \n            )\n        )\n        :effect (examined ?o ?l)\n    )\n\n    (:action GotoReceptacle\n        :parameters (?rEnd - object)\n        :precondition (isReceptacle ?rEnd)\n        :effect (and\n            (atReceptacleLocation ?rEnd)\n            (forall\n                (?r - object)\n                (when\n                    (and\n                        (isReceptacle ?r)\n                        (not (= ?r ?rEnd))\n                    )\n                    (not (atReceptacleLocation ?r))\n                )\n            )\n        )\n    )\n\n    (:action OpenReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (not (opened ?r))\n        )\n        :effect (opened ?r)\n    )\n\n    (:action CloseReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n\n    (:action PickupObjectFromReceptacle\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r) \n            (inReceptacle ?o ?r) \n            (not (isLight ?o)) \n            (forall \n                (?t - object)\n                (not (holds ?t))\n            )\n            (or\n                (not (openable ?r)) \n                (opened ?r) \n            )\n        )\n        :effect (and\n            (not (inReceptacle ?o ?r)) \n            (holds ?o) \n        )\n    )\n\n    (:action PutObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n            (or (not (openable ?r)) (opened ?r)) \n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n            (not (holds ?o))\n        )\n    )\n\n    (:action CleanObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isSink ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (isClean ?o)\n    )\n\n    (:action HeatObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isMicrowave ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isHot ?o)\n            (not (isCool ?o))\n        )\n    )\n\n    (:action CoolObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isFridge ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isCool ?o)\n            (not (isHot ?o))\n        )\n    )\n)"
    },
    {
        "batch_id": 3,
        "file_name": "PIxLLab_URSSimEnvironments_urs_domain.pddl",
        "pddl_domain": "; Action's :effect must have 'and'\n; Problem definition's :init must have 'and'\n; All :types must be in problem defintion's :objects\n(define (domain urs)\n  (:requirements :strips :typing)\n  (:types drone_id key_id loc_id)\n  (:predicates\n    (active_region ?loc_id_sw - loc_id ?loc_id_ne - loc_id)\n    (drone_above ?drone_id - drone_id ?loc_id - loc_id)\n    (drone_at ?drone_id - drone_id ?loc_id - loc_id)\n    (is_location ?loc_id - loc_id)\n    (is_occupied ?loc_id - loc_id)\n    (key_at ?key_id - key_id ?loc_id - loc_id)\n    (key_picked ?key_id - key_id)\n    (key_with ?key_id - key_id ?drone_id - drone_id)\n    (took_off ?drone_id - drone_id)\n  )\n  (:action active_region_update\n    :parameters (?loc_id_sw_old ?loc_id_ne_old ?loc_id_sw_new ?loc_id_ne_new - loc_id)\n    :precondition (active_region ?loc_id_sw_old ?loc_id_ne_old)\n    :effect (and (not (active_region ?loc_id_sw_old ?loc_id_ne_old)) (active_region ?loc_id_sw_new ?loc_id_ne_new))\n  )\n  (:action add_location\n    :parameters (?loc_id - loc_id)\n    :precondition (and (not (is_location ?loc_id)))\n    :effect (and (is_location ?loc_id) (not (is_occupied ?loc_id)))\n  )\n  (:action fly_above\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_above ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action fly_to\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_at ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action key_add\n    :parameters (?key_id - key_id ?loc_id - loc_id)\n    :precondition (not (key_at ?key_id ?loc_id))\n    :effect (and (key_at ?key_id ?loc_id) (not (key_picked ?key_id)))\n  )\n  (:action key_pick\n    :parameters (?drone_id - drone_id ?key_id - key_id ?drone_loc_id ?key_loc_id - loc_id)\n    :precondition (and (not (key_picked ?key_id)) (key_at ?key_id ?key_loc_id) (took_off ?drone_id) (or (drone_above ?drone_id ?drone_loc_id) (drone_at ?drone_id ?drone_loc_id)))\n    :effect (and\n      (not (drone_above ?drone_id ?drone_loc_id))\n      (not (drone_at ?drone_id ?drone_loc_id))\n      (drone_above ?drone_id ?key_loc_id)\n      (key_picked ?key_id)\n      (key_with ?key_id ?drone_id)\n    )\n  )\n  (:action land\n    :parameters (?drone_id - drone_id)\n    :precondition (took_off ?drone_id)\n    :effect (and (not (took_off ?drone_id)))\n  )\n  (:action take_off\n    :parameters (?drone_id - drone_id)\n    :precondition (not (took_off ?drone_id))\n    :effect (and (took_off ?drone_id))\n  )\n)\n",
        "id": 130,
        "tokens": 6061,
        "corrected_description": "### General\nThis domain models an Unmanned Aerial Vehicle (UAV) Surveillance System (URS) where drones can fly over regions, pick up and drop keys at specific locations. The domain includes actions for updating active regions, adding new locations, flying drones, picking up keys, and managing the take-off and landing of drones.\n\n### Types\n- **drone_id**: Represents the identifier for drones.\n- **key_id**: Represents the identifier for keys.\n- **loc_id**: Represents the identifier for locations.\n\n### Predicates\n- **active_region (?loc_id_sw ?loc_id_ne - loc_id)**: Indicates that a region defined by the southwest and northeast location identifiers is currently active.\n- **drone_above (?drone_id - drone_id ?loc_id - loc_id)**: Indicates that a drone is flying above a specific location.\n- **drone_at (?drone_id - drone_id ?loc_id - loc_id)**: Indicates that a drone is at a specific location, implying it is on the ground.\n- **is_location (?loc_id - loc_id)**: Indicates that an identifier corresponds to a valid location.\n- **is_occupied (?loc_id - loc_id)**: Indicates that a location is currently occupied, either by a drone or a key.\n- **key_at (?key_id - key_id ?loc_id - loc_id)**: Indicates that a key is located at a specific location.\n- **key_picked (?key_id - key_id)**: Indicates that a key has been picked up by a drone and is no longer at its original location.\n- **key_with (?key_id - key_id ?drone_id - drone_id)**: Indicates that a key is with a drone, having been picked up.\n- **took_off (?drone_id - drone_id)**: Indicates that a drone has taken off and is capable of flying.\n\n### Actions\n- **active_region_update <?loc_id_sw_old> <?loc_id_ne_old> <?loc_id_sw_new> <?loc_id_ne_new>**: Updates the active region from an old set of southwest and northeast location identifiers to a new set. This action is used to change the focus area of surveillance.  \n\n- **add_location <?loc_id>**: Adds a new location to the system, marking it as unoccupied.  \n\n- **fly_above <?drone_id> <?loc_id_from> <?loc_id_to>**: Moves a drone from one location to fly above another unoccupied location and lands it. This action is used for moving drones without landing.  \n\n- **fly_to <?drone_id> <?loc_id_from> <?loc_id_to>**: Moves a drone from one location to another unoccupied location and lands it. This action is used for repositioning drones on the ground.  \n\n- **key_add <?key_id> <?loc_id>**: Adds a key to a specific location.  \n\n- **key_pick <?drone_id> <?key_id> <?drone_loc_id> <?key_loc_id>**: Picks up a key from a location using a drone.  \n\n- **land <?drone_id>**: Lands a drone, indicating it is no longer flying.  \n\n- **take_off <?drone_id>**: Takes a drone off from the ground, allowing it to fly.",
        "pddl_domain_processed": "\n\n(define (domain urs)\n  (:requirements :strips :typing)\n  (:types drone_id key_id loc_id)\n  (:predicates\n    (active_region ?loc_id_sw - loc_id ?loc_id_ne - loc_id)\n    (drone_above ?drone_id - drone_id ?loc_id - loc_id)\n    (drone_at ?drone_id - drone_id ?loc_id - loc_id)\n    (is_location ?loc_id - loc_id)\n    (is_occupied ?loc_id - loc_id)\n    (key_at ?key_id - key_id ?loc_id - loc_id)\n    (key_picked ?key_id - key_id)\n    (key_with ?key_id - key_id ?drone_id - drone_id)\n    (took_off ?drone_id - drone_id)\n  )\n  (:action active_region_update\n    :parameters (?loc_id_sw_old ?loc_id_ne_old ?loc_id_sw_new ?loc_id_ne_new - loc_id)\n    :precondition (active_region ?loc_id_sw_old ?loc_id_ne_old)\n    :effect (and (not (active_region ?loc_id_sw_old ?loc_id_ne_old)) (active_region ?loc_id_sw_new ?loc_id_ne_new))\n  )\n  (:action add_location\n    :parameters (?loc_id - loc_id)\n    :precondition (and (not (is_location ?loc_id)))\n    :effect (and (is_location ?loc_id) (not (is_occupied ?loc_id)))\n  )\n  (:action fly_above\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_above ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action fly_to\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_at ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action key_add\n    :parameters (?key_id - key_id ?loc_id - loc_id)\n    :precondition (not (key_at ?key_id ?loc_id))\n    :effect (and (key_at ?key_id ?loc_id) (not (key_picked ?key_id)))\n  )\n  (:action key_pick\n    :parameters (?drone_id - drone_id ?key_id - key_id ?drone_loc_id ?key_loc_id - loc_id)\n    :precondition (and (not (key_picked ?key_id)) (key_at ?key_id ?key_loc_id) (took_off ?drone_id) (or (drone_above ?drone_id ?drone_loc_id) (drone_at ?drone_id ?drone_loc_id)))\n    :effect (and\n      (not (drone_above ?drone_id ?drone_loc_id))\n      (not (drone_at ?drone_id ?drone_loc_id))\n      (drone_above ?drone_id ?key_loc_id)\n      (key_picked ?key_id)\n      (key_with ?key_id ?drone_id)\n    )\n  )\n  (:action land\n    :parameters (?drone_id - drone_id)\n    :precondition (took_off ?drone_id)\n    :effect (and (not (took_off ?drone_id)))\n  )\n  (:action take_off\n    :parameters (?drone_id - drone_id)\n    :precondition (not (took_off ?drone_id))\n    :effect (and (took_off ?drone_id))\n  )\n)\n"
    },
    {
        "batch_id": 3,
        "file_name": "inverthermit_pacman_contest_pacman_domain.pddl",
        "pddl_domain": "(define (domain pacman_ai)\n   (:requirements :typing)\n   (:types node)\n   (:predicates\n            (has_food ?location -node)\n            (is_opponent_ghost ?location -node)\n            (is_opponent_pacman ?location -node)\n            (is_visited ?location)\n            (at ?location - node)\n            (connected ?n1 ?n2 - node)\n            (eat_food ?start ?end -node)\n            (move_pacman ?start ?end -node)\n            (move_ghost ?start ?end -node)\n            (eat_pacman ?start ?end -node)\n            ;; get the direction of the ghost from 5 steps away and start to avoid it! (do it in eat and move)\n\t       )\n    (:action move_pacman ;; Pacman move\n         :parameters (?start ?end -node)\n         :precondition (\n         and\n         (at ?start)\n         (not (has_food ?end))\n         (connected ?start ?end)\n         (not (is_opponent_ghost ?end))\n         )\n         :effect (and\n         (not (at ?start))\n         (at ?end)\n         (is_visited ?end)\n         )\n\n      )\n    (:action eat_food\n        :parameters (?start ?end -node)\n        :precondition (\n        and\n        (at ?start)\n        (has_food ?end)\n        (connected ?start ?end)\n        (not (is_opponent_ghost ?end))\n        )\n        :effect (and\n        (at ?end)\n        (not (at ?start))\n        (not (has_food ?end))\n        (is_visited ?end)\n        )\n\n     )\n\n)\n",
        "id": 137,
        "tokens": 5275,
        "corrected_description": "### General\nThis domain is designed for a Pacman AI simulation where the goal is to navigate a Pacman through a maze, eating food while avoiding ghosts. The maze is represented as a graph of connected nodes, where each node can have food, be occupied by an opponent ghost or Pacman, or be marked as visited. The actions defined in this domain allow Pacman to move between nodes, eat food, and avoid ghosts.\n\n### Types\n- node: Represents a location in the maze.\n\n### Predicates\n- (has_food ?location - node): Indicates that there is food at the node ?location.\n- (is_opponent_ghost ?location - node): Indicates that an opponent ghost is present at the node ?location.\n- (is_opponent_pacman ?location - node): Indicates that an opponent Pacman is present at the node ?location.\n- (is_visited ?location): Indicates that the node ?location has been visited by Pacman.\n- (at ?location - node): Indicates that Pacman is currently at the node ?location.\n- (connected ?n1 ?n2 - node): Indicates that node ?n1 is directly connected to node ?n2.\n- (eat_food ?start ?end - node): Represents the action of Pacman eating food when moving from ?start to ?end.\n- (move_pacman ?start ?end - node): Represents the action of Pacman moving from ?start to ?end without eating food.\n- (move_ghost ?start ?end - node): Represents the action of a ghost moving from ?start to ?end.\n- (eat_pacman ?start ?end - node): Represents the action of a ghost eating Pacman when moving from ?start to ?end.\n\n### Actions\n- **move_pacman <?start> <?end>**: Allows Pacman to move from one node to another if the ending node does not have food, does not have an opponent ghost. \n\n- **eat_food <?start> <?end>**: Allows Pacman to eat food when moving from one node to another if the ending node has food, does not have an opponent ghost.",
        "pddl_domain_processed": "(define (domain pacman_ai)\n   (:requirements :typing)\n   (:types node)\n   (:predicates\n            (has_food ?location -node)\n            (is_opponent_ghost ?location -node)\n            (is_opponent_pacman ?location -node)\n            (is_visited ?location)\n            (at ?location - node)\n            (connected ?n1 ?n2 - node)\n            (eat_food ?start ?end -node)\n            (move_pacman ?start ?end -node)\n            (move_ghost ?start ?end -node)\n            (eat_pacman ?start ?end -node)\n\n\t       )\n    (:action move_pacman \n         :parameters (?start ?end -node)\n         :precondition (\n         and\n         (at ?start)\n         (not (has_food ?end))\n         (connected ?start ?end)\n         (not (is_opponent_ghost ?end))\n         )\n         :effect (and\n         (not (at ?start))\n         (at ?end)\n         (is_visited ?end)\n         )\n\n      )\n    (:action eat_food\n        :parameters (?start ?end -node)\n        :precondition (\n        and\n        (at ?start)\n        (has_food ?end)\n        (connected ?start ?end)\n        (not (is_opponent_ghost ?end))\n        )\n        :effect (and\n        (at ?end)\n        (not (at ?start))\n        (not (has_food ?end))\n        (is_visited ?end)\n        )\n\n     )\n\n)\n"
    },
    {
        "batch_id": 3,
        "file_name": "hwhang0917_AI-fall2019_robotdomain.pddl",
        "pddl_domain": "(define (domain robotDomain)\n\n(:requirements :strips :equality :negative-preconditions)\n\n(:predicates \n            ; General predicate\n            (isRoom ?x) ; x is a room\n            (isObject ?x) ;x is an object\n            (isRobot ?x) ;x is a robot\n\n            ; Robot related\n            (clear ?x) ;x robot is free to hold an object\n            (holding ?x) ;robot is holding object x\n            (bot-at ?x) ;robot is at room x\n\n            ; Object location\n            (obj-at ?x ?y) ;object x is at room y\n\n            ; Room accessibility / conditon\n            (can-go ?x ?y) ;can move from room x to room y\n            (has-obj ?x) ;room X has an object\n)\n\n(:action move-without-object\n    :parameters (?start ?dest ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?start) (isRoom ?dest) (isRobot ?robot)\n                \n                ; robot spec\n                (bot-at ?start) ; robot is in start room\n                (clear ?robot) ; robot is free\n\n                ; Room accessibility\n                (not (= ?start ?dest)) ;  room start != room dest\n                (can-go ?start ?dest) ; can go from start to dest\n    )\n    :effect (and    \n                ; Move robot from start room to dest room\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action move-with-object\n    :parameters (?start ?dest ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?start) (isRoom ?dest) (isObject ?object) (isRobot ?robot)\n                \n                ; Object location\n                (not (obj-at ?object ?start)) (not (obj-at ?object ?dest)) ; There are no objects in either room start or end\n                (holding ?object)\n                (not (has-obj ?dest))\n\n                ; robot spec\n                (bot-at ?start) ; robot is in start room\n                (not (clear ?robot)) ; robot is not free\n\n                ; Room accessibility\n                (not (= ?start ?dest)) ;  room start != room dest\n                (can-go ?start ?dest) ; can go from start to dest\n\n    )\n    :effect (and \n                ; Move robot from start room to dest room\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action pickup\n    :parameters (?room ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                ; Object location\n                (obj-at ?object ?room) ; object is at the room\n                (has-obj ?room) ; room has an object\n\n                ; robot spec\n                (bot-at ?room) ; robot is in the room\n                (clear ?robot) ; robot is free \n                (not (holding ?object)) ; robot is NOT holding an object\n    )\n    :effect (and \n                ; Pick up object\n                (not (obj-at ?object ?room)) ; remove object from room\n                (not (has-obj ?room)) ; room no longer has object\n                (not (clear ?robot)) ; robot is no longer free\n                (holding ?object) ; robot is holding the object\n    )\n)\n\n(:action release\n    :parameters (?room ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                ; Object location\n                (not (obj-at ?object ?room)) ; object is NOT at the room\n                (not (has-obj ?room)) ; room does not have object\n\n                ; robot spec\n                (bot-at ?room) ; robot is in the room\n                (not (clear ?robot)) ; robot is NOT free \n                (holding ?object) ; robot is holding an object\n    )\n    :effect (and \n                ; Release object\n                (obj-at ?object ?room) ; put object in room\n                (has-obj ?room) ; room now have an object\n                (clear ?robot) ; robot is free\n                (not (holding ?object)) ; robot is no longer holding the object\n    )\n)\n\n\n)",
        "id": 168,
        "tokens": 5915,
        "corrected_description": "### General\nThis domain describes a robotic agent capable of moving between rooms, picking up objects, and releasing them. The robot can navigate a space with multiple rooms, each potentially containing objects. The robot's tasks involve object manipulation and transportation, requiring careful planning to ensure it picks up and releases objects appropriately while navigating the interconnected rooms.\n\n### Predicates\n- **(isRoom ?x)**: Checks if ?x is a room.\n- **(isObject ?x)**: Checks if ?x is an object.\n- **(isRobot ?x)**: Checks if ?x is a robot.\n- **(clear ?x)**: Indicates that the robot is free to hold an object.\n- **(holding ?x)**: Indicates that the robot is holding object ?x.\n- **(bot-at ?x)**: Indicates that the robot is at room ?x.\n- **(obj-at ?x ?y)**: Indicates that object ?x is at room ?y.\n- **(can-go ?x ?y)**: Indicates that it is possible to move from room ?x to room ?y.\n- **(has-obj ?x)**: Indicates that room ?x contains an object.\n\n### Actions\n- **move-without-object <?start> <?dest> <?robot>**: Allows the robot to move from one room to another without carrying an object.  \n\n- **move-with-object <?start> <?dest> <?object> <?robot>**: Allows the robot to move from one room to another while carrying an object.  \n\n- **pickup <?room> <?object> <?robot>**: Allows the robot to pick up an object from a room.  \n\n- **release <?room> <?object> <?robot>**: Allows the robot to release an object into a room.",
        "pddl_domain_processed": "(define (domain robotDomain)\n\n(:requirements :strips :equality :negative-preconditions)\n\n(:predicates \n\n            (isRoom ?x) \n            (isObject ?x) \n            (isRobot ?x) \n\n            (clear ?x) \n            (holding ?x) \n            (bot-at ?x) \n\n            (obj-at ?x ?y) \n\n            (can-go ?x ?y) \n            (has-obj ?x) \n)\n\n(:action move-without-object\n    :parameters (?start ?dest ?robot)\n    :precondition (and \n\n                (isRoom ?start) (isRoom ?dest) (isRobot ?robot)\n\n                (bot-at ?start) \n                (clear ?robot) \n\n                (not (= ?start ?dest)) \n                (can-go ?start ?dest) \n    )\n    :effect (and    \n\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action move-with-object\n    :parameters (?start ?dest ?object ?robot)\n    :precondition (and \n\n                (isRoom ?start) (isRoom ?dest) (isObject ?object) (isRobot ?robot)\n\n                (not (obj-at ?object ?start)) (not (obj-at ?object ?dest)) \n                (holding ?object)\n                (not (has-obj ?dest))\n\n                (bot-at ?start) \n                (not (clear ?robot)) \n\n                (not (= ?start ?dest)) \n                (can-go ?start ?dest) \n\n    )\n    :effect (and \n\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action pickup\n    :parameters (?room ?object ?robot)\n    :precondition (and \n\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                (obj-at ?object ?room) \n                (has-obj ?room) \n\n                (bot-at ?room) \n                (clear ?robot) \n                (not (holding ?object)) \n    )\n    :effect (and \n\n                (not (obj-at ?object ?room)) \n                (not (has-obj ?room)) \n                (not (clear ?robot)) \n                (holding ?object) \n    )\n)\n\n(:action release\n    :parameters (?room ?object ?robot)\n    :precondition (and \n\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                (not (obj-at ?object ?room)) \n                (not (has-obj ?room)) \n\n                (bot-at ?room) \n                (not (clear ?robot)) \n                (holding ?object) \n    )\n    :effect (and \n\n                (obj-at ?object ?room) \n                (has-obj ?room) \n                (clear ?robot) \n                (not (holding ?object)) \n    )\n)\n\n)"
    },
    {
        "batch_id": 3,
        "file_name": "planimation_documentation_edgy_domain.pddl",
        "pddl_domain": "; Title: FlowFree Domain for Edgy Strategy (made compatible with Fast Downward planners)\n; Author: Aditi Basu (University of Melbourne)\n\n(define (domain FlowFree)\n    (:requirements :strips :typing :action-costs :conditional-effects)\n\n    (:types\n        dot node\n    )\n\n    (:predicates\n        ; pre-strategy domain predicates\n        (head ?n - node ?d - dot)\n        (selected ?d - dot)\n        (finished ?d - dot)\n        (adjacent ?n - node ?n - node)\n        (filled ?n - node ?d - dot)\n\n        ; Planimation predicates\n        (position ?n - node)\n        \n        ; Edgy strategy predicates\n        (nextToEdge ?n - node)               ; is a node next to an edge?\n        (currentPath ?n - node)        ; is a node part of the current path being formed?\n\n        ; Fast-Downward predicates\n        (pipe ?n - node)                  ; does a node contain a pipe?\n\n    )\n\n    ; cost function\n    (:functions\n        (total-cost) - number\n    )\n\n    ; move selection from d1 to d2 based on cost\n    (:action select-colour\n        :parameters     (?d1 - dot\n                         ?d2 - dot)\n\n        :precondition   (and \n                            (selected ?d1)\n                            (not (selected ?d2))\n                            (not (finished ?d2))\n                        )\n\n        :effect         (and \n                            (selected ?d2)\n                            (not (selected ?d1))\n                            (finished ?d1)              \n\t\t\t\t            \n                            (increase (total-cost) 1)\n                        )\n    )\n    \n    ; move from n1 to n2 where n2 is NOT nextToEdge\n    (:action move\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (not (nextToEdge ?n2))\n                        )\n                        \n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n                             \n                            ; increment cost as ?n2 is not nextToEdge\n                            (increase (total-cost) 1)\n                        )\n    )\n    \n     ; move from n1 to n2 where n2 is nextToEdge\n    (:action moveNextToEdge\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (nextToEdge ?n2)\n                        )\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n                            \n                            ; no cost increase as ?n2 is nextToEdge\n                            (increase (total-cost) 0)\n                        )\n    )\n\n    ; finish a path by connecting to second dot \n    (:action finishPath\n        :parameters     (?n1 - node\n                         ?n2 - node\n                         ?d - dot)\n\n        :precondition   (and\n                            (filled ?n2 ?d) \n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                        ) \n\n        :effect         (and \n                            (head ?n2 ?d)\n                            \n                            ; convert nodes adjacent to currentPath nodes to nextToEdge\n                            (forall (?cp - node ?n - node) \n                                (when \n                                    (and (currentPath ?cp) (adjacent ?cp ?n))\n                                    (nextToEdge ?n)    \n                                )\n                            )\n\n                            ; reset all currentPath predicates to false \n                            (forall (?x - node)\n                                (when \n                                    (currentPath ?x) \n                                    (not (currentPath ?x))\n                                )\n                            )\n\n                            ; no cost increase as all dots will need to execute this action regardless of initial state\n                            (increase (total-cost) 0)\n                        )\n    )\n)\n",
        "id": 175,
        "tokens": 6025,
        "corrected_description": "### General\nThis domain is designed for the FlowFree game, where the objective is to connect pairs of dots of the same color with a path that fills the entire board. The domain includes actions for selecting colors, moving between nodes, and finishing paths. It incorporates strategies for efficient path completion, including a focus on moving next to edges and completing paths efficiently. The domain supports action costs and conditional effects to model the complexity of the game's strategy.\n\n### Types\n- **dot**: Represents the colored dots that need to be connected.\n- **node**: Represents the cells or positions on the game board.\n\n### Predicates\n- **(head ?n - node ?d - dot)**: Indicates that node ?n is the current endpoint of the path for dot ?d.\n- **(selected ?d - dot)**: Indicates that dot ?d has been selected for path extension.\n- **(finished ?d - dot)**: Indicates that a complete path has been formed for dot ?d.\n- **(adjacent ?n1 - node ?n2 - node)**: Indicates that node ?n1 is adjacent to node ?n2.\n- **(filled ?n - node ?d - dot)**: Indicates that node ?n has been filled with the path for dot ?d.\n- **(position ?n - node)**: Used for visualizing the position of a node.\n- **(nextToEdge ?n - node)**: Indicates that node ?n is adjacent to the edge of the board.\n- **(currentPath ?n - node)**: Indicates that node ?n is part of the current path being formed.\n- **(pipe ?n - node)**: Indicates that node ?n contains a part of the path (like a pipe).\n\n### Functions\n- **total-cost**: Represents the total cost accumulated during the plan, which is a numerical value.\n\n### Actions\n- **select-colour <?d1> <?d2>**: Selects a new dot ?d2 to continue the path from dot ?d1, marking ?d1 as finished and incrementing the total cost by 1.  \n  \n- **move <?n1> <?n2> <?d>**: Moves the path from node ?n1 to an adjacent node ?n2 that is not next to an edge, for the selected dot ?d. This action increases the total cost by 1.  \n  \n- **moveNextToEdge <?n1> <?n2> <?d>**: Moves the path from node ?n1 to an adjacent node ?n2 that is next to an edge, for the selected dot ?d. This action does not increase the total cost.  \n  \n- **finishPath <?n1> <?n2> <?d>**: Completes the path for dot ?d by connecting node ?n1 to the second dot located at node ?n2. This action converts nodes adjacent to the current path into edge nodes and resets the current path markers without increasing the total cost.",
        "pddl_domain_processed": "\n\n(define (domain FlowFree)\n    (:requirements :strips :typing :action-costs :conditional-effects)\n\n    (:types\n        dot node\n    )\n\n    (:predicates\n\n        (head ?n - node ?d - dot)\n        (selected ?d - dot)\n        (finished ?d - dot)\n        (adjacent ?n - node ?n - node)\n        (filled ?n - node ?d - dot)\n\n        (position ?n - node)\n\n        (nextToEdge ?n - node)               \n        (currentPath ?n - node)        \n\n        (pipe ?n - node)                  \n\n    )\n\n    (:functions\n        (total-cost) - number\n    )\n\n    (:action select-colour\n        :parameters     (?d1 - dot\n                         ?d2 - dot)\n\n        :precondition   (and \n                            (selected ?d1)\n                            (not (selected ?d2))\n                            (not (finished ?d2))\n                        )\n\n        :effect         (and \n                            (selected ?d2)\n                            (not (selected ?d1))\n                            (finished ?d1)              \n\n                            (increase (total-cost) 1)\n                        )\n    )\n\n    (:action move\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (not (nextToEdge ?n2))\n                        )\n\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n\n                            (increase (total-cost) 1)\n                        )\n    )\n\n    (:action moveNextToEdge\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (nextToEdge ?n2)\n                        )\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n\n                            (increase (total-cost) 0)\n                        )\n    )\n\n    (:action finishPath\n        :parameters     (?n1 - node\n                         ?n2 - node\n                         ?d - dot)\n\n        :precondition   (and\n                            (filled ?n2 ?d) \n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                        ) \n\n        :effect         (and \n                            (head ?n2 ?d)\n\n                            (forall (?cp - node ?n - node) \n                                (when \n                                    (and (currentPath ?cp) (adjacent ?cp ?n))\n                                    (nextToEdge ?n)    \n                                )\n                            )\n\n                            (forall (?x - node)\n                                (when \n                                    (currentPath ?x) \n                                    (not (currentPath ?x))\n                                )\n                            )\n\n                            (increase (total-cost) 0)\n                        )\n    )\n)\n"
    },
    {
        "batch_id": 3,
        "file_name": "martilad_MI-UMI2018_sokobanDomain.pddl",
        "pddl_domain": "(define (domain sokoban)\n  (:requirements :equality)\n  (:predicates (has_player ?x)\n               (has_box ?x)\n               (n1 ?x ?y)\n               (n2 ?x ?y))\n  (:action move-player\n           :parameters (?x ?y)\n           :precondition (and (n1 ?x ?y)\n                              (not (has_box ?y))\n                              (has_player ?x))\n           :effect\t\t (and (has_player ?y)\n                              (not (has_player ?x))))\n  (:action push-box\n\t\t   :parameters (?x ?y ?z)\n\t\t   :precondition (and   (has_player ?x)\n                                (has_box ?y)\n                                (not (has_box ?z))\n                                (n1 ?x ?y)\n                                (n1 ?y ?z)\n                                (n2 ?x ?z))\n\t       :effect (and (has_box ?z)\n\t\t\t\t\t\t(not(has_box ?y))\n\t\t\t\t\t\t(has_player ?y)\n\t\t\t\t\t\t(not(has_player ?x))))\n  )",
        "id": 184,
        "tokens": 5022,
        "corrected_description": "### General\nThe Sokoban domain involves a player moving around a grid to push boxes into designated locations. The player can move freely through empty spaces and can push a single box at a time into an adjacent space, provided the space beyond the box is also free. The goal typically involves getting all boxes to specific locations.\n\n### Predicates\n- **(has_player ?x)**: Indicates that the player is at location ?x.\n- **(has_box ?x)**: Indicates that there is a box at location ?x.\n- **(n1 ?x ?y)**: Indicates that location ?y is directly adjacent to location ?x in one direction (e.g., north).\n- **(n2 ?x ?y)**: Indicates that location ?y is directly adjacent to location ?x in another direction (e.g., east).\n\n### Actions\n- **move-player <?x> <?y>**: Allows the player to move from location ?x to location ?y.  \n\n- **push-box <?x> <?y> <?z>**: Allows the player to push a box from location ?y to location ?z.",
        "pddl_domain_processed": "(define (domain sokoban)\n  (:requirements :equality)\n  (:predicates (has_player ?x)\n               (has_box ?x)\n               (n1 ?x ?y)\n               (n2 ?x ?y))\n  (:action move-player\n           :parameters (?x ?y)\n           :precondition (and (n1 ?x ?y)\n                              (not (has_box ?y))\n                              (has_player ?x))\n           :effect\t\t (and (has_player ?y)\n                              (not (has_player ?x))))\n  (:action push-box\n\t\t   :parameters (?x ?y ?z)\n\t\t   :precondition (and   (has_player ?x)\n                                (has_box ?y)\n                                (not (has_box ?z))\n                                (n1 ?x ?y)\n                                (n1 ?y ?z)\n                                (n2 ?x ?z))\n\t       :effect (and (has_box ?z)\n\t\t\t\t\t\t(not(has_box ?y))\n\t\t\t\t\t\t(has_player ?y)\n\t\t\t\t\t\t(not(has_player ?x))))\n  )"
    },
    {
        "batch_id": 3,
        "file_name": "fawcettc_planning-instances_ipc-old-pathways-p02-domain.pddl",
        "pddl_domain": "; IPC5 Domain: Pathways Propositional\n; Authors: Yannis Dimopoulos, Alfonso Gerevini and Alessandro Saetti\n(define (domain Pathways-Propositional)\n(:requirements :typing :adl)\n(:types level molecule - object\n        simple complex - molecule)\n(:constants c-Myc-Max cycDp1 p107-E2F4-DP12p1 p107-E2F4-DP12p1-gE2  - complex)\n(:predicates\n         (association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (synthesis-reaction ?x1 ?x2 - molecule)\n             (possible ?x - molecule)\n         (available ?x - molecule)\n             (chosen ?s - simple)\n         (next ?l1 ?l2 - level)\n         (num-subs ?l - level)\n         (goal1)\n         (goal2))\n(:action choose\n :parameters (?x - simple ?l1 ?l2 - level)\n :precondition (and (possible ?x) (not (chosen ?x))\n            (num-subs ?l2) (next ?l1 ?l2))\n :effect (and (chosen ?x) (not (num-subs ?l2)) (num-subs ?l1)))\n(:action initialize\n  :parameters (?x - simple)\n  :precondition (and (chosen ?x))\n  :effect (and (available ?x)))\n(:action associate\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (association-reaction ?x1  ?x2  ?x3)\n            (available ?x1) (available ?x2))\n :effect (and  (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action associate-with-catalyze\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (catalyzed-association-reaction ?x1 ?x2 ?x3)\n            (available ?x1) (available ?x2))\n :effect (and (not (available ?x1)) (available ?x3)))\n(:action synthesize\n :parameters (?x1 ?x2 - molecule)\n :precondition (and (synthesis-reaction ?x1 ?x2) (available ?x1))\n :effect (and (available ?x2)))\n(:action DUMMY-ACTION-1\n :parameters ()\n :precondition\n    (or (available p107-E2F4-DP12p1-gE2)\n        (available p107-E2F4-DP12p1))\n :effect (and (goal1)))\n(:action DUMMY-ACTION-2\n :parameters ()\n :precondition\n    (or (available cycDp1)\n        (available c-Myc-Max))\n :effect (and (goal2)))\n)\n",
        "id": 187,
        "tokens": 5976,
        "corrected_description": "### General\nThis domain, named Pathways-Propositional, is designed for modeling biochemical pathways, focusing on the interactions between molecules. It involves various types of reactions, including association, catalysis, and synthesis, to simulate the complex interactions within a cellular environment. The goal is to achieve specific molecular configurations that represent biological goals.\n\n### Types\n- **object**: The base type for all entities in the domain.\n- **level**: A type representing different levels or stages in the pathway.\n- **molecule**: Represents all molecules involved in the pathways.\n  - **simple**: A subtype of molecule, representing simple molecules.\n  - **complex**: A subtype of molecule, representing complex molecules formed from reactions between simpler molecules.\n\n### Constants\n- **c-Myc-Max, cycDp1, p107-E2F4-DP12p1, p107-E2F4-DP12p1-gE2**: are predefined complex molecules used in the domain.\n\n### Predicates\n- **(association-reaction ?x1 ?x2 - molecule ?x3 - complex)**: Indicates that molecules ?x1 and ?x2 can associate to form complex ?x3.\n- **(catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)**: Indicates that molecules ?x1 and ?x2 can associate to form complex ?x3 in a reaction catalyzed by another molecule.\n- **(synthesis-reaction ?x1 ?x2 - molecule)**: Indicates that molecule ?x1 can synthesize molecule ?x2.\n- **(possible ?x - molecule)**: Indicates that molecule ?x can potentially participate in a reaction.\n- **(available ?x - molecule)**: Indicates that molecule ?x is currently available for reactions.\n- **(chosen ?s - simple)**: Indicates that simple molecule ?s has been chosen for a reaction.\n- **(next ?l1 ?l2 - level)**: Indicates that level ?l2 follows level ?l1 in the pathway.\n- **(num-subs ?l - level)**: Indicates the number of substrates at level ?l.\n- **(goal1)** and **(goal2)**: Indicate specific goal states to be achieved in the pathway.\n\n### Actions\n- **choose<?x><?l1><?l2>**: Selects a simple molecule for participation in the pathway, moving to the next level.   - **initialize<?x>**: Makes a chosen simple molecule available for reactions.  \n\n- **associate<?x1><?x2><?x3>**: Associates two molecules to form a complex.   \n\n- **associate-with-catalyze<?x1><?x2><?x3>**: Similar to associate, but one of the molecules acts as a catalyst.  \n\n- **synthesize<?x1><?x2>**: Synthesizes a new molecule from an available one.  \n\n- **DUMMY-ACTION-1**:These actions represent achieving specific goal states in the pathway.   \n- **DUMMY-ACTION-2**: These actions represent achieving specific goal states in the pathway.",
        "pddl_domain_processed": "\n\n(define (domain Pathways-Propositional)\n(:requirements :typing :adl)\n(:types level molecule - object\n        simple complex - molecule)\n(:constants c-Myc-Max cycDp1 p107-E2F4-DP12p1 p107-E2F4-DP12p1-gE2  - complex)\n(:predicates\n         (association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (synthesis-reaction ?x1 ?x2 - molecule)\n             (possible ?x - molecule)\n         (available ?x - molecule)\n             (chosen ?s - simple)\n         (next ?l1 ?l2 - level)\n         (num-subs ?l - level)\n         (goal1)\n         (goal2))\n(:action choose\n :parameters (?x - simple ?l1 ?l2 - level)\n :precondition (and (possible ?x) (not (chosen ?x))\n            (num-subs ?l2) (next ?l1 ?l2))\n :effect (and (chosen ?x) (not (num-subs ?l2)) (num-subs ?l1)))\n(:action initialize\n  :parameters (?x - simple)\n  :precondition (and (chosen ?x))\n  :effect (and (available ?x)))\n(:action associate\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (association-reaction ?x1  ?x2  ?x3)\n            (available ?x1) (available ?x2))\n :effect (and  (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action associate-with-catalyze\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (catalyzed-association-reaction ?x1 ?x2 ?x3)\n            (available ?x1) (available ?x2))\n :effect (and (not (available ?x1)) (available ?x3)))\n(:action synthesize\n :parameters (?x1 ?x2 - molecule)\n :precondition (and (synthesis-reaction ?x1 ?x2) (available ?x1))\n :effect (and (available ?x2)))\n(:action DUMMY-ACTION-1\n :parameters ()\n :precondition\n    (or (available p107-E2F4-DP12p1-gE2)\n        (available p107-E2F4-DP12p1))\n :effect (and (goal1)))\n(:action DUMMY-ACTION-2\n :parameters ()\n :precondition\n    (or (available cycDp1)\n        (available c-Myc-Max))\n :effect (and (goal2)))\n)\n"
    },
    {
        "batch_id": 3,
        "file_name": "Planning4Storytelling_icaps-tutorial-2024_wilf_journey_domain.pddl",
        "pddl_domain": ";This is a story about a wolf cub named Wilf who gets lost\n;in the Tundra during a blizzard, but then finds his way back to his family, with the\n;help of his animal friends.\n;\n;Original story book written by Rachel Bright and illustrated by Jim Field\n;Scholastic Press 2020\n;\n;Wilf can be guided from one location to another if\n;Wilf is at location1, and location1 and location2 are connected,\n;and there is a friend at location1 who is capable of guiding Wilf to location2.\n;Wilf is safely at home when he reaches the Den\n\n(define (domain wilf_journey1)\n\n    (:requirements\n        :equality\n        :typing\n        \n    )\n\n\n    (:types friend location wilf\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n    \t(hasFriend ?l1 - location ?f - friend)\n        (isConnected ?l1 - location ?l2 - location)\n        (at ?l1 - location ?w1 - wilf)\n        (canGuide ?l1 - location ?l2 - location ?f - friend)\n        (canCarry ?l1 - location ?l2 - location ?f - friend)\n\n    )\n\n    (:functions\n\n    )\n\n    (:action guide\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canGuide ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n    (:action carry\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canCarry ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n)",
        "id": 200,
        "tokens": 5371,
        "corrected_description": "### General\nThis domain models the journey of a wolf cub named Wilf who gets lost in the Tundra during a blizzard but finds his way back to his family with the help of his animal friends. The domain captures the actions that Wilf's friends can take to guide or carry him from one location to another, ensuring he safely returns home.\n\n### Types\n- **friend**: Represents the animal friends capable of assisting Wilf.\n- **location**: Represents different locations in the Tundra.\n- **wilf**: Represents the wolf cub, Wilf.\n\n### Predicates\n- **(hasFriend ?l1 - location ?f - friend)**: Indicates that a friend ?f is present at location ?l1.\n- **(isConnected ?l1 - location ?l2 - location)**: Indicates that location ?l1 is directly connected to location ?l2.\n- **(at ?l1 - location ?w1 - wilf)**: Indicates that Wilf is at location ?l1.\n- **(canGuide ?l1 - location ?l2 - location ?f - friend)**: Indicates that a friend ?f at location ?l1 can guide Wilf to location ?l2.\n- **(canCarry ?l1 - location ?l2 - location ?f - friend)**: Indicates that a friend ?f at location ?l1 can carry Wilf to location ?l2.\n\n### Actions\n- **guide <?f> <?w> <?l1> <?l2>**: Allows a friend to guide Wilf from one location to another.  \n- **carry <?f> <?w> <?l1> <?l2>**: Similar to the guide action, this allows a friend to carry Wilf from one location to another under the same conditions.",
        "pddl_domain_processed": "\n\n(define (domain wilf_journey1)\n\n    (:requirements\n        :equality\n        :typing\n\n    )\n\n    (:types friend location wilf\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n    \t(hasFriend ?l1 - location ?f - friend)\n        (isConnected ?l1 - location ?l2 - location)\n        (at ?l1 - location ?w1 - wilf)\n        (canGuide ?l1 - location ?l2 - location ?f - friend)\n        (canCarry ?l1 - location ?l2 - location ?f - friend)\n\n    )\n\n    (:functions\n\n    )\n\n    (:action guide\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canGuide ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n    (:action carry\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canCarry ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n)"
    },
    {
        "batch_id": 3,
        "file_name": "MOHYAZZZ_ai-planning_AirCargoDomain.pddl",
        "pddl_domain": ";; PDDL domain of the Air cargo transport\n;; The author of this piece of code is: https://github.com/arii\n;; This is a simple PDDL code inspired by the book Artificial Intelligence : A Modern Approach page 369-370\n\n(define (domain air-cargo)\n    (:requirements :strips)\n    (:predicates\n        (In ?obj ?place)\n        (At ?obj ?place)\n        (Cargo ?obj)\n        (Plane ?obj)\n        (Airport ?obj)\n    )\n\n    (:action LOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (At ?c ?a)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (At ?c ?a)) (In ?c ?p))\n    )\n\n    (:action UNLOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (In ?c ?p)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (In ?c ?p)) (At ?c ?a))\n    )\n\n    (:action FLY\n        :parameters (?p ?from ?to)\n        :precondition (and (At ?p ?from)\n            (Plane ?p)\n            (Airport ?from)\n            (Airport ?to))\n        :effect (and (not (At ?p ?from)) (At ?p ?to))\n    )\n)",
        "id": 229,
        "tokens": 5066,
        "corrected_description": "### General\nThis domain models an air cargo transport system where cargo can be loaded onto planes, transported between airports, and unloaded. The goal is to find a plan that moves cargo from their initial locations to their destinations using a fleet of planes.\n\n### Predicates\n- **(In ?obj ?place)**: Indicates that cargo ?obj is inside plane ?place.\n- **(At ?obj ?place)**: Indicates that an object (cargo or plane) ?obj is at airport ?place.\n- **(Cargo ?obj)**: Indicates that ?obj is a cargo.\n- **(Plane ?obj)**: Indicates that ?obj is a plane.\n- **(Airport ?obj)**: Indicates that ?obj is an airport.\n\n### Actions\n- **LOAD <?c> <?p> <?a>**: Allows loading cargo onto a plane at an airport.  \n  \n- **UNLOAD <?c> <?p> <?a>**: Allows unloading cargo from a plane at an airport.  \n  \n- **FLY <?p> <?from> <?to>**: Allows a plane to fly from one airport to another.",
        "pddl_domain_processed": "\n\n(define (domain air-cargo)\n    (:requirements :strips)\n    (:predicates\n        (In ?obj ?place)\n        (At ?obj ?place)\n        (Cargo ?obj)\n        (Plane ?obj)\n        (Airport ?obj)\n    )\n\n    (:action LOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (At ?c ?a)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (At ?c ?a)) (In ?c ?p))\n    )\n\n    (:action UNLOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (In ?c ?p)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (In ?c ?p)) (At ?c ?a))\n    )\n\n    (:action FLY\n        :parameters (?p ?from ?to)\n        :precondition (and (At ?p ?from)\n            (Plane ?p)\n            (Airport ?from)\n            (Airport ?to))\n        :effect (and (not (At ?p ?from)) (At ?p ?to))\n    )\n)"
    }
]