[
    {
        "file_name": "soartech_soar_grid.pddl",
        "pddl_domain": "(define (domain grid)\n  (:requirements :strips)\n  (:predicates (conn ?x ?y) (key-shape ?k ?s) (lock-shape ?x ?s)\n\t       (at ?r ?x ) (at-robot ?x) (place ?p) (key ?k) (shape ?s)\n\t       (locked ?x) (holding ?k)  (open ?x)  (arm-empty ))\n\n  (:action unlock\n    :parameters (?curpos ?lockpos ?key ?shape)\n    :precondition (and (place ?curpos) (place ?lockpos) (key ?key)\n\t\t       (shape ?shape) (conn ?curpos ?lockpos)\n\t\t       (key-shape ?key ?shape) (lock-shape ?lockpos ?shape)\n\t\t       (at-robot ?curpos) (locked ?lockpos) (holding ?key))\n    :effect (and (open ?lockpos) (not (locked ?lockpos))))\n\n  (:action move\n    :parameters (?curpos ?nextpos)\n    :precondition (and (place ?curpos) (place ?nextpos) (at-robot ?curpos)\n\t\t       (conn ?curpos ?nextpos) (open ?nextpos))\n    :effect (and (at-robot ?nextpos) (not (at-robot ?curpos))))\n\n  (:action pickup\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (at ?key ?curpos) (arm-empty ))\n    :effect (and (holding ?key) (not (at ?key ?curpos)) (not (arm-empty ))))\n\n  (:action pickup-and-loose\n    :parameters (?curpos ?newkey ?oldkey)\n    :precondition (and (place ?curpos) (key ?newkey) (key ?oldkey)\n\t\t       (at-robot ?curpos) (holding ?oldkey)\n\t\t       (at ?newkey ?curpos))\n    :effect (and (holding ?newkey) (at ?oldkey ?curpos)\n\t\t (not (holding ?oldkey)) (not (at ?newkey ?curpos))))\n\n  (:action putdown\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (holding ?key))\n    :effect (and (arm-empty ) (at ?key ?curpos) (not (holding ?key))))\n  )\n",
        "batch_id": 1,
        "id": 0,
        "tokens": 5527,
        "corrected_description": "### General\nThis domain models a robot navigating a grid environment with the objective of unlocking doors and moving through the grid. The robot can carry keys that match the shape of locks to unlock doors. The environment includes places, keys with specific shapes, and doors (locks) with corresponding shapes that need to be unlocked.\n\n### Predicates\n- (conn ?x ?y): Indicates a connection between two places ?x and ?y, allowing movement between them.\n- (key-shape ?k ?s): Indicates that key ?k has shape ?s.\n- (lock-shape ?x ?s): Indicates that lock (or door) at place ?x has shape ?s.\n- (at ?r ?x): Indicates that key ?r is at place ?x.\n- (at-robot ?x): Indicates that the robot is at place ?x.\n- (place ?p): Indicates that ?p is a place in the grid.\n- (key ?k): Indicates that ?k is a key.\n- (shape ?s): Indicates that ?s is a shape.\n- (locked ?x): Indicates that the place ?x is locked.\n- (holding ?k): Indicates that the robot is holding key ?k.\n- (open ?x): Indicates that the place ?x is open.\n- (arm-empty): Indicates that the robot's arm is empty.\n\n### Actions\n- unlock <?curpos> <?lockpos> <?key> <?shape>: Allows the robot to unlock a door at place <?lockpos> using a key of a specific shape.\n- move <?curpos> <?nextpos>: Allows the robot to move from place <?curpos> to place <?nextpos>.\n- pickup <?curpos> <?key>: Allows the robot to pick up a key at its current location.\n- pickup-and-loose <?curpos> <?newkey> <?oldkey>: Allows the robot to pick up a new key while dropping the one it was holding.\n- putdown <?curpos> <?key>: Allows the robot to put down a key it is holding.",
        "pddl_domain_processed": "(define (domain grid)\n  (:requirements :strips)\n  (:predicates (conn ?x ?y) (key-shape ?k ?s) (lock-shape ?x ?s)\n\t       (at ?r ?x ) (at-robot ?x) (place ?p) (key ?k) (shape ?s)\n\t       (locked ?x) (holding ?k)  (open ?x)  (arm-empty ))\n\n  (:action unlock\n    :parameters (?curpos ?lockpos ?key ?shape)\n    :precondition (and (place ?curpos) (place ?lockpos) (key ?key)\n\t\t       (shape ?shape) (conn ?curpos ?lockpos)\n\t\t       (key-shape ?key ?shape) (lock-shape ?lockpos ?shape)\n\t\t       (at-robot ?curpos) (locked ?lockpos) (holding ?key))\n    :effect (and (open ?lockpos) (not (locked ?lockpos))))\n\n  (:action move\n    :parameters (?curpos ?nextpos)\n    :precondition (and (place ?curpos) (place ?nextpos) (at-robot ?curpos)\n\t\t       (conn ?curpos ?nextpos) (open ?nextpos))\n    :effect (and (at-robot ?nextpos) (not (at-robot ?curpos))))\n\n  (:action pickup\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (at ?key ?curpos) (arm-empty ))\n    :effect (and (holding ?key) (not (at ?key ?curpos)) (not (arm-empty ))))\n\n  (:action pickup-and-loose\n    :parameters (?curpos ?newkey ?oldkey)\n    :precondition (and (place ?curpos) (key ?newkey) (key ?oldkey)\n\t\t       (at-robot ?curpos) (holding ?oldkey)\n\t\t       (at ?newkey ?curpos))\n    :effect (and (holding ?newkey) (at ?oldkey ?curpos)\n\t\t (not (holding ?oldkey)) (not (at ?newkey ?curpos))))\n\n  (:action putdown\n    :parameters (?curpos ?key)\n    :precondition (and (place ?curpos) (key ?key) (at-robot ?curpos)\n\t\t       (holding ?key))\n    :effect (and (arm-empty ) (at ?key ?curpos) (not (holding ?key))))\n  )\n"
    },
    {
        "file_name": "LaiaFont_Project2-PAR_domain2.pddl",
        "pddl_domain": "(define (domain robot_waiter_2)\n\n    (:requirements :strips :typing :disjunctive-preconditions :negative-preconditions)\n\n    (:types\n        entity area - object\n        robot plate buffet costumer - entity\n    )\n\n    (:predicates\n        (adjacent ?a1 - area ?a2 - area) ;Wether area a1 and a2 are adjacent and not seperated\n        (has_food ?p - plate) ;Wether plate p contains food \n        (served ?c - costumer) ;Wether costumer c has been served\n        (holding ?p - plate ?r - robot) ;Wether Lucki is holding plate p\n        (hands_full)                        ;Whether Lucki is holding any plate \n        (at ?o - entity ?a - area) ;Wether the object o is at area a \n    )\n\n    ; ------ ACTIONS ------\n    (:action move ;This action moves the robot from a1 to a2 \n        :parameters (?a1 - area ?a2 - area ?r - robot)\n        :precondition (and\n            (at ?r ?a1)\n            (or (adjacent ?a1 ?a2) (adjacent ?a2 ?a1))\n        )\n        :effect (and\n            (not (at ?r ?a1))\n            (at ?r ?a2)\n        )\n    )\n\n    (:action pick_up ;This action lets the robot pick up the plate p in the area a \n        :parameters (?p - plate ?a - area ?r -robot)\n        :precondition (and\n            (at ?r ?a)\n            (at ?p ?a)\n            (not (hands_full))\n        )\n        :effect (and\n            (holding ?p ?r)\n            (hands_full)\n            (not (at ?p ?a))\n        )\n    )\n\n    (:action present ;This action lets the robot present the plate p to the costumer c in area a\n        :parameters (?p - plate ?c - costumer ?a - area ?r - robot)\n        :precondition (and\n            (holding ?p ?r)\n            (has_food ?p)\n            (at ?r ?a)\n            (at ?c ?a)\n            (not (served ?c))\n        )\n        :effect (and\n            (served ?c)\n            (not (holding ?p ?r))\n            (not (hands_full))\n        )\n    )\n\n    (:action fill ;This action lets the robot r fill the plate p in the area a at the buffet b\n        :parameters (?p - plate ?a - area ?r - robot ?b - buffet)\n        :precondition (and\n            (holding ?p ?r)\n            (not (has_food ?p))\n            (at ?r ?a)\n            (at ?b ?a)\n        )\n        :effect (and\n            (has_food ?p)\n        )\n    )\n)",
        "batch_id": 1,
        "id": 6,
        "tokens": 5644,
        "corrected_description": "### General\nThis domain models the tasks of a robot waiter named Lucki in a restaurant setting. Lucki is responsible for moving between areas, picking up plates, filling them with food at the buffet, and serving food to customers. The domain includes actions for moving between adjacent areas, picking up and holding plates, serving customers, and filling plates with food.\n\n### Types\n- **entity**: The base type for all entities in the domain.\n- **area**: Represents different areas within the restaurant, such as the buffet area, dining area, etc.\n- **robot**: Represents the robot waiter, Lucki.\n- **plate**: Represents plates that can hold food.\n- **buffet**: Represents the buffet area where food is available.\n- **costumer**: Represents customers waiting to be served.\n\n### Predicates\n- **(adjacent ?a1 ?a2 - area)**: Indicates that area ?a1 and ?a2 are adjacent to each other.\n- **(has_food ?p - plate)**: Indicates that plate ?p contains food.\n- **(served ?c - costumer)**: Indicates that customer ?c has been served.\n- **(holding ?p - plate ?r - robot)**: Indicates that robot ?r is holding plate ?p.\n- **(hands_full)**: Indicates that Lucki is holding a plate and therefore has no free hands.\n- **(at ?o - entity ?a - area)**: Indicates that entity ?o is located at area ?a.\n\n### Actions\n- **move <?a1> <?a2> <?r>**: Moves the robot from area ?a1 to area ?a2. \n  \n- **pick_up <?p> <?a> <?r>**: Allows the robot to pick up plate ?p in area ?a.  \n  \n- **present <?p> <?c> <?a> <?r>**: Lets the robot present food to a customer ?c in area ?a.  \n  \n- **fill <?p> <?a> <?r> <?b>**: Allows the robot to fill a plate with food at the buffet.",
        "pddl_domain_processed": "(define (domain robot_waiter_2)\n\n    (:requirements :strips :typing :disjunctive-preconditions :negative-preconditions)\n\n    (:types\n        entity area - object\n        robot plate buffet costumer - entity\n    )\n\n    (:predicates\n        (adjacent ?a1 - area ?a2 - area) \n        (has_food ?p - plate) \n        (served ?c - costumer) \n        (holding ?p - plate ?r - robot) \n        (hands_full)                        \n        (at ?o - entity ?a - area) \n    )\n\n    (:action move \n        :parameters (?a1 - area ?a2 - area ?r - robot)\n        :precondition (and\n            (at ?r ?a1)\n            (or (adjacent ?a1 ?a2) (adjacent ?a2 ?a1))\n        )\n        :effect (and\n            (not (at ?r ?a1))\n            (at ?r ?a2)\n        )\n    )\n\n    (:action pick_up \n        :parameters (?p - plate ?a - area ?r -robot)\n        :precondition (and\n            (at ?r ?a)\n            (at ?p ?a)\n            (not (hands_full))\n        )\n        :effect (and\n            (holding ?p ?r)\n            (hands_full)\n            (not (at ?p ?a))\n        )\n    )\n\n    (:action present \n        :parameters (?p - plate ?c - costumer ?a - area ?r - robot)\n        :precondition (and\n            (holding ?p ?r)\n            (has_food ?p)\n            (at ?r ?a)\n            (at ?c ?a)\n            (not (served ?c))\n        )\n        :effect (and\n            (served ?c)\n            (not (holding ?p ?r))\n            (not (hands_full))\n        )\n    )\n\n    (:action fill \n        :parameters (?p - plate ?a - area ?r - robot ?b - buffet)\n        :precondition (and\n            (holding ?p ?r)\n            (not (has_food ?p))\n            (at ?r ?a)\n            (at ?b ?a)\n        )\n        :effect (and\n            (has_food ?p)\n        )\n    )\n)"
    },
    {
        "file_name": "FedeMala00_PDDL-planning-AI1-UniGe_domain-screw.pddl",
        "pddl_domain": "(define (domain screw)\n    (:requirements :strips)\n\n    (:predicates\n        (ROOM ?r) (OBJECTS ?o) (GRIPPER ?g)\n        (rob_room ?r) (obj_room ?r ?o)\n        (fixed_obj ?o) (can_fix ?o ?g)\n        \n    )\n\n    (:action move\n        :parameters (?from ?to)\n        :precondition (and \n            (ROOM ?from) (ROOM ?to)\n            (rob_room ?from)\n        )\n        :effect (and\n            (not (rob_room ?from))\n            (rob_room ?to)\n        )\n    )\n\n    (:action fix_obj\n        :parameters (?o ?r ?g)\n        :precondition (and \n            (OBJECTS ?o) (ROOM ?r) (GRIPPER ?g) (not (fixed_obj ?o))\n            (rob_room ?r) (obj_room ?r ?o) (can_fix ?o ?g)\n        )\n        :effect (and\n            (fixed_obj ?o)\n        )\n    )\n    \n   \n)\n",
        "batch_id": 1,
        "id": 8,
        "tokens": 4971,
        "corrected_description": "### General\nThis domain models a robot equipped with a gripper, operating in a domain where the main task is to fix objects located in various rooms. The goal is to navigate through rooms and use the gripper to fix objects as required.\n\n### Predicates\n- (ROOM ?r): Indicates that ?r is a room.\n- (OBJECTS ?o): Indicates that ?o is an object that can potentially be fixed.\n- (GRIPPER ?g): Indicates that ?g is a gripper, a tool for fixing objects.\n- (rob_room ?r): Indicates that the robot is currently in room ?r.\n- (obj_room ?r ?o): Indicates that object ?o is located in room ?r.\n- (fixed_obj ?o): Indicates that object ?o has been fixed.\n- (can_fix ?o ?g): Indicates that object ?o can be fixed using gripper ?g.\n\n### Actions\n- move <?from> <?to>: Allows the robot to move from one room to another.  \n  \n- fix_obj <?o> <?r> <?g>: Allows the robot to fix an object in a room using the gripper.",
        "pddl_domain_processed": "(define (domain screw)\n    (:requirements :strips)\n\n    (:predicates\n        (ROOM ?r) (OBJECTS ?o) (GRIPPER ?g)\n        (rob_room ?r) (obj_room ?r ?o)\n        (fixed_obj ?o) (can_fix ?o ?g)\n\n    )\n\n    (:action move\n        :parameters (?from ?to)\n        :precondition (and \n            (ROOM ?from) (ROOM ?to)\n            (rob_room ?from)\n        )\n        :effect (and\n            (not (rob_room ?from))\n            (rob_room ?to)\n        )\n    )\n\n    (:action fix_obj\n        :parameters (?o ?r ?g)\n        :precondition (and \n            (OBJECTS ?o) (ROOM ?r) (GRIPPER ?g) (not (fixed_obj ?o))\n            (rob_room ?r) (obj_room ?r ?o) (can_fix ?o ?g)\n        )\n        :effect (and\n            (fixed_obj ?o)\n        )\n    )\n\n)\n"
    },
    {
        "file_name": "Riften_moveit-task-planner_domain-03.pddl",
        "pddl_domain": ";; Specification in PDDL1 of the DWR domain\n\n(define (domain dock-worker-robot-simple)\n (:requirements :strips :typing )\n (:types \n  location      ; there are several connected locations in the harbor \n  robot         ; holds at most 1 container, only 1 robot per location\n  container)\n\n (:predicates\n   (adjacent ?l1  ?l2 - location)       ; location ?l1 is adjacent ot ?l2\n   (atl ?r - robot ?l - location)       ; robot ?r is at location ?l\n   (loaded ?r - robot ?c - container )  ; robot ?r is loaded with container ?c\n   (unloaded ?r - robot)                ; robot ?r is empty\n   (in ?c - container ?l - location)    ; container ?c is within location ?l\n   )\n\n;; there are 3 operators in this domain:\n\n;; moves a robot between two adjacent locations\n (:action move                                \n     :parameters (?r - robot ?from ?to - location)\n     :precondition (and (adjacent ?from ?to) (atl ?r ?from) )\n     :effect (and (atl ?r ?to)\n                    (not (atl ?r ?from)) ))\n\n;; loads an empty robot with a container held by a nearby crane\n (:action load                                \n     :parameters (?l - location ?c - container ?r - robot)\n     :precondition (and (atl ?r ?l) (in ?c ?l) (unloaded ?r))\n     :effect (and (loaded ?r ?c)\n                    (not (in ?c ?l)) (not (unloaded ?r)) ))\n\n;; unloads a robot holding a container with a nearby crane\n (:action unload                                 \n     :parameters (?l - location ?c - container ?r - robot)\n     :precondition (and (atl ?r ?l) (loaded ?r ?c) )\n     :effect (and (unloaded ?r) (in ?c ?l)\n                    (not (loaded ?r ?c)) )) )\n\n",
        "batch_id": 1,
        "id": 11,
        "tokens": 5359,
        "corrected_description": "### General\nThis domain represents a simplified version of a dock worker robot (DWR) scenario. In this domain, a robot operates in a harbor, moving between locations, loading, and unloading containers with the help of cranes. The goal is to efficiently manage the containers' distribution across different locations.\n\n### Types\n- **location**: Represents various places within the harbor where actions can occur.\n- **robot**: Represents the dock worker robots that move containers around. Each robot can hold at most one container at a time and can only be in one location at a time.\n- **container**: Represents the items that need to be moved around the harbor by the robots.\n\n### Predicates\n- **(adjacent ?l1 ?l2 - location)**: Indicates that location ?l1 is directly adjacent to location ?l2, allowing a robot to move between them.\n- **(atl ?r - robot ?l - location)**: Indicates that robot ?r is currently at location ?l.\n- **(loaded ?r - robot ?c - container)**: Indicates that robot ?r is loaded with container ?c.\n- **(unloaded ?r - robot)**: Indicates that robot ?r is not carrying any container and is ready to load.\n- **(in ?c - container ?l - location)**: Indicates that container ?c is located within location ?l, either on the ground or being held by a crane.\n\n### Actions\n- **move <?r> <?from> <?to>**: Enables a robot (?r) to move from one location (?from) to an adjacent location (?to).  \n  \n- **load <?l> <?c> <?r>**: Allows a robot (?r) to load a container (?c) at its current location (?l).  \n  \n- **unload <?l> <?c> <?r>**: Enables a robot (?r) to unload a container (?c) at a specific location (?l).",
        "pddl_domain_processed": "\n\n(define (domain dock-worker-robot-simple)\n (:requirements :strips :typing )\n (:types \n  location      \n  robot         \n  container)\n\n (:predicates\n   (adjacent ?l1  ?l2 - location)       \n   (atl ?r - robot ?l - location)       \n   (loaded ?r - robot ?c - container )  \n   (unloaded ?r - robot)                \n   (in ?c - container ?l - location)    \n   )\n\n (:action move                                \n     :parameters (?r - robot ?from ?to - location)\n     :precondition (and (adjacent ?from ?to) (atl ?r ?from) )\n     :effect (and (atl ?r ?to)\n                    (not (atl ?r ?from)) ))\n\n (:action load                                \n     :parameters (?l - location ?c - container ?r - robot)\n     :precondition (and (atl ?r ?l) (in ?c ?l) (unloaded ?r))\n     :effect (and (loaded ?r ?c)\n                    (not (in ?c ?l)) (not (unloaded ?r)) ))\n\n (:action unload                                 \n     :parameters (?l - location ?c - container ?r - robot)\n     :precondition (and (atl ?r ?l) (loaded ?r ?c) )\n     :effect (and (unloaded ?r) (in ?c ?l)\n                    (not (loaded ?r ?c)) )) )\n\n"
    },
    {
        "file_name": "tomsilver_pddlgym_hiking.pddl",
        "pddl_domain": "(define (domain hiking)\n  (:requirements :strips :typing)\n  (:types loc)\n\n(:predicates\n  (at ?loc - loc)\n  (isWater ?loc - loc)\n  (isHill ?loc - loc)\n  (isGoal ?loc - loc)\n  (adjacent ?loc1 - loc ?loc2 - loc)\n  (onTrail ?from - loc ?to - loc)\n)\n\n(:action walk\n  :parameters (?from - loc ?to - loc)\n  :precondition (and\n    (not (isHill ?to))\n    (at ?from)\n    (adjacent ?from ?to)\n    (not (isWater ?from)))\n  :effect (and (at ?to) (not (at ?from)))\n)\n\n(:action climb\n  :parameters (?from - loc ?to - loc)\n  :precondition (and\n    (isHill ?to)\n    (at ?from)\n    (adjacent ?from ?to)\n    (not (isWater ?from)))\n  :effect (and (at ?to) (not (at ?from)))\n)\n\n\n)\n",
        "batch_id": 1,
        "id": 12,
        "tokens": 4943,
        "corrected_description": "### General\nYou are navigating a hiking domain where the goal is to move through various types of terrain, including hills and water bodies, to reach a specific goal location. The domain allows for actions such as walking and climbing, depending on the terrain type.\n\n### Types\nloc: Represents locations in the hiking domain.\n\n### Predicates\n(at ?loc): Indicates the current location of the hiker.\n(isWater ?loc): Indicates that a location is water.\n(isHill ?loc): Indicates that a location is a hill.\n(isGoal ?loc): Indicates that a location is the goal.\n(adjacent ?loc1 ?loc2): Indicates that two locations are adjacent to each other.\n(onTrail ?from ?to): Indicates that there is a trail from one location to another.\n\n### Actions\n- **walk <?from> <?to>**: Enables the hiker (?hiker) to walk from one location (?from) to another (?to).  \n\n- **climb <?from> <?to>**: Allows the hiker to climb from one location (?from) to another (?to).",
        "pddl_domain_processed": "(define (domain hiking)\n  (:requirements :strips :typing)\n  (:types loc)\n\n(:predicates\n  (at ?loc - loc)\n  (isWater ?loc - loc)\n  (isHill ?loc - loc)\n  (isGoal ?loc - loc)\n  (adjacent ?loc1 - loc ?loc2 - loc)\n  (onTrail ?from - loc ?to - loc)\n)\n\n(:action walk\n  :parameters (?from - loc ?to - loc)\n  :precondition (and\n    (not (isHill ?to))\n    (at ?from)\n    (adjacent ?from ?to)\n    (not (isWater ?from)))\n  :effect (and (at ?to) (not (at ?from)))\n)\n\n(:action climb\n  :parameters (?from - loc ?to - loc)\n  :precondition (and\n    (isHill ?to)\n    (at ?from)\n    (adjacent ?from ?to)\n    (not (isWater ?from)))\n  :effect (and (at ?to) (not (at ?from)))\n)\n\n)\n"
    },
    {
        "file_name": "TheUnholyPear_PDDL-Basic_domainP2.pddl",
        "pddl_domain": ";Header and description\n\n(define (domain taxi_simplest2)\n\n    ;remove requirements that are not needed\n    (:requirements :strips :equality :typing :conditional-effects :negative-preconditions)\n\n    (:types \n        taxi\n        location\n        person\n    )\n\n\n    (:predicates \n        (plocation ?p - person ?l - location)  \n        (tlocation ?t - taxi ?l - location)   \n        (inTaxi ?p - person ?t - taxi) \n        (connects ?l1 - location ?l2)  \n        (empty ?t - taxi) \n\n    )\n\n    (:action get_in\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and\n            (plocation ?p ?l)\n            (tlocation ?t ?l)\n            (not (inTaxi ?p ?t))\n            (empty ?t)\n         )\n        :effect (and \n            (inTaxi ?p ?t)\n            (not (plocation ?p ?l))\n            (not (empty ?t))\n        )\n    )\n\n    (:action get_out\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and \n            (inTaxi ?p ?t)\n            (tlocation ?t ?l)\n            (not (empty ?t))\n        )\n        :effect (and \n            (not (inTaxi ?p ?t))\n            (plocation ?p ?l)\n            (empty ?t)\n        )\n    )\n\n    (:action move\n    :parameters (?t - taxi ?l1 - location ?l2 - location)\n    :precondition (and \n        (tlocation ?t ?l1)\n        (connects ?l1 ?l2)\n    )\n    :effect (and \n        (not (tlocation ?t ?l1)) \n        (tlocation ?t ?l2)\n    )\n)\n \n\n)",
        "batch_id": 1,
        "id": 16,
        "tokens": 5297,
        "corrected_description": "### General\nThis domain models a simplified taxi service where taxis can move between locations, and people can get in and out of taxis. The goal is to transport people from their current locations to their desired destinations using taxis.\n\n### Types\n- **taxi**: Represents the taxis available for transporting people.\n- **location**: Represents the different locations within the domain.\n- **person**: Represents individuals who need transportation.\n\n### Predicates\n- **(plocation ?p - person ?l - location)**: Indicates that person ?p is at location ?l.\n- **(tlocation ?t - taxi ?l - location)**: Indicates that taxi ?t is at location ?l.\n- **(inTaxi ?p - person ?t - taxi)**: Indicates that person ?p is inside taxi ?t.\n- **(connects ?l1 - location ?l2 - location)**: Indicates that there is a direct path from location ?l1 to location ?l2.\n- **(empty ?t - taxi)**: Indicates that taxi ?t is empty and can take passengers.\n\n### Actions\n- **get_in <?p> <?t> <?l>**: Allows a person to get into a taxi at their current location.  \n  \n- **get_out <?p> <?t> <?l>**: Allows a person to get out of a taxi at a location.  \n  \n- **move <?t> <?l1> <?l2>**: Allows a taxi to move from one location to another if there is a direct path between the two locations.",
        "pddl_domain_processed": "\n\n(define (domain taxi_simplest2)\n\n    (:requirements :strips :equality :typing :conditional-effects :negative-preconditions)\n\n    (:types \n        taxi\n        location\n        person\n    )\n\n    (:predicates \n        (plocation ?p - person ?l - location)  \n        (tlocation ?t - taxi ?l - location)   \n        (inTaxi ?p - person ?t - taxi) \n        (connects ?l1 - location ?l2)  \n        (empty ?t - taxi) \n\n    )\n\n    (:action get_in\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and\n            (plocation ?p ?l)\n            (tlocation ?t ?l)\n            (not (inTaxi ?p ?t))\n            (empty ?t)\n         )\n        :effect (and \n            (inTaxi ?p ?t)\n            (not (plocation ?p ?l))\n            (not (empty ?t))\n        )\n    )\n\n    (:action get_out\n        :parameters (?p - person ?t - taxi ?l - location)\n        :precondition (and \n            (inTaxi ?p ?t)\n            (tlocation ?t ?l)\n            (not (empty ?t))\n        )\n        :effect (and \n            (not (inTaxi ?p ?t))\n            (plocation ?p ?l)\n            (empty ?t)\n        )\n    )\n\n    (:action move\n    :parameters (?t - taxi ?l1 - location ?l2 - location)\n    :precondition (and \n        (tlocation ?t ?l1)\n        (connects ?l1 ?l2)\n    )\n    :effect (and \n        (not (tlocation ?t ?l1)) \n        (tlocation ?t ?l2)\n    )\n)\n\n)"
    },
    {
        "file_name": "Grahamjcks_Mine_problem_domain-1.pddl",
        "pddl_domain": "(define (domain mine-world)\n(:requirements :adl)\n\n(:types \n    cell item minebot lift - object\n    ore hammer - item\n)\n\n\n(:predicates\n    (ObjectIn ?y - object ?where - cell)\n    (Adjacent ?cell1 - cell ?cell2 - cell)\n    (MinebotHolding ?who - minebot)\n    (ItemHeld ?who - minebot ?what - item)\n    (RockBlocking ?where - cell)\n    (LiftOn ?lift - lift)\n    (Mined ?what - ore)\n)\n\n\n(:action MOVE\n    :parameters (?who - minebot ?from - cell ?to - cell)\n    :precondition (and (Adjacent ?from ?to) (ObjectIn ?who ?from))\n    :effect (and (ObjectIn ?who ?to) (not (ObjectIn ?who ?from)))\n)\n\n(:action PICKUP\n    :parameters (?what - item ?where - cell ?who - minebot)\n    :precondition (and (ObjectIn ?what ?where) (ObjectIn ?who ?where) (not (MinebotHolding ?who)) (not (RockBlocking ?where)) )\n    :effect (and (MinebotHolding ?who) (ItemHeld ?who ?what) (not (ObjectIn ?what ?where)))\n)\n\n(:action TURNON\n    :parameters (?who - minebot ?lift - lift ?where - cell)\n    :precondition (and (ObjectIn ?who ?where) (ObjectIn ?lift ?where))\n    :effect (and (LiftOn ?lift))\n\n)\n\n(:action BREAK\n    :parameters (?who - minebot ?what - hammer ?where - cell)\n    :precondition (and (MinebotHolding ?who) (ItemHeld ?who ?what) (ObjectIn ?who ?where) (RockBlocking ?where))\n    :effect (and (not (RockBlocking ?where)))\n)\n\n(:action MINE\n    :parameters (?who - minebot ?what - ore ?where - cell ?lift - lift)\n    :precondition (and (ObjectIn ?who ?where) (ObjectIn ?lift ?where) (LiftOn ?lift) (ItemHeld ?who ?what) (MinebotHolding ?who))\n    :effect (and (not (MinebotHolding ?who)) (not (ItemHeld ?who ?what)) (Mined ?what))\n)\n\n(:action PUTDOWN\n    :parameters (?who - minebot ?what - item ?where - cell)\n    :precondition (and (ItemHeld ?who ?what) (MinebotHolding ?who) (ObjectIn ?who ?where))\n    :effect (and (ObjectIn ?what ?where) (not (ItemHeld ?who ?what)) (not (MinebotHolding ?who)))\n)\n)\n",
        "batch_id": 1,
        "id": 17,
        "tokens": 5727,
        "corrected_description": "### General\nIn the mine-world domain, a minebot operates within a mine, moving between cells, picking up items, using a lift, breaking rocks, mining ore, and putting down items. The domain models a simplified mining operation where the minebot must navigate, manipulate objects, and interact with the environment to achieve its goals.\n\n### Types\n- **cell**: Represents the different locations within the mine.\n- **item**: A general category for objects that can be picked up and manipulated by the minebot.\n- **minebot**: Represents the robotic agent operating within the mine.\n- **lift**: Represents the lift mechanism that can be turned on by the minebot.\n- **ore**: A subtype of item, represents ore that can be mined.\n- **hammer**: A subtype of item, represents a tool that can break rocks blocking the minebot's path.\n\n### Predicates\n- **(ObjectIn ?y - object ?where - cell)**: Indicates that an object (?y) is located in a specific cell (?where).\n- **(Adjacent ?cell1 - cell ?cell2 - cell)**: Indicates that two cells (?cell1 and ?cell2) are adjacent to each other.\n- **(MinebotHolding ?who - minebot)**: Indicates that the minebot (?who) is currently holding an item.\n- **(ItemHeld ?who - minebot ?what - item)**: Specifies which item (?what) the minebot (?who) is holding.\n- **(RockBlocking ?where - cell)**: Indicates that a cell (?where) is blocked by a rock.\n- **(LiftOn ?lift - lift)**: Indicates that the lift (?lift) is turned on.\n- **(Mined ?what - ore)**: Indicates that an ore (?what) has been mined.\n\n### Actions\n- **MOVE <?who> <?from> <?to>**: Allows the minebot to move from one cell to another. \n- **PICKUP <?what> <?where> <?who>**: Allows the minebot to pick up an item. \n- **TURNON <?who> <?lift> <?where>**: Activates a lift. \n- **BREAK <?who> <?what> <?where>**: Allows the minebot to break a rock blocking a cell. \n- **MINE <?who> <?what> <?where> <?lift>**: Enables the minebot to mine an ore it is holding. \n- **PUTDOWN <?who> <?what> <?where>**: Allows the minebot to put down an item it is holding.",
        "pddl_domain_processed": "(define (domain mine-world)\n(:requirements :adl)\n\n(:types \n    cell item minebot lift - object\n    ore hammer - item\n)\n\n(:predicates\n    (ObjectIn ?y - object ?where - cell)\n    (Adjacent ?cell1 - cell ?cell2 - cell)\n    (MinebotHolding ?who - minebot)\n    (ItemHeld ?who - minebot ?what - item)\n    (RockBlocking ?where - cell)\n    (LiftOn ?lift - lift)\n    (Mined ?what - ore)\n)\n\n(:action MOVE\n    :parameters (?who - minebot ?from - cell ?to - cell)\n    :precondition (and (Adjacent ?from ?to) (ObjectIn ?who ?from))\n    :effect (and (ObjectIn ?who ?to) (not (ObjectIn ?who ?from)))\n)\n\n(:action PICKUP\n    :parameters (?what - item ?where - cell ?who - minebot)\n    :precondition (and (ObjectIn ?what ?where) (ObjectIn ?who ?where) (not (MinebotHolding ?who)) (not (RockBlocking ?where)) )\n    :effect (and (MinebotHolding ?who) (ItemHeld ?who ?what) (not (ObjectIn ?what ?where)))\n)\n\n(:action TURNON\n    :parameters (?who - minebot ?lift - lift ?where - cell)\n    :precondition (and (ObjectIn ?who ?where) (ObjectIn ?lift ?where))\n    :effect (and (LiftOn ?lift))\n\n)\n\n(:action BREAK\n    :parameters (?who - minebot ?what - hammer ?where - cell)\n    :precondition (and (MinebotHolding ?who) (ItemHeld ?who ?what) (ObjectIn ?who ?where) (RockBlocking ?where))\n    :effect (and (not (RockBlocking ?where)))\n)\n\n(:action MINE\n    :parameters (?who - minebot ?what - ore ?where - cell ?lift - lift)\n    :precondition (and (ObjectIn ?who ?where) (ObjectIn ?lift ?where) (LiftOn ?lift) (ItemHeld ?who ?what) (MinebotHolding ?who))\n    :effect (and (not (MinebotHolding ?who)) (not (ItemHeld ?who ?what)) (Mined ?what))\n)\n\n(:action PUTDOWN\n    :parameters (?who - minebot ?what - item ?where - cell)\n    :precondition (and (ItemHeld ?who ?what) (MinebotHolding ?who) (ObjectIn ?who ?where))\n    :effect (and (ObjectIn ?what ?where) (not (ItemHeld ?who ?what)) (not (MinebotHolding ?who)))\n)\n)\n"
    },
    {
        "file_name": "SoarGroup_Domains-Planning-Domain-Definition-Language_sat.pddl",
        "pddl_domain": "\n(define (domain sat)\n  (:requirements :strips)\n  (:predicates (is_clear ?x) (is_set ?x) (is_neg ?x ?y) (sat_clause ?x ?y ?z))\n\n  (:action set_var\n    :parameters (?var ?neg)\n    :precondition (and (is_neg ?var ?neg) (is_clear ?var) (is_clear ?neg))\n    :effect (and (is_set ?var) (not (is_clear ?var)) (not (is_clear ?neg))))\n\n  (:action make_sat_x\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?x)\n    :effect (sat_clause ?x ?y ?z))\n\n  (:action make_sat_y\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?y)\n    :effect (sat_clause ?x ?y ?z))\n\n  (:action make_sat_z\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?z)\n    :effect (sat_clause ?x ?y ?z))\n  )\n",
        "batch_id": 1,
        "id": 20,
        "tokens": 4991,
        "corrected_description": "### General\nThis domain is designed for solving SAT (Boolean satisfiability problem) instances. It models the setting and satisfying of variables within clauses. The goal is to find a sequence of actions that leads to all clauses being satisfied.\n\n### Predicates\n- (is_clear ?x): Indicates that variable ?x is clear.\n- (is_set ?x): Indicates that variable ?x has been set.\n- (is_neg ?x ?y): Indicates that variable ?x is the negation of variable ?y.\n- (sat_clause ?x ?y ?z): Indicates that the clause containing variables ?x, ?y, and ?z is satisfied.\n\n### Actions\n- set_var <?var> <?neg>: Sets a variable and its negation.  \n- make_sat_x <?x> <?y> <?z>: Satisfies a clause based on variable ?x being set.  \n- make_sat_y <?x> <?y> <?z>: Satisfies a clause based on variable ?y being set.  \n- make_sat_z <?x> <?y> <?z>: Satisfies a clause based on variable ?z being set.",
        "pddl_domain_processed": "\n(define (domain sat)\n  (:requirements :strips)\n  (:predicates (is_clear ?x) (is_set ?x) (is_neg ?x ?y) (sat_clause ?x ?y ?z))\n\n  (:action set_var\n    :parameters (?var ?neg)\n    :precondition (and (is_neg ?var ?neg) (is_clear ?var) (is_clear ?neg))\n    :effect (and (is_set ?var) (not (is_clear ?var)) (not (is_clear ?neg))))\n\n  (:action make_sat_x\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?x)\n    :effect (sat_clause ?x ?y ?z))\n\n  (:action make_sat_y\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?y)\n    :effect (sat_clause ?x ?y ?z))\n\n  (:action make_sat_z\n    :parameters (?x ?y ?z)\n    :precondition (is_set ?z)\n    :effect (sat_clause ?x ?y ?z))\n  )\n"
    },
    {
        "file_name": "rgascons_PracticaPDDL_dominio.pddl",
        "pddl_domain": "(define (domain libros)\n\t(:requirements :strips :adl :typing)\n\t\n\t(:types\n\t\tLibro Mes - Object\n\t)\n\t\n\t(:predicates\n\t\t(predecesor ?x - Libro ?y - Libro) ;?x es predecesor de ?y\n\t\t(anterior ?m - Mes ?n - Mes); ?m es anterior a ?n\n\t\t(libro_asignado ?l - Libro)\n\t\t(libro_leido ?l - Libro)\n\t\t(libro_a_leer ?l - Libro)\n\t\t(asignado_en ?l - Libro ?m - Mes)\n\t\t(paralelo ?par - Libro ?libro - Libro)\n\t)\n\n\t\n\t;(:action asignar_par\n\t;\t:parameters (?libro - Libro ?par - Libro ?mes - Mes ?antOig - Mes)\n\t;\t:precondition \n\t;\t(and \n\t;\t\t(not (libro_asignado ?par))\n\t;\t\t(not (libro_leido ?par))\n\t;\t\t(paralelo ?par ?libro)\n\t;\t\t(or (anterior ?antOig ?mes) (= ?mes ?antOig))\n\t;\t)\n\t;\t:effect\n\t;\t(and (asignado_en ?par ?antOig) (libro_asignado ?par))\n\t;)\n\n\n\t(:action asignar\n\t\t:parameters (?libro - Libro ?mes - Mes)\n\t\t:precondition \n\t\t\t(and\n\t\t\t\t(not (libro_asignado ?libro))\n\t\t\t\t(not (libro_leido ?libro))\n\t\t\t\t(forall (?pred - Libro)\n\t\t\t\t\t(or \n\t\t\t\t\t\t(libro_leido ?pred)\n\t\t\t\t\t\t(and \n\t\t\t\t\t\t\t(imply (predecesor ?pred ?libro) \n\t\t\t\t\t\t\t\t(exists (?ant - Mes) (and (anterior ?ant ?mes) (asignado_en ?pred ?ant)))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(imply (paralelo ?pred ?libro) (asignado_en ?pred ?mes))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t:effect (and (asignado_en ?libro ?mes) (libro_asignado ?libro))\n\t)\n)",
        "batch_id": 1,
        "id": 27,
        "tokens": 5342,
        "corrected_description": "### General\nThis domain is designed for managing the assignment and reading of books (Libros) over a series of months. It includes actions for assigning books to be read in specific months, considering prerequisites (predecessors) and parallel readings.\n\n### Types\n- **Libro**: Represents books that are to be assigned and read.\n- **Mes**: Represents months during which books can be assigned and read.\n\n### Predicates\n- **(predecesor ?x - Libro ?y - Libro)**: Indicates that book ?x is a predecessor of book ?y, meaning ?y should be read after ?x.\n- **(anterior ?m - Mes ?n - Mes)**: Indicates that month ?m is before month ?n.\n- **(libro_asignado ?l - Libro)**: Indicates that book ?l has been assigned to a month.\n- **(libro_leido ?l - Libro)**: Indicates that book ?l has been read.\n- **(libro_a_leer ?l - Libro)**: Indicates that book ?l is to be read (not necessarily assigned yet).\n- **(asignado_en ?l - Libro ?m - Mes)**: Indicates that book ?l is assigned to month ?m.\n- **(paralelo ?par - Libro ?libro - Libro)**: Indicates that book ?par can be read in parallel with book ?libro.\n\n### Actions\n- **asignar <?libro> <?mes>**: Assigns a book to be read in a specific month. The book must not already be assigned or read and the book can only be assigned if all its predecessors have been read or assigned in a previous month and parallel books must be assigned in the same month.",
        "pddl_domain_processed": "(define (domain libros)\n\t(:requirements :strips :adl :typing)\n\n\t(:types\n\t\tLibro Mes - Object\n\t)\n\n\t(:predicates\n\t\t(predecesor ?x - Libro ?y - Libro) \n\t\t(anterior ?m - Mes ?n - Mes)\n\t\t(libro_asignado ?l - Libro)\n\t\t(libro_leido ?l - Libro)\n\t\t(libro_a_leer ?l - Libro)\n\t\t(asignado_en ?l - Libro ?m - Mes)\n\t\t(paralelo ?par - Libro ?libro - Libro)\n\t)\n\n\t(:action asignar\n\t\t:parameters (?libro - Libro ?mes - Mes)\n\t\t:precondition \n\t\t\t(and\n\t\t\t\t(not (libro_asignado ?libro))\n\t\t\t\t(not (libro_leido ?libro))\n\t\t\t\t(forall (?pred - Libro)\n\t\t\t\t\t(or \n\t\t\t\t\t\t(libro_leido ?pred)\n\t\t\t\t\t\t(and \n\t\t\t\t\t\t\t(imply (predecesor ?pred ?libro) \n\t\t\t\t\t\t\t\t(exists (?ant - Mes) (and (anterior ?ant ?mes) (asignado_en ?pred ?ant)))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(imply (paralelo ?pred ?libro) (asignado_en ?pred ?mes))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t:effect (and (asignado_en ?libro ?mes) (libro_asignado ?libro))\n\t)\n)"
    },
    {
        "file_name": "seanlanepgh_Tile-Cleaning-Robot-PDDL_domain .pddl",
        "pddl_domain": ";;Domain for cleaning floor tiles\n;; Define the name for this domain (needs to match the domain definition\n;;   in the problem files)\n\n(define (domain floor-tile)\n\n\t;; We only require some typing to make this plan faster. We can do without!\n\t(:requirements :typing)\n\n\t;; We have two types: robots and the tiles, both are objects\n\t(:types robot tile - object)\n\n\t;; define all the predicates as they are used in the problem files\n\t(:predicates  \n\n    ;; described what tile a robot is at\n    (robot-at ?robot - robot ?robotTile - tile)\n\n    ;; indicates that tile ?tileAbove is above tile ?tileBelow\n    (up ?tileAbove - tile ?tileBelow - tile)\n\n    ;; indicates that tile ?tileBelow is below tile ?tileAbove\n    (down ?tileBelow - tile ?tileAbove - tile)\n\n    ;; indicates that tile ?tileOnRight is right of tile ?tileOnLeft\n    (right ?tileOnRight - tile ?tileOnLeft - tile)\n\n    ;; indicates that tile ?tileOnLeft is left of tile ?tileOnRight\n    (left ?tileOnLeft - tile ?tileOnRight - tile)\n    \n    ;; indicates that a tile is clear (robot can move there)\n    (clear ?clearedTile - tile)\n\n    ;; indicates that a tile is cleaned\n    (cleaned ?cleanedTile - tile)\n \t)\n  \n  ;; actions\n  ;; clean-up action  \n  (:action clean-up\n        ;; clean-up action takes a robot object called robot and it takes two tile objects called tileToBeCleaned and robotTile\n        :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile)\n        ;; Preconditions for the action clean-up\n        :precondition (and\n                       ;; The clean-up action uses the predicate called robot-at to check a robot is on a tile\n                       (robot-at ?robot ?robotTile) \n                       ;; The predicate called up is used to check if the tileToBeCleaned is above the tile that the robot is on\n                       (up ?tileToBeCleaned ?robotTile) \n                       ;;The predicate clear is used to check if the tileToBeCleaned is clear\n                       (clear ?tileToBeCleaned)\n                       ;; This precondition uses the predicate cleaned,this  is used to check if the tileToBeCleaned is not cleaned\n                       (not(cleaned ?tileToBeCleaned))\n                  )\n    ;;Effects of the action clean-up \t\t\t\t\t\n    :effect (and \n              ;; The action clean-up causes the tileToBeCleaned to be cleaned and so the predicate cleaned is used to show the tileToBeCleaned is cleaned\n               ( cleaned ?tileToBeCleaned)\n              ;; As the tile is now clean it is also not clear as the robot cannot move on clean tiles\n               (not(clear ?tileToBeCleaned))\n            )\n  )\n  \n  ;;clean-down action\n  (:action clean-down\n      ;; clean-down action takes a robot object called robot and it takes two tile objects called tileToBeCleaned and robotTile\n     :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile )\n   ;; Preconditions for the action clean-down \n   :precondition (and \n                       ;; The clean-down action uses the predicate called robot-at to check a robot is on a tile\n                      (robot-at ?robot ?robotTile)\n                       ;; The predicate called up is used to check if the tileToBeCleaned is above the tile that the robot is on\n                      (down ?tileToBeCleaned ?robotTile)\n                       ;;The predicate clear is used to check if the tileToBeCleaned is clear\n                      (clear ?tileToBeCleaned) \n                       ;; This precondition uses the predicate cleaned,this  is used to check if the tileToBeCleaned is not cleaned\n                      (not(cleaned ?tileToBeCleaned))\n                  )\n   ;;Effects of the action clean-down \t\n    :effect (and \n              ;; The action clean-down causes the tileToBeCleaned to be cleaned and so the predicate cleaned is used to show the tileToBeCleaned is cleaned\n              ( cleaned ?tileToBeCleaned)\n              ;; As the tile is now clean it is also not clear as the robot cannot move on clean tiles\n              (not(clear ?tileToBeCleaned))\n          )\n  )\n  \n  ;; up action\n  (:action up\n          ;; up action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action up\n         :precondition (and \n                      ;; The up action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       ;; The predicate called up is used to check if the moveToNextTile is above the tile that the robot is on \n                        (up ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                         ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n          ;;Effects of the action up\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; down action\n  (:action down\n         ;; down action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action down\n         :precondition (and \n                      \t;; The down action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       \t;; The predicate called down is used to check if the moveToNextTile is below the tile that the robot is on \n                        (down ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n          ;;Effects of the action down\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; right action\n  (:action right\n         ;; right action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action right\n         :precondition (and \n                      \t;; The right action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                      \t;; The predicate called right is used to check if the moveToNextTile is below the tile that the robot is on \n                        (right ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n         ;;Effects of the action right\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n  \n  ;; left action\n  (:action left\n         ;; left action takes a robot object called robot and it takes two tile objects called moveToNextTile and robotTile\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n         ;; Preconditions for the action left\n         :precondition (and \n                     \t ;; The left action uses the predicate called robot-at to check a robot is on a tile\n                        (robot-at ?robot ?robotTile)\n                       \t;; The predicate called left is used to check if the moveToNextTile is below the tile that the robot is on \n                        (left ?moveToNextTile ?robotTile)\n                        ;;The predicate clear is used to check if the moveToNextTile is clear\n                        (clear ?moveToNextTile)\n                        ;; This precondition uses the predicate cleaned,this  is used to check if the moveToNextTile is not cleaned\n                        (not(cleaned ?moveToNextTile))\n                       )\n         ;;Effects of the action left\n         :effect (and \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is not on its old tile position\n                  (not(robot-at ?robot ?robotTile)) \n                  ;; As the robot has moved it would need to used the robot-at predicate to say that the robot is on the moveToNextTile\n                  (robot-at ?robot ?moveToNextTile)\n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot is on the moveToNextTile and so it is not clear\n                  (not(clear ?moveToNextTile)) \n                  ;; As the robot has moved it would need to used the clear predicate to say that the robot's old tile position is now clear\n                  ( clear ?robotTile)\n                 )  \n  )\n)\n\n  \n\n\n",
        "batch_id": 1,
        "id": 28,
        "tokens": 7837,
        "corrected_description": "### General\nThis domain is designed for a robot tasked with cleaning floor tiles. The robot can move in four directions (up, down, right, left) relative to its current position on a grid of tiles. The goal is to clean all the specified tiles by moving to them and performing a cleaning action.\n\n### Types\n- **robot**: Represents the robot that performs the cleaning.\n- **tile**: Represents the individual tiles on the floor that may need to be cleaned.\n\n### Predicates\n- **(robot-at ?robot - robot ?robotTile - tile)**: Indicates that the robot is currently at a specific tile.\n- **(up ?tileAbove - tile ?tileBelow - tile)**: Indicates that one tile is directly above another.\n- **(down ?tileBelow - tile ?tileAbove - tile)**: Indicates that one tile is directly below another.\n- **(right ?tileOnRight - tile ?tileOnLeft - tile)**: Indicates that one tile is directly to the right of another.\n- **(left ?tileOnLeft - tile ?tileOnRight - tile)**: Indicates that one tile is directly to the left of another.\n- **(clear ?clearedTile - tile)**: Indicates that a tile is clear and robot can move there.\n- **(cleaned ?cleanedTile - tile)**: Indicates that a tile has been cleaned.\n\n### Actions\n- **clean-up <?robot> <?robotTile> <?tileToBeCleaned>**: Allows the robot (?robot) to clean a tile (?tileToBeCleaned) that is directly above its current position (?robotTile).  \n\n- **clean-down <?robot> <?robotTile> <?tileToBeCleaned>**: Allows the robot (?robot) to clean a tile (?tileToBeCleaned) that is directly below its current position (?robotTile).  \n\n- **up <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly above its current position (?robotTile).  \n\n- **down <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly below its current position (?robotTile).  \n\n- **right <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly to the right of its current position (?robotTile).  \n\n- **left <?robot> <?robotTile> <?moveToNextTile>**: Moves the robot (?robot) to a tile (?moveToNextTile) directly to the left of its current position (?robotTile).",
        "pddl_domain_processed": "\n\n(define (domain floor-tile)\n\n\t(:requirements :typing)\n\n\t(:types robot tile - object)\n\n\t(:predicates  \n\n    (robot-at ?robot - robot ?robotTile - tile)\n\n    (up ?tileAbove - tile ?tileBelow - tile)\n\n    (down ?tileBelow - tile ?tileAbove - tile)\n\n    (right ?tileOnRight - tile ?tileOnLeft - tile)\n\n    (left ?tileOnLeft - tile ?tileOnRight - tile)\n\n    (clear ?clearedTile - tile)\n\n    (cleaned ?cleanedTile - tile)\n \t)\n\n  (:action clean-up\n\n        :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile)\n\n        :precondition (and\n\n                       (robot-at ?robot ?robotTile) \n\n                       (up ?tileToBeCleaned ?robotTile) \n\n                       (clear ?tileToBeCleaned)\n\n                       (not(cleaned ?tileToBeCleaned))\n                  )\n\n    :effect (and \n\n               ( cleaned ?tileToBeCleaned)\n\n               (not(clear ?tileToBeCleaned))\n            )\n  )\n\n  (:action clean-down\n\n     :parameters (?robot - robot ?robotTile - tile ?tileToBeCleaned - tile )\n\n   :precondition (and \n\n                      (robot-at ?robot ?robotTile)\n\n                      (down ?tileToBeCleaned ?robotTile)\n\n                      (clear ?tileToBeCleaned) \n\n                      (not(cleaned ?tileToBeCleaned))\n                  )\n\n    :effect (and \n\n              ( cleaned ?tileToBeCleaned)\n\n              (not(clear ?tileToBeCleaned))\n          )\n  )\n\n  (:action up\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (up ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action down\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (down ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action right\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (right ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n\n  (:action left\n\n         :parameters(?robot - robot ?robotTile - tile ?moveToNextTile - tile)\n\n         :precondition (and \n\n                        (robot-at ?robot ?robotTile)\n\n                        (left ?moveToNextTile ?robotTile)\n\n                        (clear ?moveToNextTile)\n\n                        (not(cleaned ?moveToNextTile))\n                       )\n\n         :effect (and \n\n                  (not(robot-at ?robot ?robotTile)) \n\n                  (robot-at ?robot ?moveToNextTile)\n\n                  (not(clear ?moveToNextTile)) \n\n                  ( clear ?robotTile)\n                 )  \n  )\n)\n\n"
    },
    {
        "file_name": "SoarGroup_Domains-Planning-Domain-Definition-Language_bw_hard.pddl",
        "pddl_domain": "; Blocks world with both ontop and above relations\n(define (domain blocks_world_hard)\n  (:requirements :strips :adl)\n  (:predicates (on-table ?x) (on ?x ?y) (clear ?x) (above ?x ?y))\n\n  (:action MoveToTable\n    :parameters (?omf)\n    :precondition (and (clear ?omf) (not (on-table ?omf)))\n    :effect (and (on-table ?omf) \n                 ; the block being moved is no longer on top of what it used to be\n                 (forall (?right-below)\n                     (when (on ?omf ?right-below) \n                           (and (not (on ?omf ?right-below))\n                                (clear ?right-below))\n                     )\n                 )\n                 ; everything that the block being moved was above, it no longer is\n                 (forall (?lower) \n                         (when (above ?omf ?lower)\n                               (not (above ?omf ?lower))\n                         )\n                 )\n            )\n  )\n\n  (:action MoveToBlock\n    :parameters (?omf ?dest)\n    :precondition (and (clear ?omf) (clear ?dest))\n    :effect (and (on ?omf ?dest) \n                 (above ?omf ?dest)\n                 (not (clear ?dest)) \n                 ; the block is no longer on the table, if it was in the first place\n                 (when (on-table ?omf)\n                       (not (on-table ?omf)))\n                 ; the block being moved is no longer on top of what it used to be\n                 (forall (?right-below)\n                     (when (on ?omf ?right-below) \n                           (and (not (on ?omf ?right-below))\n                                (clear ?right-below))\n                     )\n                 )\n                 ; everything that the block being moved was above, it no longer is\n                 (forall (?lower) \n                         (when (above ?omf ?lower)\n                               (not (above ?omf ?lower))\n                         )\n                 )\n                 ; block being moved is now above all blocks below the destination\n                 (forall (?new-lower) \n                         (when (above ?dest ?new-lower)\n                               (above ?omf ?new-lower)\n                         )\n                 )\n            )\n  )\n)\n",
        "batch_id": 1,
        "id": 29,
        "tokens": 5244,
        "corrected_description": "### General\nThis domain represents a more complex version of the classic blocks world, incorporating both direct stacking (ontop) and indirect stacking (above) relations. It allows for the movement of blocks either back to the table or on top of another block, updating the \"ontop\" and \"above\" relations accordingly.\n\n### Predicates\n(on-table ?x): Indicates that block ?x is directly on the table.\n(on ?x ?y): Indicates that block ?x is directly on top of block ?y.\n(clear ?x): Indicates that there is no block on top of block ?x, making it accessible for movement.\n(above ?x ?y): Indicates that block ?x is somewhere above block ?y in the stack, either directly or indirectly.\n\n### Actions\n- **MoveToTable <?omf>**: Moves a block to the table.  \n\n- **MoveToBlock <?omf> <?dest>**: Moves a block on top of another block.",
        "pddl_domain_processed": "\n(define (domain blocks_world_hard)\n  (:requirements :strips :adl)\n  (:predicates (on-table ?x) (on ?x ?y) (clear ?x) (above ?x ?y))\n\n  (:action MoveToTable\n    :parameters (?omf)\n    :precondition (and (clear ?omf) (not (on-table ?omf)))\n    :effect (and (on-table ?omf) \n\n                 (forall (?right-below)\n                     (when (on ?omf ?right-below) \n                           (and (not (on ?omf ?right-below))\n                                (clear ?right-below))\n                     )\n                 )\n\n                 (forall (?lower) \n                         (when (above ?omf ?lower)\n                               (not (above ?omf ?lower))\n                         )\n                 )\n            )\n  )\n\n  (:action MoveToBlock\n    :parameters (?omf ?dest)\n    :precondition (and (clear ?omf) (clear ?dest))\n    :effect (and (on ?omf ?dest) \n                 (above ?omf ?dest)\n                 (not (clear ?dest)) \n\n                 (when (on-table ?omf)\n                       (not (on-table ?omf)))\n\n                 (forall (?right-below)\n                     (when (on ?omf ?right-below) \n                           (and (not (on ?omf ?right-below))\n                                (clear ?right-below))\n                     )\n                 )\n\n                 (forall (?lower) \n                         (when (above ?omf ?lower)\n                               (not (above ?omf ?lower))\n                         )\n                 )\n\n                 (forall (?new-lower) \n                         (when (above ?dest ?new-lower)\n                               (above ?omf ?new-lower)\n                         )\n                 )\n            )\n  )\n)\n"
    },
    {
        "file_name": "Ratun011_ICE-Cream-Factory_domain(2).pddl",
        "pddl_domain": "(define (domain myDomain)\n    (:predicates (packaging)(assemble)(delivered)\n        (have-sprinkle)(have-chocolate)(have-vanilla)(have-cone)(have-order)\n        (sprinkle ?x)(chocolate ?x)(vanilla ?x)(cone ?x)(order ?x))\n \n    (:action packaging\n        :parameters ()\n\t    :precondition (and (assemble)\n\t    \t    \t   (not (delivered))) \n        :effect (and (packaging)\n                (not (assemble)))) \n\n    (:action delivery\n        :parameters ()\n        :precondition (and(not (delivered)) \n                      (packaging))\n        :effect (and (delivered)\n                 (not (packaging))))\n\n    (:action add-sprinkle\n        :parameters (?x)\n        :precondition (sprinkle ?x)\n        :effect (have-sprinkle))\n    \n    (:action add-chocolate\n        :parameters (?x)\n        :precondition (chocolate ?x)\n        :effect (have-chocolate))\n\n    (:action add-vanilla\n        :parameters (?x)\n        :precondition (vanilla ?x)\n        :effect (have-vanilla))\n  \n    (:action add-cone\n        :parameters (?x)\n        :precondition (cone ?x)\n        :effect (have-cone))\n    (:action order\n        :parameters (?x)\n        :precondition (order ?x)\n        :effect (have-order))\n  \n)\n",
        "batch_id": 1,
        "id": 32,
        "tokens": 5242,
        "corrected_description": "### General\nThis domain is centered around the process of assembling, packaging, and delivering ice cream orders. It includes actions for adding various ingredients to an ice cream order, packaging the assembled ice cream, and delivering it.\n\n### Predicates\n- (packaging): Indicates that the ice cream is being packaged.\n- (assemble): Indicates that the ice cream has been assembled.\n- (delivered): Indicates that the order has been delivered.\n- (have-sprinkle): Indicates that sprinkles have been added to the order.\n- (have-chocolate): Indicates that chocolate has been added to the order.\n- (have-vanilla): Indicates that vanilla has been added to the order.\n- (have-cone): Indicates that a cone has been added to the order.\n- (have-order): Indicates that there is an order to be processed.\n- (sprinkle ?x): Indicates that there are sprinkles available to be added to the order.\n- (chocolate ?x): Indicates that there is chocolate available to be added to the order.\n- (vanilla ?x): Indicates that there is vanilla available to be added to the order.\n- (cone ?x): Indicates that there are cones available to be added to the order.\n- (order ?x): Indicates that there is an order identified by ?x.\n\n### Actions\n- **packaging**: Packages the assembled ice cream.  \n- **delivery**: Delivers the packaged ice cream.  \n- **add-sprinkle <?x>**: Adds sprinkles to the ice cream.  \n- **add-chocolate <?x>**: Adds chocolate to the ice cream.  \n- **add-vanilla <?x>**: Adds vanilla to the ice cream.  \n- **add-cone <?x>**: Adds a cone to the ice cream.  \n- **order <?x>**: Processes an order.",
        "pddl_domain_processed": "(define (domain myDomain)\n    (:predicates (packaging)(assemble)(delivered)\n        (have-sprinkle)(have-chocolate)(have-vanilla)(have-cone)(have-order)\n        (sprinkle ?x)(chocolate ?x)(vanilla ?x)(cone ?x)(order ?x))\n\n    (:action packaging\n        :parameters ()\n\t    :precondition (and (assemble)\n\t    \t    \t   (not (delivered))) \n        :effect (and (packaging)\n                (not (assemble)))) \n\n    (:action delivery\n        :parameters ()\n        :precondition (and(not (delivered)) \n                      (packaging))\n        :effect (and (delivered)\n                 (not (packaging))))\n\n    (:action add-sprinkle\n        :parameters (?x)\n        :precondition (sprinkle ?x)\n        :effect (have-sprinkle))\n\n    (:action add-chocolate\n        :parameters (?x)\n        :precondition (chocolate ?x)\n        :effect (have-chocolate))\n\n    (:action add-vanilla\n        :parameters (?x)\n        :precondition (vanilla ?x)\n        :effect (have-vanilla))\n\n    (:action add-cone\n        :parameters (?x)\n        :precondition (cone ?x)\n        :effect (have-cone))\n    (:action order\n        :parameters (?x)\n        :precondition (order ?x)\n        :effect (have-order))\n\n)\n"
    },
    {
        "file_name": "IgnacioVellido_VGDL-PDDL_dummy_boulder.pddl",
        "pddl_domain": "(define (domain vgdl-game)\n  (:requirements :typing)\n  \n  (:types \n    num\n    Object\n    avatar wall sword dirt exitdoor diamond boulder crab butterfly - Object\n  )\n\n  (:predicates\n    (oriented-up ?o - Object)\n    (oriented-down ?o - Object)\n    (oriented-left ?o - Object)\n    (oriented-right ?o - Object)\n    (oriented-none ?o - Object)\n    (next ?x ?y - num)\n    (previous ?x ?y - num)\n    (at ?x ?y - num ?o - Object)\n    (has-sword ?a - avatar)\n  )\n\n  (:action MOVE_UP\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?y1 ?y2)\n      (not (exists (?w - wall) (at ?x1 ?y2 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x1 ?y2 ?a)\n      (oriented-up ?a)\n      (not (oriented-down ?a))\n      (not (oriented-left ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_DOWN\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?y2 ?y1)\n      (not (exists (?w - wall) (at ?x1 ?y2 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x1 ?y2 ?a)\n      (oriented-down ?a)\n      (not (oriented-up ?a))\n      (not (oriented-left ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_LEFT\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?x2 ?x1)\n      (not (exists (?w - wall) (at ?x2 ?y1 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x2 ?y1 ?a)\n      (oriented-left ?a)\n      (not (oriented-up ?a))\n      (not (oriented-down ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_RIGHT\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (previous ?x2 ?x1)\n      (not (exists (?w - wall) (at ?x2 ?y1 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x2 ?y1 ?a)\n      (oriented-right ?a)\n      (not (oriented-up ?a))\n      (not (oriented-down ?a))\n      (not (oriented-left ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action COLLECT_DIAMOND\n    :parameters (?a - avatar ?d - diamond ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?d)\n    )\n    :effect (and\n      (not (at ?x ?y ?d))\n    )\n  )\n\n  (:action COLLECT_SWORD\n    :parameters (?a - avatar ?s - sword ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?s)\n      (not (has-sword ?a))\n    )\n    :effect (and\n      (not (at ?x ?y ?s))\n      (has-sword ?a)\n    )\n  )\n\n  (:action KILL_CRAB\n    :parameters (?a - avatar ?c - crab ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?c)\n      (has-sword ?a)\n    )\n    :effect (and\n      (not (at ?x ?y ?c))\n    )\n  )\n\n  (:action KILL_BUTTERFLY\n    :parameters (?a - avatar ?b - butterfly ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?b)\n      (has-sword ?a)\n    )\n    :effect (and\n      (not (at ?x ?y ?b))\n    )\n  )\n)\n",
        "batch_id": 1,
        "id": 34,
        "tokens": 5093,
        "corrected_description": "### General\nThis domain models a VGDL (Video Game Description Language) game environment where an avatar interacts with various objects within a grid. The game includes elements such as walls, swords, dirt, exit doors, diamonds, boulders, crabs, and butterflies. The avatar and these objects can have specific orientations and positions within the game grid. The domain supports actions that change the state of the game based on the avatar's interactions and movements. Note: x represents the left-right direction, y represents the up-down direction.\n\n### Types\n- **num**: Represents numerical values, likely used for grid positions.\n- **avatar**: A subtype of Object, representing the player's character in the game.\n- **wall, sword, dirt, exitdoor, diamond, boulder, crab, butterfly**: These are all subtypes of Object, representing various elements within the game that the avatar can interact with.\n\n### Predicates\n- **(oriented-up ?o - Object)**: Indicates that an object is oriented upwards.\n- **(oriented-down ?o - Object)**: Indicates that an object is oriented downwards.\n- **(oriented-left ?o - Object)**: Indicates that an object is oriented to the left.\n- **(oriented-right ?o - Object)**: Indicates that an object is oriented to the right.\n- **(oriented-none ?o - Object)**: Indicates that an object has no specific orientation.\n- **(next ?x ?y - num)**: Represents a numerical sequence where ?y is the next number after ?x. This could be used to define movement or progression in the game.\n- **(previous ?x ?y - num)**: Represents a numerical sequence where ?y is the number before ?x. This could be used to define movement or regression in the game.\n- **(at ?x ?y - num ?o - Object)**: Indicates the position of an object on the grid, with ?x and ?y representing the grid coordinates.\n- **(has-sword ?a - avatar)**: Represents if avatar has a sword.\n\n### Actions\n- **MOVE_UP <?a> <?x1> <?x2> <?y1 <?y2>**: Moves the avatar upwards to the next position if no wall is present.\n- **MOVE_DOWN <?a> <?x1> <?x2> <?y1 <?y2>**: Moves the avatar downwards to the next position if no wall is present.\n- **MOVE_LEFT <?a> <?x1> <?x2> <?y1 <?y2>**: Moves the avatar to the left to the next position if no wall is present.\n- **MOVE_RIGHT <?a> <?x1> <?x2> <?y1 <?y2>**: Moves the avatar to the right to the next position if no wall is present.\n- **COLLECT_DIAMOND <?x> <?d> <?x> <?y>**: Allows the avatar to collect a diamond at its current position.\n- **COLLECT_SWORD <?a> <?s> <?x> <?y>**: Allows the avatar to collect a sword at its current position if it doesn't already have one.\n- **KILL_CRAB <?a> <?c> <?x> <?y>**: Allows the avatar to kill a crab at its current position if it has a sword.\n- **KILL_BUTTERFLY <?a> <?b> <?x> <?y>**: Allows the avatar to kill a butterfly at its current position if it has a sword.",
        "pddl_domain_processed": "(define (domain vgdl-game)\n  (:requirements :typing)\n\n  (:types \n    num\n    Object\n    avatar wall sword dirt exitdoor diamond boulder crab butterfly - Object\n  )\n\n  (:predicates\n    (oriented-up ?o - Object)\n    (oriented-down ?o - Object)\n    (oriented-left ?o - Object)\n    (oriented-right ?o - Object)\n    (oriented-none ?o - Object)\n    (next ?x ?y - num)\n    (previous ?x ?y - num)\n    (at ?x ?y - num ?o - Object)\n    (has-sword ?a - avatar)\n  )\n\n  (:action MOVE_UP\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?y1 ?y2)\n      (not (exists (?w - wall) (at ?x1 ?y2 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x1 ?y2 ?a)\n      (oriented-up ?a)\n      (not (oriented-down ?a))\n      (not (oriented-left ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_DOWN\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?y2 ?y1)\n      (not (exists (?w - wall) (at ?x1 ?y2 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x1 ?y2 ?a)\n      (oriented-down ?a)\n      (not (oriented-up ?a))\n      (not (oriented-left ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_LEFT\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (next ?x2 ?x1)\n      (not (exists (?w - wall) (at ?x2 ?y1 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x2 ?y1 ?a)\n      (oriented-left ?a)\n      (not (oriented-up ?a))\n      (not (oriented-down ?a))\n      (not (oriented-right ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action MOVE_RIGHT\n    :parameters (?a - avatar ?x1 ?x2 ?y1 ?y2 - num)\n    :precondition (and \n      (at ?x1 ?y1 ?a)\n      (previous ?x2 ?x1)\n      (not (exists (?w - wall) (at ?x2 ?y1 ?w)))\n    )\n    :effect (and\n      (not (at ?x1 ?y1 ?a))\n      (at ?x2 ?y1 ?a)\n      (oriented-right ?a)\n      (not (oriented-up ?a))\n      (not (oriented-down ?a))\n      (not (oriented-left ?a))\n      (not (oriented-none ?a))\n    )\n  )\n\n  (:action COLLECT_DIAMOND\n    :parameters (?a - avatar ?d - diamond ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?d)\n    )\n    :effect (and\n      (not (at ?x ?y ?d))\n    )\n  )\n\n  (:action COLLECT_SWORD\n    :parameters (?a - avatar ?s - sword ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?s)\n      (not (has-sword ?a))\n    )\n    :effect (and\n      (not (at ?x ?y ?s))\n      (has-sword ?a)\n    )\n  )\n\n  (:action KILL_CRAB\n    :parameters (?a - avatar ?c - crab ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?c)\n      (has-sword ?a)\n    )\n    :effect (and\n      (not (at ?x ?y ?c))\n    )\n  )\n\n  (:action KILL_BUTTERFLY\n    :parameters (?a - avatar ?b - butterfly ?x ?y - num)\n    :precondition (and\n      (at ?x ?y ?a)\n      (at ?x ?y ?b)\n      (has-sword ?a)\n    )\n    :effect (and\n      (not (at ?x ?y ?b))\n    )\n  )\n)\n"
    },
    {
        "file_name": "soartech_soar_miconic.pddl",
        "pddl_domain": "(define (domain miconic)\n  (:requirements :adl :typing)\n  (:types passenger\n          going_up going_down vip going_nonstop attendant never_alone \n          conflict_A conflict_B\n          floor)\n  (:predicates \n   (origin ?person - passenger ?floor - floor) ;; entry of ?person is ?floor\n   (destin ?person - passenger ?floor - floor) ;; exit of ?person is ?floor\n   (above ?floor1 - floor  ?floor2 - floor)    ;; ?floor2 is located above of ?floor1\n   (boarded ?person - passenger) ;; true if ?person has boarded the lift\n   (served ?person - passenger)  ;; true if ?person has alighted as her destination\n   (lift-at ?floor - floor)      ;; current position of the lift is at ?floor\n   )\n\n  (:action stop\n    :parameters (?f - floor)\n    :precondition (lift-at ?f)\n    :effect (and \n\t     (forall (?p - passenger) \n\t\t     (when (and (boarded ?p) \n\t\t\t\t            (destin ?p ?f))\n\t\t           (and (not (boarded ?p)) \n\t\t\t              (served  ?p))\n         )\n       )\n\t     (forall (?p - passenger)                \n\t\t     (when (and (origin ?p ?f) (not (served ?p)))\n\t\t       (boarded ?p)))))\n\n  (:action up\n    :parameters (?f1 - floor ?f2 - floor)\n    :precondition (and (lift-at ?f1) (above ?f1 ?f2))\n    :effect (and (lift-at ?f2) (not (lift-at ?f1))))\n\n  (:action down\n    :parameters (?f1 - floor ?f2 - floor)\n    :precondition (and (lift-at ?f1) (above ?f2 ?f1))\n    :effect (and (lift-at ?f2) (not (lift-at ?f1))))\n  )\n",
        "batch_id": 1,
        "id": 47,
        "tokens": 5390,
        "corrected_description": "### General\nThe Miconic domain models an elevator system designed to transport passengers between floors of a building. It supports advanced features like prioritizing certain passengers (VIPs, attendants) and handling special conditions (never alone, conflict groups). The goal is to efficiently transport all passengers to their desired floors while adhering to the constraints and preferences specified.\n\n### Types\n- **passenger**: Represents individuals using the elevator.\n- **going_up**: A subtype of passenger, represents passengers who are traveling upwards.\n- **going_down**: A subtype of passenger, represents passengers who are traveling downwards.\n- **vip**: A subtype of passenger, represents VIP passengers who might have priority over others.\n- **going_nonstop**: A subtype of passenger, represents passengers who require a nonstop trip to their destination.\n- **attendant**: A subtype of passenger, represents passengers who are attendants and might need to accompany other passengers.\n- **never_alone**: A subtype of passenger, represents passengers who must never be alone in the elevator.\n- **conflict_A**: A subtype of passenger, represents passengers who belong to a conflict group A, indicating they should not travel with certain other passengers.\n- **conflict_B**: A subtype of passenger, represents passengers who belong to a conflict group B, indicating they should not travel with certain other passengers.\n- **floor**: Represents the floors within the building.\n\n### Predicates\n- **(origin ?person - passenger ?floor - floor)**: Specifies the floor where a passenger begins their journey.\n- **(destin ?person - passenger ?floor - floor)**: Specifies the destination floor of a passenger.\n- **(above ?floor1 - floor ?floor2 - floor)**: Indicates that floor2 is directly above floor1.\n- **(boarded ?person - passenger)**: True if the passenger has boarded the elevator.\n- **(served ?person - passenger)**: True if the passenger has reached their destination floor and alighted from the elevator.\n- **(lift-at ?floor - floor)**: Indicates the current floor where the elevator is located.\n\n### Actions\n- **stop <?f>**: This action represents the elevator stopping at a floor.  \n  \n- **up <?f1> <?f2>**: Represents the elevator moving up from floor ?f1 to floor ?f2.  \n  \n- **down <?f1> <?f2>**: Represents the elevator moving down from floor ?f1 to floor ?f2.",
        "pddl_domain_processed": "(define (domain miconic)\n  (:requirements :adl :typing)\n  (:types passenger\n          going_up going_down vip going_nonstop attendant never_alone \n          conflict_A conflict_B\n          floor)\n  (:predicates \n   (origin ?person - passenger ?floor - floor) \n   (destin ?person - passenger ?floor - floor) \n   (above ?floor1 - floor  ?floor2 - floor)    \n   (boarded ?person - passenger) \n   (served ?person - passenger)  \n   (lift-at ?floor - floor)      \n   )\n\n  (:action stop\n    :parameters (?f - floor)\n    :precondition (lift-at ?f)\n    :effect (and \n\t     (forall (?p - passenger) \n\t\t     (when (and (boarded ?p) \n\t\t\t\t            (destin ?p ?f))\n\t\t           (and (not (boarded ?p)) \n\t\t\t              (served  ?p))\n         )\n       )\n\t     (forall (?p - passenger)                \n\t\t     (when (and (origin ?p ?f) (not (served ?p)))\n\t\t       (boarded ?p)))))\n\n  (:action up\n    :parameters (?f1 - floor ?f2 - floor)\n    :precondition (and (lift-at ?f1) (above ?f1 ?f2))\n    :effect (and (lift-at ?f2) (not (lift-at ?f1))))\n\n  (:action down\n    :parameters (?f1 - floor ?f2 - floor)\n    :precondition (and (lift-at ?f1) (above ?f2 ?f1))\n    :effect (and (lift-at ?f2) (not (lift-at ?f1))))\n  )\n"
    },
    {
        "file_name": "HAPILab_GoalAlignment_domain_new.pddl",
        "pddl_domain": "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Domain file automatically generated by the Tarski FSTRIPS writer\n;;; \n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain test_domain)\n    (:requirements :typing :equality)\n    (:types\n        tealeavesquality - object\n        object\n    )\n\n    (:constants\n        \n    )\n\n    (:predicates\n        (extendedarm )\n        (tea-made )\n        (tea-made-with ?x1 - tealeavesquality)\n        (on-upper-shelf ?x1 - tealeavesquality)\n        (on-lower-shelf ?x1 - tealeavesquality)\n        (in-kitchen )\n        (has-tealeaves ?x1 - tealeavesquality)\n        (can_climb )\n        (ladder-next-pantry )\n        (ladder-used )\n        (dummy )\n    )\n\n    (:functions\n        \n    )\n\n    \n\n    \n    (:action bring_ladder\n     :parameters ()\n     :precondition (in-kitchen )\n     :effect (and\n        (ladder-next-pantry ))\n    )\n\n\n    (:action grab_tealeaves\n     :parameters (?n - tealeavesquality)\n     :precondition (and (on-lower-shelf ?n) (in-kitchen ))\n     :effect (and\n        (has-tealeaves ?n))\n    )\n\n\n    (:action reach_tealeaves_extend_arm\n     :parameters (?g - tealeavesquality)\n     :precondition (and (on-upper-shelf ?g) (in-kitchen ))\n     :effect (and\n        (extendedarm )\n        (has-tealeaves ?g))\n    )\n\n\n    (:action reach_tealeaves_ladder\n     :parameters (?g - tealeavesquality)\n     :precondition (and (ladder-next-pantry ) (on-upper-shelf ?g) (can_climb ))\n     :effect (and\n        (has-tealeaves ?g)\n        (ladder-used ))\n    )\n\n\n    (:action make_tea\n     :parameters (?t - tealeavesquality)\n     :precondition (has-tealeaves ?t)\n     :effect (and\n        (tea-made )\n        (tea-made-with ?t))\n    )\n\n)",
        "batch_id": 1,
        "id": 48,
        "tokens": 5582,
        "corrected_description": "### General\nThis domain is designed for a scenario involving the preparation of tea with different qualities of tea leaves. The actions include moving a ladder, grabbing tea leaves from shelves, and making tea. The domain models the environment of a kitchen with upper and lower shelves where tea leaves are stored and a process for making tea with the selected tea leaves.\n\n### Types\n- **tealeavesquality**: Represents different qualities of tea leaves.\n- **object**: A general type for objects in the domain.\n\n### Predicates\n- **(extendedarm)**: Indicates that the robot's arm is extended.\n- **(tea-made)**: Indicates that tea has been made.\n- **(tea-made-with ?x1 - tealeavesquality)**: Indicates that tea has been made with a specific quality of tea leaves, denoted by ?x1.\n- **(on-upper-shelf ?x1 - tealeavesquality)**: Indicates that tea leaves of a specific quality are on the upper shelf.\n- **(on-lower-shelf ?x1 - tealeavesquality)**: Indicates that tea leaves of a specific quality are on the lower shelf.\n- **(in-kitchen)**: Indicates that the robot is in the kitchen.\n- **(has-tealeaves ?x1 - tealeavesquality)**: Indicates that the robot has tea leaves of a specific quality.\n- **(can_climb)**: Indicates that the robot can climb.\n- **(ladder-next-pantry)**: Indicates that the ladder is next to the pantry.\n- **(ladder-used)**: Indicates that the ladder has been used.\n- **(dummy)**: A placeholder predicate with no specific meaning.\n\n### Actions\n- **bring_ladder**: Moves the ladder next to the pantry if the robot is in the kitchen. The precondition for this action is that the robot is in the kitchen. The effect of this action is that the ladder is next to the pantry.\n\n- **grab_tealeaves <?n>**: Allows the robot to grab tea leaves from the lower shelf if it is in the kitchen. The precondition for this action is that the tea leaves are on the lower shelf and the robot is in the kitchen. The effect of this action is that the robot has the tea leaves.\n\n- **reach_tealeaves_extend_arm <?g>**: Allows the robot to reach and grab tea leaves from the upper shelf by extending its arm if it is in the kitchen.  \n\n- **reach_tealeaves_ladder <?g>**: Allows the robot to reach and grab tea leaves from the upper shelf using a ladder if the ladder is next to the pantry and the robot can climb.  \n\n- **make_tea <?t>**: Allows the robot to make tea with the tea leaves it has.",
        "pddl_domain_processed": "\n\n(define (domain test_domain)\n    (:requirements :typing :equality)\n    (:types\n        tealeavesquality - object\n        object\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n        (extendedarm )\n        (tea-made )\n        (tea-made-with ?x1 - tealeavesquality)\n        (on-upper-shelf ?x1 - tealeavesquality)\n        (on-lower-shelf ?x1 - tealeavesquality)\n        (in-kitchen )\n        (has-tealeaves ?x1 - tealeavesquality)\n        (can_climb )\n        (ladder-next-pantry )\n        (ladder-used )\n        (dummy )\n    )\n\n    (:functions\n\n    )\n\n    (:action bring_ladder\n     :parameters ()\n     :precondition (in-kitchen )\n     :effect (and\n        (ladder-next-pantry ))\n    )\n\n    (:action grab_tealeaves\n     :parameters (?n - tealeavesquality)\n     :precondition (and (on-lower-shelf ?n) (in-kitchen ))\n     :effect (and\n        (has-tealeaves ?n))\n    )\n\n    (:action reach_tealeaves_extend_arm\n     :parameters (?g - tealeavesquality)\n     :precondition (and (on-upper-shelf ?g) (in-kitchen ))\n     :effect (and\n        (extendedarm )\n        (has-tealeaves ?g))\n    )\n\n    (:action reach_tealeaves_ladder\n     :parameters (?g - tealeavesquality)\n     :precondition (and (ladder-next-pantry ) (on-upper-shelf ?g) (can_climb ))\n     :effect (and\n        (has-tealeaves ?g)\n        (ladder-used ))\n    )\n\n    (:action make_tea\n     :parameters (?t - tealeavesquality)\n     :precondition (has-tealeaves ?t)\n     :effect (and\n        (tea-made )\n        (tea-made-with ?t))\n    )\n\n)"
    },
    {
        "file_name": "bennydeep_mestint-dump_agi-domain.pddl",
        "pddl_domain": "(define (domain tuske8)\n(:requirements :strips :equality)\n(:predicates (clear ?x)\n\t\t(on ?x ?y)\n\t\t(smaller ?x ?y)\n\t\t(color ?x ?y))\n\n(:action move\n:parameters (?disc ?c ?from ?to ?tocolor)\n:precondition (and (smaller ?to ?disc)\n\t\t\t(on ?disc ?from)\n\t\t\t(clear ?disc)\n\t\t\t(clear ?to)\n\t\t\t(color ?disc ?c)\n\t\t\t(color ?to ?tocolor)\n\t\t\t(not (= ?c ?tocolor )))\n:effect (and (clear ?from)\n\t\t(on ?disc ?to)\n\t\t(not (on ?disc ?from))\n\t\t(not (clear ?to))\n\t\t(not (color ?disc ?c))\n\t\t(color ?disc ?tocolor))\n))",
        "batch_id": 1,
        "id": 54,
        "tokens": 4951,
        "corrected_description": "### General\nThis domain, named tuske8, is designed for a puzzle or game scenario where discs of different sizes and colors are moved between pegs or locations. The goal is often to rearrange the discs according to specific rules related to their size and color.\n\n### Predicates\n(clear ?x): Indicates that there is no disc on top of ?x, making it possible to place another disc on it or move the top disc if ?x is a disc.\n(on ?x ?y): Indicates that disc ?x is directly on top of ?y, where ?y can be another disc or a peg/location.\n(smaller ?x ?y): Indicates that disc ?x is smaller than ?y, allowing ?x to be placed on ?y according to the rules of the game.\n(color ?x ?y): Indicates the color of disc ?x is ?y.\n\n### Actions\n- **move <?disc> <?c> <?from> <?to> <?tocolor>**: This action allows moving a disc from one location to another under certain conditions. The action parameters include the disc being moved (?disc), its color (?c), the original location (?from), the destination location (?to), and the color of the destination (?tocolor).",
        "pddl_domain_processed": "(define (domain tuske8)\n(:requirements :strips :equality)\n(:predicates (clear ?x)\n\t\t(on ?x ?y)\n\t\t(smaller ?x ?y)\n\t\t(color ?x ?y))\n\n(:action move\n:parameters (?disc ?c ?from ?to ?tocolor)\n:precondition (and (smaller ?to ?disc)\n\t\t\t(on ?disc ?from)\n\t\t\t(clear ?disc)\n\t\t\t(clear ?to)\n\t\t\t(color ?disc ?c)\n\t\t\t(color ?to ?tocolor)\n\t\t\t(not (= ?c ?tocolor )))\n:effect (and (clear ?from)\n\t\t(on ?disc ?to)\n\t\t(not (on ?disc ?from))\n\t\t(not (clear ?to))\n\t\t(not (color ?disc ?c))\n\t\t(color ?disc ?tocolor))\n))"
    },
    {
        "file_name": "taskography_pddlgym_taskographyv2tiny10.pddl",
        "pddl_domain": "\n(define (domain taskographyv2tiny10)\n  (:requirements :typing)\n  (:types agent room place location receptacle item)\n  \n  (:predicates (inroom ?v0 - agent ?v1 - room)\n\t(inplace ?v0 - agent ?v1 - place)\n\t(atlocation ?v0 - agent ?v1 - location)\n\t(receptacleatlocation ?v0 - receptacle ?v1 - location)\n\t(itematlocation ?v0 - item ?v1 - location)\n\t(placeinroom ?v0 - place ?v1 - room)\n\t(locationinplace ?v0 - location ?v1 - place)\n\t(roomplace ?v0 - place ?v1 - room)\n\t(placelocation ?v0 - location ?v1 - place)\n\t(roomsconnected ?v0 - room ?v1 - room)\n\t(inreceptacle ?v0 - item ?v1 - receptacle)\n\t(inanyreceptacle ?v0 - item)\n\t(holds ?v0 - agent ?v1 - item)\n\t(holdsany ?v0 - agent)\n\t(receptacleopeningtype ?v0 - receptacle)\n\t(receptacleopened ?v0 - receptacle)\n  )\n  ; (:actions )\n\n  \n\n\t(:action gotoroom\n\t\t:parameters (?a - agent ?rstart - room ?rend - room ?pstart - place ?pend - place ?lstart - location ?lend - location)\n\t\t:precondition (and (inroom ?a ?rstart)\n\t\t\t(inplace ?a ?pstart)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(roomplace ?pstart ?rstart)\n\t\t\t(placeinroom ?pstart ?rstart)\n\t\t\t(placelocation ?lstart ?pstart)\n\t\t\t(locationinplace ?lstart ?pstart)\n\t\t\t(roomplace ?pend ?rend)\n\t\t\t(placeinroom ?pend ?rend)\n\t\t\t(placelocation ?lend ?pend)\n\t\t\t(locationinplace ?lend ?pend)\n\t\t\t(roomsconnected ?rstart ?rend))\n\t\t:effect (and\n\t\t\t(inroom ?a ?rend)\n\t\t\t(inplace ?a ?pend)\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (inroom ?a ?rstart))\n\t\t\t(not (inplace ?a ?pstart))\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\t\n\n\t(:action gotoplace\n\t\t:parameters (?a - agent ?pstart - place ?pend - place ?lstart - location ?lend - location ?r - room)\n\t\t:precondition (and (inroom ?a ?r)\n\t\t\t(inplace ?a ?pstart)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(placeinroom ?pstart ?r)\n\t\t\t(placelocation ?lstart ?pstart)\n\t\t\t(locationinplace ?lstart ?pstart)\n\t\t\t(placeinroom ?pend ?r)\n\t\t\t(placelocation ?lend ?pend)\n\t\t\t(locationinplace ?lend ?pend))\n\t\t:effect (and\n\t\t\t(inplace ?a ?pend)\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (inplace ?a ?pstart))\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\t\n\n\t(:action gotolocation\n\t\t:parameters (?a - agent ?lstart - location ?lend - location ?p - place)\n\t\t:precondition (and (inplace ?a ?p)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(locationinplace ?lstart ?p)\n\t\t\t(locationinplace ?lend ?p))\n\t\t:effect (and\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\t\n\n\t(:action openreceptacle\n\t\t:parameters (?a - agent ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(not (receptacleopened ?r)))\n\t\t:effect (and\n\t\t\t(receptacleopened ?r))\n\t)\n\t\n\n\t(:action closereceptacle\n\t\t:parameters (?a - agent ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r))\n\t\t:effect (and\n\t\t\t(not (receptacleopened ?r)))\n\t)\n\t\n\n\t(:action pickupitemnoreceptacle\n\t\t:parameters (?a - agent ?i - item ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (inanyreceptacle ?i)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\t\n\n\t(:action pickupiteminreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(not (receptacleopeningtype ?r))\n\t\t\t(not (holdsany ?a)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (inreceptacle ?i ?r))\n\t\t\t(not (inanyreceptacle ?i))\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\t\n\n\t(:action pickupiteminopeningreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r)\n\t\t\t(not (holdsany ?a)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (inreceptacle ?i ?r))\n\t\t\t(not (inanyreceptacle ?i))\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\t\n\n\t(:action putiteminreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(not (receptacleopeningtype ?r))\n\t\t\t(holds ?a ?i))\n\t\t:effect (and\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(inanyreceptacle ?i)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (holds ?a ?i)))\n\t)\n\t\n\n\t(:action putiteminopeningreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r)\n\t\t\t(holds ?a ?i))\n\t\t:effect (and\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(inanyreceptacle ?i)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (holds ?a ?i)))\n\t)\n\n  \n\n)\n        ",
        "batch_id": 1,
        "id": 56,
        "tokens": 7031,
        "corrected_description": "### General\nThis domain, named TaskographyV2Tiny10, models a scenario where an agent navigates through rooms, places, and locations, interacts with receptacles, and manipulates items. The agent can move between connected rooms, navigate to different places within a room, and approach specific locations within those places. It can open and close receptacles, pick up items from locations or receptacles, and place items into receptacles. The domain is designed to simulate tasks that involve object retrieval, placement, and navigation in a structured environment.\n\n### Types\n- **agent**: Represents entities capable of performing actions.\n- **room**: Represents distinct areas that can contain places.\n- **place**: Represents specific areas within rooms.\n- **location**: Represents precise positions within places.\n- **receptacle**: Represents objects that can contain items.\n- **item**: Represents objects that can be manipulated by agents.\n\n### Predicates\n- **(inroom ?v0 - agent ?v1 - room)**: Indicates that agent ?v0 is in room ?v1.\n- **(inplace ?v0 - agent ?v1 - place)**: Indicates that agent ?v0 is at place ?v1.\n- **(atlocation ?v0 - agent ?v1 - location)**: Indicates that agent ?v0 is at location ?v1.\n- **(receptacleatlocation ?v0 - receptacle ?v1 - location)**: Indicates that receptacle ?v0 is at location ?v1.\n- **(itematlocation ?v0 - item ?v1 - location)**: Indicates that item ?v0 is at location ?v1.\n- **(placeinroom ?v0 - place ?v1 - room)**: Indicates that place ?v0 is in room ?v1.\n- **(locationinplace ?v0 - location ?v1 - place)**: Indicates that location ?v0 is in place ?v1.\n- **(roomplace ?v0 - place ?v1 - room)**: Indicates a relationship between place ?v0 and room ?v1.\n- **(placelocation ?v0 - location ?v1 - place)**: Indicates a relationship between location ?v0 and place ?v1.\n- **(roomsconnected ?v0 - room ?v1 - room)**: Indicates that room ?v0 is connected to room ?v1.\n- **(inreceptacle ?v0 - item ?v1 - receptacle)**: Indicates that item ?v0 is in receptacle ?v1.\n- **(inanyreceptacle ?v0 - item)**: Indicates that item ?v0 is in some receptacle.\n- **(holds ?v0 - agent ?v1 - item)**: Indicates that agent ?v0 is holding item ?v1.\n- **(holdsany ?v0 - agent)**: Indicates that agent ?v0 is holding some item.\n- **(receptacleopeningtype ?v0 - receptacle)**: Indicates that receptacle ?v0 has a specific opening type.\n- **(receptacleopened ?v0 - receptacle)**: Indicates that receptacle ?v0 is opened.\n\n### Actions\n- **gotoroom <?a> <?rstart> <?rend> <?pstart> <?pend> <?lstart> <?lend>**: Allows an agent (?a) to move from one room (?rstart) to another room (?rend), updating their place and location accordingly. The preconditions for this action are that the agent must be in the starting room (?rstart), at the starting place (?pstart), and at the starting location (?lstart). The starting place must be in the starting room, and the starting location must be in the starting place. The destination place (?pend) must be in the destination room, and the destination location (?lend) must be in the destination place. The starting and destination rooms must be connected. The effect of this action is that the agent is now in the destination room, at the destination place, and at the destination location, and no longer at the starting room, place, and location.\n\n- **gotoplace <?a> <?pstart> <?pend> <?lstart> <?lend> <?r>**: Allows an agent (?a) to move from one place (?pstart) to another place (?pend) within the same room (?r), updating their location accordingly.  \n\n- **gotolocation <?a> <?lstart> <?lend> <?p>**: Allows an agent (?a) to move from one location (?lstart) to another location (?lend) within the same place (?p).  \n\n- **openreceptacle <?a> <?r> <?l>**: Allows an agent (?a) to open a receptacle (?r) at a location (?l).  \n\n- **closereceptacle <?a> <?r> <?l>**: Allows an agent (?a) to close a receptacle (?r) at a location (?l).  \n\n- **pickupitemnoreceptacle <?a> <?i> <?l>**: Allows an agent (?a) to pick up an item (?i) at a location (?l) without using a receptacle.  \n\n- **pickupiteminreceptacle <?a> <?i> <?r> <?l>**: Allows an agent (?a) to pick up an item (?i) from a receptacle (?r) at a location (?l) when the receptacle does not have an opening type.  \n\n- **pickupiteminopeningreceptacle <?a> <?i> <?r> <?l>**: Allows an agent (?a) to pick up an item (?i) from an opened receptacle (?r) at a location (?l) when the receptacle has an opening type.  \n\n- **putiteminreceptacle <?a> <?i> <?r> <?l>**: Allows an agent (?a) to put an item (?i) into a receptacle (?r) at a location (?l) when the receptacle does not have an opening type.  \n\n- **putiteminopeningreceptacle <?a> <?i> <?r> <?l>**: Allows an agent (?a) to put an item (?i) into an opened receptacle (?r) at a location (?l) when the receptacle has an opening type.",
        "pddl_domain_processed": "\n(define (domain taskographyv2tiny10)\n  (:requirements :typing)\n  (:types agent room place location receptacle item)\n\n  (:predicates (inroom ?v0 - agent ?v1 - room)\n\t(inplace ?v0 - agent ?v1 - place)\n\t(atlocation ?v0 - agent ?v1 - location)\n\t(receptacleatlocation ?v0 - receptacle ?v1 - location)\n\t(itematlocation ?v0 - item ?v1 - location)\n\t(placeinroom ?v0 - place ?v1 - room)\n\t(locationinplace ?v0 - location ?v1 - place)\n\t(roomplace ?v0 - place ?v1 - room)\n\t(placelocation ?v0 - location ?v1 - place)\n\t(roomsconnected ?v0 - room ?v1 - room)\n\t(inreceptacle ?v0 - item ?v1 - receptacle)\n\t(inanyreceptacle ?v0 - item)\n\t(holds ?v0 - agent ?v1 - item)\n\t(holdsany ?v0 - agent)\n\t(receptacleopeningtype ?v0 - receptacle)\n\t(receptacleopened ?v0 - receptacle)\n  )\n\n\t(:action gotoroom\n\t\t:parameters (?a - agent ?rstart - room ?rend - room ?pstart - place ?pend - place ?lstart - location ?lend - location)\n\t\t:precondition (and (inroom ?a ?rstart)\n\t\t\t(inplace ?a ?pstart)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(roomplace ?pstart ?rstart)\n\t\t\t(placeinroom ?pstart ?rstart)\n\t\t\t(placelocation ?lstart ?pstart)\n\t\t\t(locationinplace ?lstart ?pstart)\n\t\t\t(roomplace ?pend ?rend)\n\t\t\t(placeinroom ?pend ?rend)\n\t\t\t(placelocation ?lend ?pend)\n\t\t\t(locationinplace ?lend ?pend)\n\t\t\t(roomsconnected ?rstart ?rend))\n\t\t:effect (and\n\t\t\t(inroom ?a ?rend)\n\t\t\t(inplace ?a ?pend)\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (inroom ?a ?rstart))\n\t\t\t(not (inplace ?a ?pstart))\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\n\t(:action gotoplace\n\t\t:parameters (?a - agent ?pstart - place ?pend - place ?lstart - location ?lend - location ?r - room)\n\t\t:precondition (and (inroom ?a ?r)\n\t\t\t(inplace ?a ?pstart)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(placeinroom ?pstart ?r)\n\t\t\t(placelocation ?lstart ?pstart)\n\t\t\t(locationinplace ?lstart ?pstart)\n\t\t\t(placeinroom ?pend ?r)\n\t\t\t(placelocation ?lend ?pend)\n\t\t\t(locationinplace ?lend ?pend))\n\t\t:effect (and\n\t\t\t(inplace ?a ?pend)\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (inplace ?a ?pstart))\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\n\t(:action gotolocation\n\t\t:parameters (?a - agent ?lstart - location ?lend - location ?p - place)\n\t\t:precondition (and (inplace ?a ?p)\n\t\t\t(atlocation ?a ?lstart)\n\t\t\t(locationinplace ?lstart ?p)\n\t\t\t(locationinplace ?lend ?p))\n\t\t:effect (and\n\t\t\t(atlocation ?a ?lend)\n\t\t\t(not (atlocation ?a ?lstart)))\n\t)\n\n\t(:action openreceptacle\n\t\t:parameters (?a - agent ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(not (receptacleopened ?r)))\n\t\t:effect (and\n\t\t\t(receptacleopened ?r))\n\t)\n\n\t(:action closereceptacle\n\t\t:parameters (?a - agent ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r))\n\t\t:effect (and\n\t\t\t(not (receptacleopened ?r)))\n\t)\n\n\t(:action pickupitemnoreceptacle\n\t\t:parameters (?a - agent ?i - item ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (inanyreceptacle ?i)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\n\t(:action pickupiteminreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(not (receptacleopeningtype ?r))\n\t\t\t(not (holdsany ?a)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (inreceptacle ?i ?r))\n\t\t\t(not (inanyreceptacle ?i))\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\n\t(:action pickupiteminopeningreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r)\n\t\t\t(not (holdsany ?a)))\n\t\t:effect (and\n\t\t\t(holdsany ?a)\n\t\t\t(holds ?a ?i)\n\t\t\t(not (inreceptacle ?i ?r))\n\t\t\t(not (inanyreceptacle ?i))\n\t\t\t(not (itematlocation ?i ?l)))\n\t)\n\n\t(:action putiteminreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(not (receptacleopeningtype ?r))\n\t\t\t(holds ?a ?i))\n\t\t:effect (and\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(inanyreceptacle ?i)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (holds ?a ?i)))\n\t)\n\n\t(:action putiteminopeningreceptacle\n\t\t:parameters (?a - agent ?i - item ?r - receptacle ?l - location)\n\t\t:precondition (and (atlocation ?a ?l)\n\t\t\t(receptacleatlocation ?r ?l)\n\t\t\t(receptacleopeningtype ?r)\n\t\t\t(receptacleopened ?r)\n\t\t\t(holds ?a ?i))\n\t\t:effect (and\n\t\t\t(inreceptacle ?i ?r)\n\t\t\t(inanyreceptacle ?i)\n\t\t\t(itematlocation ?i ?l)\n\t\t\t(not (holdsany ?a))\n\t\t\t(not (holds ?a ?i)))\n\t)\n\n)\n        "
    },
    {
        "file_name": "goldminer",
        "pddl_domain": "(define (domain gold-miner-typed)\n(:requirements :typing)\n(:types LOC)\n\n(:predicates\n        (robot-at ?x - LOC)\n        (bomb-at ?x - LOC )\n        (laser-at ?x - LOC)\n        (soft-rock-at ?x - LOC)\n        (hard-rock-at ?x - LOC)\n        (gold-at ?x - LOC)\n        (arm-empty)\n        (holds-bomb)\n                (holds-laser)\n        (holds-gold)\n        (clear ?x - LOC)\n        (connected ?x - LOC ?y - LOC)\n)\n\n\n\n(:action move\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (connected ?x ?y) (clear ?y))\n  :effect (and (robot-at ?y) (not (robot-at ?x)))\n)\n\n(:action pickup-laser\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (laser-at ?x) (arm-empty))\n  :effect (and (not (arm-empty)) (holds-laser) (not (laser-at ?x)) )\n)\n\n\n(:action pickup-bomb\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (bomb-at ?x) (arm-empty))\n  :effect (and (not (arm-empty)) (holds-bomb) (not (bomb-at ?x)))\n)\n\n(:action putdown-laser\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (holds-laser))\n  :effect (and (arm-empty) (not (holds-laser)) (laser-at ?x))\n)\n\n\n(:action detonate-bomb\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (holds-bomb)\n                     (connected ?x ?y) (soft-rock-at ?y))\n  :effect (and (not (holds-bomb)) (arm-empty) (clear ?y) (not (soft-rock-at ?y)))\n)\n\n(:action fire-laser\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (holds-laser)\n                     (connected ?x ?y))\n  :effect (and (clear ?y) (not (soft-rock-at ?y)) (not (gold-at ?y))\n               (not (hard-rock-at ?y)))\n)\n\n\n\n(:action pick-gold\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (arm-empty) (gold-at ?x))\n  :effect (and (not (arm-empty)) (holds-gold) (not (gold-at ?x)))\n)\n)\n",
        "batch_id": 2,
        "id": 59,
        "tokens": 5746,
        "corrected_description": "### General\nThis domain is designed for a gold-mining scenario where a robot can move around a grid, interact with objects, and collect gold. The robot can pick up and use tools like lasers and bombs to clear obstacles such as soft and hard rocks. The ultimate goal is to collect gold while navigating through a grid of connected locations.\n\n### Types\nLOC: Represents the locations in the grid.\n\n### Predicates\n(robot-at ?x - LOC): Indicates the robot is at location ?x.\n(bomb-at ?x - LOC): Indicates there is a bomb at location ?x.\n(laser-at ?x - LOC): Indicates there is a laser at location ?x.\n(soft-rock-at ?x - LOC): Indicates there is soft rock at location ?x.\n(hard-rock-at ?x - LOC): Indicates there is hard rock at location ?x.\n(gold-at ?x - LOC): Indicates there is gold at location ?x.\n(arm-empty): Indicates the robot's arm is empty.\n(holds-bomb): Indicates the robot is holding a bomb.\n(holds-laser): Indicates the robot is holding a laser.\n(holds-gold): Indicates the robot is holding gold.\n(clear ?x - LOC): Indicates location ?x is clear of obstacles.\n(connected ?x - LOC ?y - LOC): Indicates location ?x is connected to location ?y.\n\n### Actions\n- **move <?x> <?y>**: Allows a robot to move to an adjacent empty grid location.  \n\n- **pickup-laser <?x>**: Allows a robot to pick up a laser at a location (?x).  \n\n- **pickup-bomb <?x>**: Allows a robot to pick up a bomb at a location (?x).  \n\n- **putdown-laser <?x>**: Allows a robot to put down a laser at a location (?x).  \n\n- **detonate-bomb <?x> <?y>**: Allows a robot to detonate a bomb at an adjacent location (?y) that has soft rock.  \n\n- **fire-laser <?x> <?y>**: Allows a robot to fire a laser at an adjacent location (?y).  \n\n- **pick-gold <?x>**: Allows a robot to mine gold at a location (?x).",
        "pddl_domain_processed": "(define (domain gold-miner-typed)\n(:requirements :typing)\n(:types LOC)\n\n(:predicates\n        (robot-at ?x - LOC)\n        (bomb-at ?x - LOC )\n        (laser-at ?x - LOC)\n        (soft-rock-at ?x - LOC)\n        (hard-rock-at ?x - LOC)\n        (gold-at ?x - LOC)\n        (arm-empty)\n        (holds-bomb)\n                (holds-laser)\n        (holds-gold)\n        (clear ?x - LOC)\n        (connected ?x - LOC ?y - LOC)\n)\n\n(:action move\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (connected ?x ?y) (clear ?y))\n  :effect (and (robot-at ?y) (not (robot-at ?x)))\n)\n\n(:action pickup-laser\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (laser-at ?x) (arm-empty))\n  :effect (and (not (arm-empty)) (holds-laser) (not (laser-at ?x)) )\n)\n\n(:action pickup-bomb\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (bomb-at ?x) (arm-empty))\n  :effect (and (not (arm-empty)) (holds-bomb) (not (bomb-at ?x)))\n)\n\n(:action putdown-laser\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (holds-laser))\n  :effect (and (arm-empty) (not (holds-laser)) (laser-at ?x))\n)\n\n(:action detonate-bomb\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (holds-bomb)\n                     (connected ?x ?y) (soft-rock-at ?y))\n  :effect (and (not (holds-bomb)) (arm-empty) (clear ?y) (not (soft-rock-at ?y)))\n)\n\n(:action fire-laser\n  :parameters (?x - LOC ?y - LOC)\n  :precondition (and (robot-at ?x) (holds-laser)\n                     (connected ?x ?y))\n  :effect (and (clear ?y) (not (soft-rock-at ?y)) (not (gold-at ?y))\n               (not (hard-rock-at ?y)))\n)\n\n(:action pick-gold\n  :parameters (?x - LOC)\n  :precondition (and (robot-at ?x) (arm-empty) (gold-at ?x))\n  :effect (and (not (arm-empty)) (holds-gold) (not (gold-at ?x)))\n)\n)\n"
    },
    {
        "file_name": "mprime",
        "pddl_domain": "(define (domain mprime-strips)\n   (:requirements :typing)\n   (:types location space fuel locatable - object\n           vehicle cargo - locatable)\n   (:predicates\n       (at ?o - locatable ?l - location)\n       (conn ?l1 ?l2 - location)\n       (has-fuel ?l - location ?f - fuel)\n       (fuel-neighbor ?f1 ?f2 - fuel)\n       (in ?c - cargo ?v - vehicle)\n       (has-space ?v - vehicle ?s - space)\n       (space-neighbor ?s1 ?s2 - space)\n       (not-equal ?l1 ?l2 - location)\n\n)\n\n\n\n   (:action move\n       :parameters (?v - vehicle ?l1 ?l2 - location ?f1 ?f2 - fuel)\n       :precondition (and (at ?v ?l1)\n                          (conn ?l1 ?l2)\n                          (has-fuel ?l1 ?f1)\n                          (fuel-neighbor ?f2 ?f1))\n       :effect (and (not (at ?v ?l1))\n                    (at ?v ?l2)\n                    (not (has-fuel ?l1 ?f1))\n                    (has-fuel ?l1 ?f2)))\n\n   (:action load\n       :parameters (?c - cargo ?v - vehicle ?l - location ?s1 ?s2 - space)\n       :precondition (and (at ?c ?l)\n                          (at ?v ?l)\n                          (has-space ?v ?s1)\n\t\t\t  (space-neighbor ?s2 ?s1))\n       :effect (and (not (at ?c ?l))\n                    (in ?c ?v)\n                    (not (has-space ?v ?s1))\n                    (has-space ?v ?s2)))\n\n   (:action unload\n       :parameters (?c - cargo ?v - vehicle ?l - location ?s1 ?s2 - space)\n       :precondition (and (in ?c ?v)\n                          (at ?v ?l)\n\t\t\t  (has-space ?v ?s1)\n                          (space-neighbor ?s1 ?s2))\n       :effect (and (not (in ?c ?v))\n                    (at ?c ?l)\n                    (not (has-space ?v ?s1))\n                    (has-space ?v ?s2)))\n\n   (:action donate\n      :parameters (?l1 ?l2 - location ?f11 ?f12 ?f21 ?f22 - fuel)\n      :precondition (and (not-equal ?l1 ?l2)\n                         (has-fuel ?l1 ?f11)\n                         (fuel-neighbor ?f12 ?f11)\n                         (has-fuel ?l2 ?f21)\n                         (fuel-neighbor ?f21 ?f22))\n      :effect (and (not (has-fuel ?l1 ?f11))\n                   (has-fuel ?l1 ?f12)\n                   (not (has-fuel ?l2 ?f21))\n                   (has-fuel ?l2 ?f22)))\n\n)\n",
        "batch_id": 2,
        "id": 60,
        "tokens": 5838,
        "corrected_description": "### General\nThis domain, named mprime-strips, models a logistics scenario involving the movement of vehicles and cargo between different locations. It incorporates the management of fuel and space resources, essential for planning the transportation tasks. The domain is designed to simulate logistics operations, including loading and unloading cargo, moving vehicles between locations, and transferring fuel among locations to ensure vehicles can continue their operations.\n\n### Types\n- **location**: Represents the various locations in the domain.\n- **space**: A type representing the space available in vehicles for cargo.\n- **fuel**: Represents different quantities of fuel available at locations.\n- **locatable**: A superclass of objects that can have a location, including vehicles and cargo.\n- **vehicle**: Subtype of locatable, represents vehicles that can move cargo.\n- **cargo**: Subtype of locatable, represents cargo items to be transported.\n\n### Predicates\n- **(at ?o - locatable ?l - location)**: Indicates that a locatable object (?o) is at a specific location (?l).\n- **(conn ?l1 ?l2 - location)**: Represents a connection between two locations, allowing travel between them.\n- **(has-fuel ?l - location ?f - fuel)**: Indicates that a location (?l) has a certain amount of fuel (?f) available.\n- **(fuel-neighbor ?f1 ?f2 - fuel)**: Represents a relationship between two fuel quantities, where (?f2) is greater than (?f1).\n- **(in ?c - cargo ?v - vehicle)**: Indicates that cargo (?c) is loaded in a vehicle (?v).\n- **(has-space ?v - vehicle ?s - space)**: Indicates that a vehicle (?v) has a certain amount of space (?s) available.\n- **(space-neighbor ?s1 ?s2 - space)**: Represents a relationship between two space quantities, where ?s2 is directly after ?s1.\n- **(not-equal ?l1 ?l2 - location)**: A predicate to ensure two locations are different.\n\n### Actions\n- **move <?v> <?l1> <?l2> <?f1> <?f2>**: Moves a vehicle (?v) from one location (?l1) to another (?l2) using fuel.  \n\n- **load <?c> <?v> <?l> <?s1> <?s2>**: Loads cargo (?c) into a vehicle (?v) at a location (?l), consuming a certain amount of space (?s1) and updating it to a new space quantity (?s2).  \n\n- **unload <?c> <?v> <?l> <?s1> <?s2>**:  Unloads cargo from a vehicle at a specified location, adjusting the space in the vehicle.  \n\n- **donate <?l1> <?l2> <?f11> <?f12> <?f21> <?f22>**: Transfers fuel from one location (?l1) to another <?l2>.",
        "pddl_domain_processed": "(define (domain mprime-strips)\n   (:requirements :typing)\n   (:types location space fuel locatable - object\n           vehicle cargo - locatable)\n   (:predicates\n       (at ?o - locatable ?l - location)\n       (conn ?l1 ?l2 - location)\n       (has-fuel ?l - location ?f - fuel)\n       (fuel-neighbor ?f1 ?f2 - fuel)\n       (in ?c - cargo ?v - vehicle)\n       (has-space ?v - vehicle ?s - space)\n       (space-neighbor ?s1 ?s2 - space)\n       (not-equal ?l1 ?l2 - location)\n\n)\n\n   (:action move\n       :parameters (?v - vehicle ?l1 ?l2 - location ?f1 ?f2 - fuel)\n       :precondition (and (at ?v ?l1)\n                          (conn ?l1 ?l2)\n                          (has-fuel ?l1 ?f1)\n                          (fuel-neighbor ?f2 ?f1))\n       :effect (and (not (at ?v ?l1))\n                    (at ?v ?l2)\n                    (not (has-fuel ?l1 ?f1))\n                    (has-fuel ?l1 ?f2)))\n\n   (:action load\n       :parameters (?c - cargo ?v - vehicle ?l - location ?s1 ?s2 - space)\n       :precondition (and (at ?c ?l)\n                          (at ?v ?l)\n                          (has-space ?v ?s1)\n\t\t\t  (space-neighbor ?s2 ?s1))\n       :effect (and (not (at ?c ?l))\n                    (in ?c ?v)\n                    (not (has-space ?v ?s1))\n                    (has-space ?v ?s2)))\n\n   (:action unload\n       :parameters (?c - cargo ?v - vehicle ?l - location ?s1 ?s2 - space)\n       :precondition (and (in ?c ?v)\n                          (at ?v ?l)\n\t\t\t  (has-space ?v ?s1)\n                          (space-neighbor ?s1 ?s2))\n       :effect (and (not (in ?c ?v))\n                    (at ?c ?l)\n                    (not (has-space ?v ?s1))\n                    (has-space ?v ?s2)))\n\n   (:action donate\n      :parameters (?l1 ?l2 - location ?f11 ?f12 ?f21 ?f22 - fuel)\n      :precondition (and (not-equal ?l1 ?l2)\n                         (has-fuel ?l1 ?f11)\n                         (fuel-neighbor ?f12 ?f11)\n                         (has-fuel ?l2 ?f21)\n                         (fuel-neighbor ?f21 ?f22))\n      :effect (and (not (has-fuel ?l1 ?f11))\n                   (has-fuel ?l1 ?f12)\n                   (not (has-fuel ?l2 ?f21))\n                   (has-fuel ?l2 ?f22)))\n\n)\n"
    },
    {
        "file_name": "driverlog",
        "pddl_domain": "(define (domain driverlog)\n  (:requirements :typing) \n  (:types         location locatable - object\n\t\tdriver truck obj - locatable\n  \n  )\n  (:predicates \n\t\t(at ?obj - locatable ?loc - location)\n\t\t(in ?obj1 - obj ?obj - truck)\n\t\t(driving ?d - driver ?v - truck)\n\t\t(link ?x ?y - location) (path ?x ?y - location)\n\t\t(empty ?v - truck)\n)\n\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action BOARD-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?driver ?loc) (empty ?truck))\n  :effect\n   (and (not (at ?driver ?loc)) (driving ?driver ?truck) (not (empty ?truck))))\n\n(:action DISEMBARK-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (driving ?driver ?truck))\n  :effect\n   (and (not (driving ?driver ?truck)) (at ?driver ?loc) (empty ?truck)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck - truck\n    ?loc-from - location\n    ?loc-to - location\n    ?driver - driver)\n  :precondition\n   (and (at ?truck ?loc-from)\n   (driving ?driver ?truck) (link ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action WALK\n  :parameters\n   (?driver - driver\n    ?loc-from - location\n    ?loc-to - location)\n  :precondition\n   (and (at ?driver ?loc-from) (path ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?driver ?loc-from)) (at ?driver ?loc-to)))\n\n \n)\n",
        "batch_id": 2,
        "id": 61,
        "tokens": 5790,
        "corrected_description": "### General\nThe domain models a logistics scenario where drivers can load objects into trucks, drive trucks between locations, and unload objects. Drivers can also move between locations independently of the trucks. The goal is to efficiently manage the transportation of objects and the movement of drivers to achieve specific logistical objectives.\n\n### Types\n- **location**: Represents geographical locations.\n- **locatable**: A superclass for all entities that can be located somewhere, including drivers, trucks, and objects.\n- **driver**: Represents individuals capable of driving trucks and carrying objects.\n- **truck**: Represents vehicles used for transporting objects.\n- **obj**: Represents objects that need to be transported.\n\n### Predicates\n- **(at ?obj - locatable ?loc - location)**: Indicates that a locatable entity (?obj) is at a specific location (?loc).\n- **(in ?obj1 - obj ?obj - truck)**: Indicates that an object (?obj1) is inside a truck (?obj).\n- **(driving ?d - driver ?v - truck)**: Indicates that a driver (?d) is driving a truck (?v).\n- **(link ?x ?y - location)**: Represents a direct route between two locations (?x and ?y).\n- **(path ?x ?y - location)**: Represents a walkable path between two locations (?x and ?y).\n- **(empty ?v - truck)**: Indicates that a truck (?v) is empty.\n\n### Actions\n- **LOAD-TRUCK <?obj> <?truck> <?loc>**: Loads an object into a truck at a location.  \n  \n- **UNLOAD-TRUCK <?obj> <?truck> <?loc>**: Unloads an object from a truck at a location.  \n  \n- **BOARD-TRUCK <?driver> <?truck> <?loc>**: A driver boards a truck at a location, preparing to drive it.  \n  \n- **DISEMBARK-TRUCK <?driver> <?truck> <?loc>**: A driver disembarks from a truck at a location.  \n  \n- **DRIVE-TRUCK <?truck> <?loc-from> <?loc-to> <?driver>**: Moves a truck from one location to another under the control of a driver.  \n  \n- **WALK <?driver> <?loc-from> <?loc-to>**: A driver walks from one location to another.",
        "pddl_domain_processed": "(define (domain driverlog)\n  (:requirements :typing) \n  (:types         location locatable - object\n\t\tdriver truck obj - locatable\n\n  )\n  (:predicates \n\t\t(at ?obj - locatable ?loc - location)\n\t\t(in ?obj1 - obj ?obj - truck)\n\t\t(driving ?d - driver ?v - truck)\n\t\t(link ?x ?y - location) (path ?x ?y - location)\n\t\t(empty ?v - truck)\n)\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj - obj\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action BOARD-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (at ?driver ?loc) (empty ?truck))\n  :effect\n   (and (not (at ?driver ?loc)) (driving ?driver ?truck) (not (empty ?truck))))\n\n(:action DISEMBARK-TRUCK\n  :parameters\n   (?driver - driver\n    ?truck - truck\n    ?loc - location)\n  :precondition\n   (and (at ?truck ?loc) (driving ?driver ?truck))\n  :effect\n   (and (not (driving ?driver ?truck)) (at ?driver ?loc) (empty ?truck)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck - truck\n    ?loc-from - location\n    ?loc-to - location\n    ?driver - driver)\n  :precondition\n   (and (at ?truck ?loc-from)\n   (driving ?driver ?truck) (link ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action WALK\n  :parameters\n   (?driver - driver\n    ?loc-from - location\n    ?loc-to - location)\n  :precondition\n   (and (at ?driver ?loc-from) (path ?loc-from ?loc-to))\n  :effect\n   (and (not (at ?driver ?loc-from)) (at ?driver ?loc-to)))\n\n)\n"
    },
    {
        "file_name": "schedule",
        "pddl_domain": ";; Schedule World\n;;\n\n(define (domain schedule)\n  (:requirements :adl :typing)\n  (:types temperature-type\n\t  ashape\n\t  surface\n\t  machine\n\t  part\n\t  colour\n\t  width\n\t  anorient)\n\n  (:constants cold hot - temperature-type\n\t      cylindrical - ashape \n\t      polisher roller lathe grinder punch drill-press\n\t      spray-painter immersion-painter - machine\n              polished rough smooth - surface)\n\n  (:predicates (temperature ?obj - part ?temp - temperature-type)\n\t       (busy ?machine - machine)\n\t       (scheduled ?obj - part)\n\t       (objscheduled)\n\t       (surface-condition ?obj - part ?surface-cond - surface)\n\t       (shape ?obj - part ?shape - ashape)\n\t       (painted ?obj - part ?colour - colour)\n\t       (has-hole ?obj - part ?width - width ?orientation - anorient)\n\t       (has-bit ?machine - machine ?width - width)\n\t       (can-orient ?machine - machine ?orientation - anorient)\n\t       (has-paint ?machine - machine ?colour - colour))\n\n  (:action do-polish\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy polisher))\n\t\t\t      (not (scheduled ?x))\n\t\t\t      (temperature ?x cold))\n\t   :effect (and (busy polisher)\n\t\t\t(scheduled ?x)\n\t\t\t(surface-condition ?x polished)\n\t\t\t(when (not (objscheduled))\n\t\t\t  (objscheduled))\n\t\t\t(forall (?oldsurface - surface)\n\t\t\t\t(when (and (surface-condition ?x ?oldsurface)\n                                           (not (= ?oldsurface polished)))\n\t\t\t\t  (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-roll\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy roller))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy roller)\n\t\t    (scheduled ?x)\n\t\t    (temperature ?x hot)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))\n\t\t    (forall (?oldwidth - width ?oldorient - anorient)\n\t\t\t    (when (has-hole ?x ?oldwidth ?oldorient)\n\t\t\t      (not (has-hole ?x ?oldwidth ?oldorient))))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldtemp - temperature-type)\n\t\t\t    (when (and (temperature ?x ?oldtemp)\n                                       (not (= ?oldtemp hot)))\n\t\t\t      (not (temperature ?x ?oldtemp))))))\n\n  (:action do-lathe\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy lathe))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and \n\t\t    (busy lathe)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x rough)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t    (not (painted ?x ?oldpaint))))))\n\n  (:action do-grind\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy grinder))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy GRINDER)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x smooth)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface smooth)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-punch\n\t   :parameters (?x - part ?width - width  ?orient - anorient)  \n\t   :precondition (and\n\t\t\t  (has-bit punch ?width)\n\t\t\t  (can-orient punch ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy punch))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy punch)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (surface-condition ?x rough)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface) \n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-drill-press\n\t   :parameters (?x - part ?width - width ?orient - anorient)\n\t   :precondition (and\n\t\t\t  (has-bit drill-press ?width)\n\t\t\t  (can-orient drill-press ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy drill-press))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy drill-press)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))))\n\n  (:action do-spray-paint\n\t   :parameters (?x - part ?newpaint - colour) \n\t   :precondition (and\n\t\t\t  (has-paint spray-painter ?newpaint)\n\t\t\t  (not (busy spray-painter))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (temperature ?x COLD))\n\t   :effect (and\n\t\t    (busy spray-painter)\n\t\t    (scheduled ?x)\n\t\t    (painted ?x ?newpaint)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n\t\t\t      (not (painted ?x ?oldpaint))))))\n  \n  (:action do-immersion-paint     \n           :parameters (?x - part ?newpaint - colour) \n           :precondition (and\n                          (has-paint immersion-painter ?newpaint)\n                          (not (busy immersion-painter))\n                          (not (scheduled ?x)))\n           :effect (and\n                    (busy immersion-painter)\n                    (scheduled ?x)\n                    (painted ?x ?newpaint)\n                    (when (not (objscheduled))\n                      (objscheduled))\n                    (forall (?oldpaint - colour)\n                            (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n                              (not (painted ?x ?oldpaint))))))\n  \n  (:action do-time-step\n           :parameters ()\n           :precondition (objscheduled)\n           :effect (and\n                    (forall (?x - part)\n                            (when (scheduled ?x)\n                              (not (scheduled ?x))))\n                    (forall (?m - machine)\n                            (when (busy ?m)\n                              (not (busy ?m)))))))\n\n\n\n\n\n\n",
        "batch_id": 2,
        "id": 63,
        "tokens": 6990,
        "corrected_description": "### General\nThis domain is designed for scheduling tasks in a manufacturing environment. It involves managing parts, machines, and operations such as polishing, rolling, lathe work, grinding, punching, drilling, and painting. The goal is to efficiently schedule various operations on parts while managing the state of machines (busy or not) and ensuring parts go through the necessary processes to meet their final specifications.\n\n### Types\n- **temperature-type**: Represents the temperature states of parts, such as cold or hot.\n- **ashape**: Represents the shapes of parts, such as cylindrical.\n- **surface**: Represents the surface conditions of parts, such as polished, rough, or smooth.\n- **machine**: Represents different machines used in the manufacturing process, such as polishers, rollers, lathes, grinders, punch presses, drill presses, spray painters, and immersion painters.\n- **part**: Represents the items being manufactured.\n- **colour**: Represents the colors that parts can be painted.\n- **width**: Represents the width of holes that can be punched or drilled into parts.\n- **anorient**: Represents the orientation of holes in parts.\n\n### Predicates\n- **(temperature ?obj - part ?temp - temperature-type)**: Indicates the temperature state of a part.\n- **(busy ?machine - machine)**: Indicates whether a machine is currently busy.\n- **(scheduled ?obj - part)**: Indicates whether a part has been scheduled for an operation.\n- **(objscheduled)**: Indicates that at least one part has been scheduled for an operation.\n- **(surface-condition ?obj - part ?surface-cond - surface)**: Indicates the surface condition of a part.\n- **(shape ?obj - part ?shape - ashape)**: Indicates the shape of a part.\n- **(painted ?obj - part ?colour - colour)**: Indicates the color a part has been painted.\n- **(has-hole ?obj - part ?width - width ?orientation - anorient)**: Indicates that a part has a hole of a certain width and orientation.\n- **(has-bit ?machine - machine ?width - width)**: Indicates that a machine has a bit of a certain width for operations like punching or drilling.\n- **(can-orient ?machine - machine ?orientation - anorient)**: Indicates that a machine can orient its operations in a certain way.\n- **(has-paint ?machine - machine ?colour - colour)**: Indicates that a machine has paint of a certain color for painting operations.\n\n### Actions\n- **do-polish <?x>**: Polishes a part using the polisher machine if it is not busy, the part is cold, and not already scheduled.  \n\n- **do-roll <?x>**: Rolls a part to make it cylindrical and hot using the roller machine if it is not busy and the part is not already scheduled.  \n\n- **do-lathe <?x>**: Performs lathe work on a part to make it cylindrical and rough using the lathe machine if it is not busy and the part is not already scheduled.  \n\n- **do-grind <?x>**: Grinds a part to make its surface smooth using the grinder machine if it is not busy and the part is not already scheduled.  \n\n- **do-punch <?x> <?width> <?orient>**: Punches a hole in a part using the punch machine if it has the correct bit and orientation, the part is cold, not busy, not already scheduled, and does not already have a hole of the specified width and orientation.  \n\n- **do-drill-press <?x> <?width> <?orient>**: Drills a hole in a part using the drill press if it has the correct bit and orientation, the part is cold, not busy, not already scheduled, and does not already have a hole of the specified width and orientation.  \n\n- **do-spray-paint <?x> <?newpaint>**: Spray paints a part with a new color using the spray painter if it has the paint, is not busy, the part is cold, and not already scheduled.  \n\n- **do-immersion-paint <?x> <?newpaint>**: Paints a part with a new color using the immersion painter if it has the paint, is not busy, and the part is not already scheduled.  \n\n- **do-time-step**: Advances time, resetting the scheduled status of parts and the busy status of machines if at least one part has been scheduled.",
        "pddl_domain_processed": "\n\n(define (domain schedule)\n  (:requirements :adl :typing)\n  (:types temperature-type\n\t  ashape\n\t  surface\n\t  machine\n\t  part\n\t  colour\n\t  width\n\t  anorient)\n\n  (:constants cold hot - temperature-type\n\t      cylindrical - ashape \n\t      polisher roller lathe grinder punch drill-press\n\t      spray-painter immersion-painter - machine\n              polished rough smooth - surface)\n\n  (:predicates (temperature ?obj - part ?temp - temperature-type)\n\t       (busy ?machine - machine)\n\t       (scheduled ?obj - part)\n\t       (objscheduled)\n\t       (surface-condition ?obj - part ?surface-cond - surface)\n\t       (shape ?obj - part ?shape - ashape)\n\t       (painted ?obj - part ?colour - colour)\n\t       (has-hole ?obj - part ?width - width ?orientation - anorient)\n\t       (has-bit ?machine - machine ?width - width)\n\t       (can-orient ?machine - machine ?orientation - anorient)\n\t       (has-paint ?machine - machine ?colour - colour))\n\n  (:action do-polish\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy polisher))\n\t\t\t      (not (scheduled ?x))\n\t\t\t      (temperature ?x cold))\n\t   :effect (and (busy polisher)\n\t\t\t(scheduled ?x)\n\t\t\t(surface-condition ?x polished)\n\t\t\t(when (not (objscheduled))\n\t\t\t  (objscheduled))\n\t\t\t(forall (?oldsurface - surface)\n\t\t\t\t(when (and (surface-condition ?x ?oldsurface)\n                                           (not (= ?oldsurface polished)))\n\t\t\t\t  (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-roll\n\t   :parameters (?x - part)\n\t   :precondition (and (not (busy roller))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy roller)\n\t\t    (scheduled ?x)\n\t\t    (temperature ?x hot)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))\n\t\t    (forall (?oldwidth - width ?oldorient - anorient)\n\t\t\t    (when (has-hole ?x ?oldwidth ?oldorient)\n\t\t\t      (not (has-hole ?x ?oldwidth ?oldorient))))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldtemp - temperature-type)\n\t\t\t    (when (and (temperature ?x ?oldtemp)\n                                       (not (= ?oldtemp hot)))\n\t\t\t      (not (temperature ?x ?oldtemp))))))\n\n  (:action do-lathe\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy lathe))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and \n\t\t    (busy lathe)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x rough)\n\t\t    (shape ?x cylindrical)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldshape - ashape)\n\t\t\t    (when (and (shape ?x ?oldshape)\n                                       (not (= ?oldshape cylindrical)))\n\t\t\t      (not (shape ?x ?oldshape))))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t    (not (painted ?x ?oldpaint))))))\n\n  (:action do-grind\n\t   :parameters (?x - part) \n\t   :precondition (and (not (busy grinder))\n\t\t\t      (not (scheduled ?x)))\n\t   :effect (and\n\t\t    (busy GRINDER)\n\t\t    (scheduled ?x)\n\t\t    (surface-condition ?x smooth)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface smooth)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (painted ?x ?oldpaint)\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-punch\n\t   :parameters (?x - part ?width - width  ?orient - anorient)  \n\t   :precondition (and\n\t\t\t  (has-bit punch ?width)\n\t\t\t  (can-orient punch ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy punch))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy punch)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (surface-condition ?x rough)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface) \n\t\t\t    (when (and (surface-condition ?x ?oldsurface)\n                                       (not (= ?oldsurface rough)))\n\t\t\t      (not (surface-condition ?x ?oldsurface))))))\n\n  (:action do-drill-press\n\t   :parameters (?x - part ?width - width ?orient - anorient)\n\t   :precondition (and\n\t\t\t  (has-bit drill-press ?width)\n\t\t\t  (can-orient drill-press ?orient)\n\t\t\t  (temperature ?x cold)\n\t\t\t  (not (busy drill-press))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (not (has-hole ?x ?width ?orient)))\n\t   :effect (and\n\t\t    (busy drill-press)\n\t\t    (scheduled ?x)\n\t\t    (has-hole ?x ?width ?orient)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))))\n\n  (:action do-spray-paint\n\t   :parameters (?x - part ?newpaint - colour) \n\t   :precondition (and\n\t\t\t  (has-paint spray-painter ?newpaint)\n\t\t\t  (not (busy spray-painter))\n\t\t\t  (not (scheduled ?x))\n\t\t\t  (temperature ?x COLD))\n\t   :effect (and\n\t\t    (busy spray-painter)\n\t\t    (scheduled ?x)\n\t\t    (painted ?x ?newpaint)\n\t\t    (when (not (objscheduled))\n\t\t      (objscheduled))\n\t\t    (forall (?oldsurface - surface)\n\t\t\t    (when (surface-condition ?x ?oldsurface)\n\t\t\t      (not (surface-condition ?x ?oldsurface))))\n\t\t    (forall (?oldpaint - colour)\n\t\t\t    (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n\t\t\t      (not (painted ?x ?oldpaint))))))\n\n  (:action do-immersion-paint     \n           :parameters (?x - part ?newpaint - colour) \n           :precondition (and\n                          (has-paint immersion-painter ?newpaint)\n                          (not (busy immersion-painter))\n                          (not (scheduled ?x)))\n           :effect (and\n                    (busy immersion-painter)\n                    (scheduled ?x)\n                    (painted ?x ?newpaint)\n                    (when (not (objscheduled))\n                      (objscheduled))\n                    (forall (?oldpaint - colour)\n                            (when (and (painted ?x ?oldpaint)\n                                       (not (= ?oldpaint ?newpaint)))\n                              (not (painted ?x ?oldpaint))))))\n\n  (:action do-time-step\n           :parameters ()\n           :precondition (objscheduled)\n           :effect (and\n                    (forall (?x - part)\n                            (when (scheduled ?x)\n                              (not (scheduled ?x))))\n                    (forall (?m - machine)\n                            (when (busy ?m)\n                              (not (busy ?m)))))))\n\n"
    },
    {
        "file_name": "freecell",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain freecell)\n  (:requirements :strips :typing)\n  (:types card colnum cellnum num suit)\n  (:predicates (on ?c1 - card ?c2 - card)\n\t       (incell ?c - card)\n\t       (clear ?c - card)\n\t       (cellspace ?n - cellnum)\n\t       (colspace ?n - colnum)\n\t       (home ?c - card)\n\t       (bottomcol ?c - card)\n\t       (canstack ?c1 - card ?c2 - card)\n\t       (hassuit ?c - card ?s - suit)\n\t       (value ?c - card ?v - num)\n\t       (successor ?n1 - num ?n0 - num)\n\t       (colsuccessor ?n1 - colnum ?n0 - colnum)\n\t       (cellsuccessor ?n1 - cellnum ?n0 - cellnum)\n )\n\n;;; Move card between columns. Two versions dependent on whether or\n;;; not we generate a new stack.\n\n  (:action move\n\t   :parameters (?card ?oldcard ?newcard - card)\n\t   :precondition (and (clear ?card)\n\t\t\t      (clear ?newcard)\n\t\t\t      (canstack ?card ?newcard)\n\t\t\t      (on ?card ?oldcard))\n\t   :effect (and\n\t\t    (on ?card ?newcard)\n\t\t    (clear ?oldcard)\n\t\t    (not (on ?card ?oldcard))\n\t\t    (not (clear ?newcard))))\n\n  (:action move-b\n\t   :parameters (?card ?newcard - card ?cols ?ncols - colnum)\n\t   :precondition (and (clear ?card)\n\t\t\t      (bottomcol ?card)\n\t\t\t      (clear ?newcard)\n\t\t\t      (canstack ?card ?newcard)\n\t\t\t      (colspace ?cols)\n\t\t\t      (colsuccessor ?ncols ?cols))\n\t   :effect (and (on ?card ?newcard)\n\t\t\t(colspace ?ncols)\n\t\t\t(not (bottomcol ?card))\n\t\t\t(not (clear ?newcard))\n\t\t\t(not (colspace ?cols))))\n\n;; Send a card to a freecell. Two versions dependent on whether or not\n;; we generate a new stack.\n\n  (:action sendtofree\n\t   :parameters (?card ?oldcard - card ?cells ?ncells - cellnum)\n\t   :precondition (and\n\t\t\t  (clear ?card)\n\t\t\t  (on ?card ?oldcard)\n\t\t\t  (cellspace ?cells)\n\t\t\t  (cellsuccessor ?ncells ?cells))\n\t   :effect (and\n\t\t    (incell ?card)\n\t\t    (clear ?oldcard)\n\t\t    (cellspace ?ncells)\n\t\t    (not (on ?card ?oldcard))\n\t\t    (not (clear ?card))\n\t\t    (not (cellspace ?cells))))\n\n  (:action sendtofree-b\n\t   :parameters (?card - card ?cells ?ncells - cellnum ?cols ?ncols - colnum)\n\t   :precondition (and (clear ?card)\n\t\t\t      (bottomcol ?card)\n\t\t\t      (cellspace ?cells)\n\t\t\t      (cellsuccessor ?ncells ?cells)\n\t\t\t      (colspace ?cols)\n\t\t\t      (colsuccessor ?ncols ?cols))\n\t   :effect (and\n\t\t    (incell ?card)\n\t\t    (colspace ?ncols)\n\t\t    (cellspace ?ncells)\n\t\t    (not (bottomcol ?card))\n\t\t    (not (clear ?card))\n\t\t    (not (colspace ?cols))\n\t\t    (not (cellspace ?cells))))\n\n;; Send a card a new column\n\n(:action sendtonewcol\n\t :parameters (?card ?oldcard - card ?cols ?ncols - colnum)\n\t :precondition (and\n\t\t\t(clear ?card)\n\t\t\t(colspace ?cols)\n\t\t\t(colsuccessor ?ncols ?cols)\n\t\t\t(on ?card ?oldcard))\n\t :effect (and\n\t\t  (bottomcol ?card)\n\t\t  (clear ?oldcard)\n\t\t  (colspace ?ncols)\n\t\t  (not (on ?card ?oldcard))\n\t\t  (not (colspace ?cols))))\n\n;;Send a card home\n\n(:action sendtohome\n\t :parameters (?card ?oldcard - card ?suitname - suit ?vcard - num\n\t\t\t    ?homecard - card ?vhomecard - num)\n\t :precondition (and\n\t\t\t(clear ?card)\n\t\t\t(on ?card ?oldcard)\n\t\t\t(home ?homecard)\n\t\t\t(hassuit ?card ?suitname)\n\t\t\t(hassuit ?homecard ?suitname)\n\t\t\t(value ?card ?vcard)\n\t\t\t(value ?homecard ?vhomecard)\n\t\t\t(successor ?vcard ?vhomecard))\n\t :effect (and (home ?card)\n\t\t      (clear ?oldcard)\n\t\t      (not (on ?card ?oldcard))\n                      (not (home ?homecard))\n\t\t      (not (clear ?card))))\n\n(:action sendtohome-b\n\t :parameters (?card - card ?suitname - suit  ?vcard - num\n\t\t\t    ?homecard - card\n\t\t\t    ?vhomecard - num\n\t\t\t    ?cols ?ncols - colnum)\n\t :precondition (and (clear ?card)\n\t\t\t    (bottomcol ?card)\n\t\t\t    (home ?homecard)\n\t\t\t    (hassuit ?card ?suitname)\n\t\t\t    (hassuit ?homecard ?suitname)\n\t\t\t    (value ?card ?vcard)\n\t\t\t    (value ?homecard ?vhomecard)\n\t\t\t    (successor ?vcard ?vhomecard)\n\t\t\t    (colspace ?cols)\n\t\t\t    (colsuccessor ?ncols ?cols))\n\t :effect (and (home ?card)\n\t\t      (colspace ?ncols)\n\t\t      (not (home ?homecard))\n\t\t      (not (clear ?card))\n\t\t      (not (bottomcol ?card))\n\t\t      (not (colspace ?cols))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Move cards in free cell\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(:action homefromfreecell\n\t :parameters (?card - card ?suitname - suit ?vcard - num\n\t\t\t    ?homecard - card ?vhomecard - num\n\t\t\t    ?cells ?ncells - cellnum)\n    ;;Send a card home from a free cell.\n\t :precondition (and\n\t\t\t(incell ?card)\n\t\t\t(home ?homecard)\n\t\t\t(hassuit ?card ?suitname)\n\t\t\t(hassuit ?homecard ?suitname)\n\t\t\t(value ?card ?vcard)\n\t\t\t(value ?homecard ?vhomecard)\n\t\t\t(successor ?vcard ?vhomecard)\n\t\t\t(cellspace ?cells)\n\t\t\t(cellsuccessor ?ncells ?cells))\n\t :effect (and\n\t\t  (home ?card)\n\t\t  (cellspace ?ncells)\n\t\t  (not (incell ?card))\n\t\t  (not (cellspace ?cells))\n\t\t  (not (home ?homecard))))\n\n(:action colfromfreecell\n\t :parameters (?card ?newcard -  card ?cells ?ncells - cellnum)\n\t :precondition (and  (incell ?card)\n\t\t\t     (clear ?newcard)\n\t\t\t     (canstack ?card ?newcard)\n\t\t\t     (cellspace ?cells)\n\t\t\t     (cellsuccessor ?ncells ?cells))\n\t :effect (and (cellspace ?ncells)\n\t\t      (clear ?card)\n\t\t      (on ?card ?newcard)\n\t\t      (not (incell ?card))\n\t\t      (not (cellspace ?cells))\n\t\t      (not (clear ?newcard))))\n\n(:action newcolfromfreecell\n\t :parameters (?card - card ?cols ?ncols - colnum ?cells ?ncells - cellnum)\n\t :precondition (and (incell ?card)\n\t\t\t    (colspace ?cols)\n\t\t\t    (cellspace ?cells)\n\t\t\t    (colsuccessor ?ncols ?cols)\n\t\t\t    (cellsuccessor ?ncells ?cells))\n\t :effect (and (bottomcol ?card)\n\t\t      (clear ?card)\n\t\t      (colspace ?ncols)\n\t\t      (cellspace ?ncells)\n\t\t      (not (incell ?card))\n\t\t      (not (colspace ?cols))\n\t\t      (not (cellspace ?cells)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n",
        "batch_id": 2,
        "id": 64,
        "tokens": 6883,
        "corrected_description": "### General\nThe FreeCell domain involves manipulating a deck of cards distributed across different columns, free cells, and home cells. The goal is to organize all cards into the home cells according to their suits and in ascending order. The domain allows for moving cards between columns, sending cards to free cells, moving cards from free cells to columns or home cells, and directly sending cards to their home cells.\n\n### Types\n- **card**: Represents individual cards in the deck.\n- **colnum**: Represents column numbers.\n- **cellnum**: Represents free cell numbers.\n- **num**: Represents the numerical values of cards.\n- **suit**: Represents the suits of cards (e.g., hearts, diamonds, clubs, spades).\n\n### Predicates\n- **(on ?c1 ?c2)**: Indicates that card ?c1 is on top of card ?c2.\n- **(incell ?c)**: Indicates that card ?c is in a free cell.\n- **(clear ?c)**: Indicates that there are no cards on top of card ?c.\n- **(cellspace ?n)**: Indicates that free cell ?n is available.\n- **(colspace ?n)**: Indicates that column ?n has space available.\n- **(home ?c)**: Indicates that card ?c is in its home cell.\n- **(bottomcol ?c)**: Indicates that card ?c is at the bottom of a column.\n- **(canstack ?c1 ?c2)**: Indicates that card ?c1 can be placed on top of card ?c2 according to the game rules.\n- **(hassuit ?c ?s)**: Indicates that card ?c has suit ?s.\n- **(value ?c ?v)**: Indicates the value of card ?c is ?v.\n- **(successor ?n1 ?n0)**: Indicates that ?n1 is the successor of ?n0 in numerical value.\n- **(colsuccessor ?n1 ?n0)**: Indicates that ?n1 is the successor of ?n0 in column numbering.\n- **(cellsuccessor ?n1 ?n0)**: Indicates that ?n1 is the successor of ?n0 in free cell numbering.\n\n### Actions\n- **move <?card> <?oldcard> <?newcard>**: Moves a card to a new column on top of another card.  \n\n- **move-b <?card> <?newcard> <?cols> <?ncols>**: Similar to move, but also updates the column space availability.  \n\n- **sendtofree <?card> <?oldcard> <?cells> <?ncells>**: Sends a card to a free cell, updating the free cell and column statuses accordingly.  \n\n- **sendtofree-b <?card> <?cells> <?ncells> <?cols> <?ncols>**: Similar to sendtofree, but for bottom column cards, updating both column and cell space statuses.  \n\n- **sendtonewcol <?card> <?oldcard> <?cols> <?ncols>**: Moves a card to a new column, making it the bottom card of that column.  \n\n- **sendtohome <?card> <?oldcard> <?suitname> <?vcard> <?homecard> <?vhomecard>**: Sends a card directly to its home cell from a column.  \n\n- **sendtohome-b <?card> <?suitname> <?vcard> <?homecard> <?vhomecard> <?cols> <?ncols>**: Similar to sendtohome, but also updates the column space availability.  \n\n- **homefromfreecell <?card> <?suitname> <?vcard> <?homecard> <?vhomecard> <?cells> <?ncells>**: Moves a card from a free cell directly to its home cell.  \n\n- **colfromfreecell <?card> <?newcard> <?cells> <?ncells>**: Moves a card from a free cell to a column.  \n\n- **newcolfromfreecell <?card> <?cols> <?ncols> <?cells> <?ncells>**: Moves a card from a free cell to a new column, making it the bottom card of that column.",
        "pddl_domain_processed": "\n\n(define (domain freecell)\n  (:requirements :strips :typing)\n  (:types card colnum cellnum num suit)\n  (:predicates (on ?c1 - card ?c2 - card)\n\t       (incell ?c - card)\n\t       (clear ?c - card)\n\t       (cellspace ?n - cellnum)\n\t       (colspace ?n - colnum)\n\t       (home ?c - card)\n\t       (bottomcol ?c - card)\n\t       (canstack ?c1 - card ?c2 - card)\n\t       (hassuit ?c - card ?s - suit)\n\t       (value ?c - card ?v - num)\n\t       (successor ?n1 - num ?n0 - num)\n\t       (colsuccessor ?n1 - colnum ?n0 - colnum)\n\t       (cellsuccessor ?n1 - cellnum ?n0 - cellnum)\n )\n\n  (:action move\n\t   :parameters (?card ?oldcard ?newcard - card)\n\t   :precondition (and (clear ?card)\n\t\t\t      (clear ?newcard)\n\t\t\t      (canstack ?card ?newcard)\n\t\t\t      (on ?card ?oldcard))\n\t   :effect (and\n\t\t    (on ?card ?newcard)\n\t\t    (clear ?oldcard)\n\t\t    (not (on ?card ?oldcard))\n\t\t    (not (clear ?newcard))))\n\n  (:action move-b\n\t   :parameters (?card ?newcard - card ?cols ?ncols - colnum)\n\t   :precondition (and (clear ?card)\n\t\t\t      (bottomcol ?card)\n\t\t\t      (clear ?newcard)\n\t\t\t      (canstack ?card ?newcard)\n\t\t\t      (colspace ?cols)\n\t\t\t      (colsuccessor ?ncols ?cols))\n\t   :effect (and (on ?card ?newcard)\n\t\t\t(colspace ?ncols)\n\t\t\t(not (bottomcol ?card))\n\t\t\t(not (clear ?newcard))\n\t\t\t(not (colspace ?cols))))\n\n  (:action sendtofree\n\t   :parameters (?card ?oldcard - card ?cells ?ncells - cellnum)\n\t   :precondition (and\n\t\t\t  (clear ?card)\n\t\t\t  (on ?card ?oldcard)\n\t\t\t  (cellspace ?cells)\n\t\t\t  (cellsuccessor ?ncells ?cells))\n\t   :effect (and\n\t\t    (incell ?card)\n\t\t    (clear ?oldcard)\n\t\t    (cellspace ?ncells)\n\t\t    (not (on ?card ?oldcard))\n\t\t    (not (clear ?card))\n\t\t    (not (cellspace ?cells))))\n\n  (:action sendtofree-b\n\t   :parameters (?card - card ?cells ?ncells - cellnum ?cols ?ncols - colnum)\n\t   :precondition (and (clear ?card)\n\t\t\t      (bottomcol ?card)\n\t\t\t      (cellspace ?cells)\n\t\t\t      (cellsuccessor ?ncells ?cells)\n\t\t\t      (colspace ?cols)\n\t\t\t      (colsuccessor ?ncols ?cols))\n\t   :effect (and\n\t\t    (incell ?card)\n\t\t    (colspace ?ncols)\n\t\t    (cellspace ?ncells)\n\t\t    (not (bottomcol ?card))\n\t\t    (not (clear ?card))\n\t\t    (not (colspace ?cols))\n\t\t    (not (cellspace ?cells))))\n\n(:action sendtonewcol\n\t :parameters (?card ?oldcard - card ?cols ?ncols - colnum)\n\t :precondition (and\n\t\t\t(clear ?card)\n\t\t\t(colspace ?cols)\n\t\t\t(colsuccessor ?ncols ?cols)\n\t\t\t(on ?card ?oldcard))\n\t :effect (and\n\t\t  (bottomcol ?card)\n\t\t  (clear ?oldcard)\n\t\t  (colspace ?ncols)\n\t\t  (not (on ?card ?oldcard))\n\t\t  (not (colspace ?cols))))\n\n(:action sendtohome\n\t :parameters (?card ?oldcard - card ?suitname - suit ?vcard - num\n\t\t\t    ?homecard - card ?vhomecard - num)\n\t :precondition (and\n\t\t\t(clear ?card)\n\t\t\t(on ?card ?oldcard)\n\t\t\t(home ?homecard)\n\t\t\t(hassuit ?card ?suitname)\n\t\t\t(hassuit ?homecard ?suitname)\n\t\t\t(value ?card ?vcard)\n\t\t\t(value ?homecard ?vhomecard)\n\t\t\t(successor ?vcard ?vhomecard))\n\t :effect (and (home ?card)\n\t\t      (clear ?oldcard)\n\t\t      (not (on ?card ?oldcard))\n                      (not (home ?homecard))\n\t\t      (not (clear ?card))))\n\n(:action sendtohome-b\n\t :parameters (?card - card ?suitname - suit  ?vcard - num\n\t\t\t    ?homecard - card\n\t\t\t    ?vhomecard - num\n\t\t\t    ?cols ?ncols - colnum)\n\t :precondition (and (clear ?card)\n\t\t\t    (bottomcol ?card)\n\t\t\t    (home ?homecard)\n\t\t\t    (hassuit ?card ?suitname)\n\t\t\t    (hassuit ?homecard ?suitname)\n\t\t\t    (value ?card ?vcard)\n\t\t\t    (value ?homecard ?vhomecard)\n\t\t\t    (successor ?vcard ?vhomecard)\n\t\t\t    (colspace ?cols)\n\t\t\t    (colsuccessor ?ncols ?cols))\n\t :effect (and (home ?card)\n\t\t      (colspace ?ncols)\n\t\t      (not (home ?homecard))\n\t\t      (not (clear ?card))\n\t\t      (not (bottomcol ?card))\n\t\t      (not (colspace ?cols))))\n\n(:action homefromfreecell\n\t :parameters (?card - card ?suitname - suit ?vcard - num\n\t\t\t    ?homecard - card ?vhomecard - num\n\t\t\t    ?cells ?ncells - cellnum)\n\n\t :precondition (and\n\t\t\t(incell ?card)\n\t\t\t(home ?homecard)\n\t\t\t(hassuit ?card ?suitname)\n\t\t\t(hassuit ?homecard ?suitname)\n\t\t\t(value ?card ?vcard)\n\t\t\t(value ?homecard ?vhomecard)\n\t\t\t(successor ?vcard ?vhomecard)\n\t\t\t(cellspace ?cells)\n\t\t\t(cellsuccessor ?ncells ?cells))\n\t :effect (and\n\t\t  (home ?card)\n\t\t  (cellspace ?ncells)\n\t\t  (not (incell ?card))\n\t\t  (not (cellspace ?cells))\n\t\t  (not (home ?homecard))))\n\n(:action colfromfreecell\n\t :parameters (?card ?newcard -  card ?cells ?ncells - cellnum)\n\t :precondition (and  (incell ?card)\n\t\t\t     (clear ?newcard)\n\t\t\t     (canstack ?card ?newcard)\n\t\t\t     (cellspace ?cells)\n\t\t\t     (cellsuccessor ?ncells ?cells))\n\t :effect (and (cellspace ?ncells)\n\t\t      (clear ?card)\n\t\t      (on ?card ?newcard)\n\t\t      (not (incell ?card))\n\t\t      (not (cellspace ?cells))\n\t\t      (not (clear ?newcard))))\n\n(:action newcolfromfreecell\n\t :parameters (?card - card ?cols ?ncols - colnum ?cells ?ncells - cellnum)\n\t :precondition (and (incell ?card)\n\t\t\t    (colspace ?cols)\n\t\t\t    (cellspace ?cells)\n\t\t\t    (colsuccessor ?ncols ?cols)\n\t\t\t    (cellsuccessor ?ncells ?cells))\n\t :effect (and (bottomcol ?card)\n\t\t      (clear ?card)\n\t\t      (colspace ?ncols)\n\t\t      (cellspace ?ncells)\n\t\t      (not (incell ?card))\n\t\t      (not (colspace ?cols))\n\t\t      (not (cellspace ?cells)))))\n\n"
    },
    {
        "file_name": "visitall",
        "pddl_domain": ";; Visitall domain\n;; Created by Nir Lipovetzky \n\n; MIT License\n\n; Copyright (c) 2011 Nir Lipovetzky\n\n; Permission is hereby granted, free of charge, to any person obtaining a copy\n; of this software and associated documentation files (the \"Software\"), to deal\n; in the Software without restriction, including without limitation the rights\n; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n; copies of the Software, and to permit persons to whom the Software is\n; furnished to do so, subject to the following conditions:\n\n; The above copyright notice and this permission notice shall be included in all\n; copies or substantial portions of the Software.\n\n; THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n; SOFTWARE.\n\n(define (domain grid-visit-all)\n(:requirements :typing)\n(:types        place - object)\n(:predicates (connected ?x ?y - place)\n\t     (at-robot ?x - place)\n\t     (visited ?x - place)\n)\n\t\n(:action move\n:parameters (?curpos ?nextpos - place)\n:precondition (and (at-robot ?curpos) (connected ?curpos ?nextpos))\n:effect (and (at-robot ?nextpos) (not (at-robot ?curpos)) (visited ?nextpos))\n)\n\n)\n",
        "batch_id": 2,
        "id": 65,
        "tokens": 5012,
        "corrected_description": "### General\nThe domain is designed for a robot tasked with visiting all places in a grid. The robot can move between connected places, marking them as visited as it goes.\n\n### Types\n- **place**: Represents the locations or places within the grid.\n\n### Predicates\n- **(connected ?x ?y - place)**: Indicates that place ?x is directly connected to place ?y, allowing the robot to move between them.\n- **(at-robot ?x - place)**: Indicates that the robot is currently at place ?x.\n- **(visited ?x - place)**: Indicates that place ?x has been visited by the robot.\n\n### Actions\n- **move <?curpos> <?nextpos>**: Allows the robot to move from its current position to a next position if the two places are connected.",
        "pddl_domain_processed": "\n\n(define (domain grid-visit-all)\n(:requirements :typing)\n(:types        place - object)\n(:predicates (connected ?x ?y - place)\n\t     (at-robot ?x - place)\n\t     (visited ?x - place)\n)\n\n(:action move\n:parameters (?curpos ?nextpos - place)\n:precondition (and (at-robot ?curpos) (connected ?curpos ?nextpos))\n:effect (and (at-robot ?nextpos) (not (at-robot ?curpos)) (visited ?nextpos))\n)\n\n)\n"
    },
    {
        "file_name": "childsnack",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; The child-snack domain 2013\n;;\n;; This domain is for planning how to make and serve sandwiches for a group of\n;; children in which some are allergic to gluten. There are two actions for\n;; making sandwiches from their ingredients. The first one makes a sandwich and\n;; the second one makes a sandwich taking into account that all ingredients are\n;; gluten-free. There are also actions to put a sandwich on a tray, to move a tray\n;; from one place to another and to serve sandwiches.\n;;\n;; Problems in this domain define the ingredients to make sandwiches at the initial\n;; state. Goals consist of having all kids served with a sandwich to which they\n;; are not allergic.\n;;\n;; Author: Raquel Fuentetaja and Tom\u00e1s de la Rosa\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(define (domain child-snack)\n(:requirements :typing :equality)\n(:types child bread-portion content-portion sandwich tray place)\n(:constants kitchen - place)\n\n(:predicates (at_kitchen_bread ?b - bread-portion)\n\t     (at_kitchen_content ?c - content-portion)\n     \t     (at_kitchen_sandwich ?s - sandwich)\n     \t     (no_gluten_bread ?b - bread-portion)\n       \t     (no_gluten_content ?c - content-portion)\n      \t     (ontray ?s - sandwich ?t - tray)\n       \t     (no_gluten_sandwich ?s - sandwich)\n\t     (allergic_gluten ?c - child)\n     \t     (not_allergic_gluten ?c - child)\n\t     (served ?c - child)\n\t     (waiting ?c - child ?p - place)\n             (at ?t - tray ?p - place)\n\t     (notexist ?s - sandwich)\n  )\n\n(:action make_sandwich_no_gluten\n\t :parameters (?s - sandwich ?b - bread-portion ?c - content-portion)\n\t :precondition (and (at_kitchen_bread ?b)\n\t\t\t    (at_kitchen_content ?c)\n\t\t\t    (no_gluten_bread ?b)\n\t\t\t    (no_gluten_content ?c)\n\t\t\t    (notexist ?s))\n\t :effect (and\n\t\t   (not (at_kitchen_bread ?b))\n\t\t   (not (at_kitchen_content ?c))\n\t\t   (at_kitchen_sandwich ?s)\n\t\t   (no_gluten_sandwich ?s)\n                   (not (notexist ?s))\n\t\t   ))\n\n\n(:action make_sandwich\n\t :parameters (?s - sandwich ?b - bread-portion ?c - content-portion)\n\t :precondition (and (at_kitchen_bread ?b)\n\t\t\t    (at_kitchen_content ?c)\n                            (notexist ?s)\n\t\t\t    )\n\t :effect (and\n\t\t   (not (at_kitchen_bread ?b))\n\t\t   (not (at_kitchen_content ?c))\n\t\t   (at_kitchen_sandwich ?s)\n                   (not (notexist ?s))\n\t\t   ))\n\n\n(:action put_on_tray\n\t :parameters (?s - sandwich ?t - tray)\n\t :precondition (and  (at_kitchen_sandwich ?s)\n\t\t\t     (at ?t kitchen))\n\t :effect (and\n\t\t   (not (at_kitchen_sandwich ?s))\n\t\t   (ontray ?s ?t)))\n\n\n(:action serve_sandwich_no_gluten\n \t:parameters (?s - sandwich ?c - child ?t - tray ?p - place)\n\t:precondition (and\n\t\t       (allergic_gluten ?c)\n\t\t       (ontray ?s ?t)\n\t\t       (waiting ?c ?p)\n\t\t       (no_gluten_sandwich ?s)\n                       (at ?t ?p)\n\t\t       )\n\t:effect (and (not (ontray ?s ?t))\n\t\t     (served ?c)))\n\n(:action serve_sandwich\n\t:parameters (?s - sandwich ?c - child ?t - tray ?p - place)\n\t:precondition (and (not_allergic_gluten ?c)\n\t                   (waiting ?c ?p)\n\t\t\t   (ontray ?s ?t)\n\t\t\t   (at ?t ?p))\n\t:effect (and (not (ontray ?s ?t))\n\t\t     (served ?c)))\n\n(:action move_tray\n\t :parameters (?t - tray ?p1 ?p2 - place)\n\t :precondition (and (at ?t ?p1))\n\t :effect (and (not (at ?t ?p1))\n\t\t      (at ?t ?p2)))\n\n\n)\n",
        "batch_id": 2,
        "id": 66,
        "tokens": 6077,
        "corrected_description": "### General\nThe Child-Snack domain involves planning how to prepare and serve sandwiches to a group of children, some of whom are allergic to gluten. The domain includes actions for making sandwiches with or without gluten, placing sandwiches on a tray, moving the tray between places, and serving the sandwiches to the children. The goal is to ensure all children are served a suitable sandwich according to their dietary restrictions.\n\n### Types\n- **child**: Represents the children to be served.\n- **bread-portion**: Represents portions of bread.\n- **content-portion**: Represents portions of sandwich content (e.g., fillings).\n- **sandwich**: Represents completed sandwiches.\n- **tray**: Represents trays used to carry sandwiches.\n- **place**: Represents locations within the scenario, including the kitchen.\n\n### Predicates\n- **(at_kitchen_bread ?b - bread-portion)**: Indicates that a portion of bread is available in the kitchen.\n- **(at_kitchen_content ?c - content-portion)**: Indicates that a portion of content (filling) is available in the kitchen.\n- **(at_kitchen_sandwich ?s - sandwich)**: Indicates that a sandwich is available in the kitchen.\n- **(no_gluten_bread ?b - bread-portion)**: Indicates that a portion of bread is gluten-free.\n- **(no_gluten_content ?c - content-portion)**: Indicates that a portion of content (filling) is gluten-free.\n- **(ontray ?s - sandwich ?t - tray)**: Indicates that a sandwich is on a tray.\n- **(no_gluten_sandwich ?s - sandwich)**: Indicates that a sandwich is gluten-free.\n- **(allergic_gluten ?c - child)**: Indicates that a child is allergic to gluten.\n- **(not_allergic_gluten ?c - child)**: Indicates that a child is not allergic to gluten.\n- **(served ?c - child)**: Indicates that a child has been served.\n- **(waiting ?c - child ?p - place)**: Indicates that a child is waiting at a specific place.\n- **(at ?t - tray ?p - place)**: Indicates that a tray is at a specific place.\n- **(notexist ?s - sandwich)**: Indicates that a sandwich does not yet exist.\n\n### Actions\n- **make_sandwich_no_gluten <?s> <?b> <?c>**: Creates a gluten-free sandwich from available gluten-free bread and content in the kitchen.  \n\n- **make_sandwich <?s> <?b> <?c>**: Creates a sandwich from available bread and content in the kitchen, without considering gluten content.  \n\n- **put_on_tray <?s> <?t>**: Places a sandwich from the kitchen onto a tray that is in the kitchen.  \n\n- **serve_sandwich_no_gluten <?s> <?c> <?t> <?p>**: Serves a gluten-free sandwich from a tray to a child who is allergic to gluten and waiting at a specific place.  \n\n- **serve_sandwich <?s> <?c> <?t> <?p>**: Serves a sandwich from a tray to a child who is not allergic to gluten and waiting at a specific place.  \n\n- **move_tray <?t> <?p1> <?p2>**: Moves a tray from one place to another, changing the location of the tray within the scenario.",
        "pddl_domain_processed": "\n\n(define (domain child-snack)\n(:requirements :typing :equality)\n(:types child bread-portion content-portion sandwich tray place)\n(:constants kitchen - place)\n\n(:predicates (at_kitchen_bread ?b - bread-portion)\n\t     (at_kitchen_content ?c - content-portion)\n     \t     (at_kitchen_sandwich ?s - sandwich)\n     \t     (no_gluten_bread ?b - bread-portion)\n       \t     (no_gluten_content ?c - content-portion)\n      \t     (ontray ?s - sandwich ?t - tray)\n       \t     (no_gluten_sandwich ?s - sandwich)\n\t     (allergic_gluten ?c - child)\n     \t     (not_allergic_gluten ?c - child)\n\t     (served ?c - child)\n\t     (waiting ?c - child ?p - place)\n             (at ?t - tray ?p - place)\n\t     (notexist ?s - sandwich)\n  )\n\n(:action make_sandwich_no_gluten\n\t :parameters (?s - sandwich ?b - bread-portion ?c - content-portion)\n\t :precondition (and (at_kitchen_bread ?b)\n\t\t\t    (at_kitchen_content ?c)\n\t\t\t    (no_gluten_bread ?b)\n\t\t\t    (no_gluten_content ?c)\n\t\t\t    (notexist ?s))\n\t :effect (and\n\t\t   (not (at_kitchen_bread ?b))\n\t\t   (not (at_kitchen_content ?c))\n\t\t   (at_kitchen_sandwich ?s)\n\t\t   (no_gluten_sandwich ?s)\n                   (not (notexist ?s))\n\t\t   ))\n\n(:action make_sandwich\n\t :parameters (?s - sandwich ?b - bread-portion ?c - content-portion)\n\t :precondition (and (at_kitchen_bread ?b)\n\t\t\t    (at_kitchen_content ?c)\n                            (notexist ?s)\n\t\t\t    )\n\t :effect (and\n\t\t   (not (at_kitchen_bread ?b))\n\t\t   (not (at_kitchen_content ?c))\n\t\t   (at_kitchen_sandwich ?s)\n                   (not (notexist ?s))\n\t\t   ))\n\n(:action put_on_tray\n\t :parameters (?s - sandwich ?t - tray)\n\t :precondition (and  (at_kitchen_sandwich ?s)\n\t\t\t     (at ?t kitchen))\n\t :effect (and\n\t\t   (not (at_kitchen_sandwich ?s))\n\t\t   (ontray ?s ?t)))\n\n(:action serve_sandwich_no_gluten\n \t:parameters (?s - sandwich ?c - child ?t - tray ?p - place)\n\t:precondition (and\n\t\t       (allergic_gluten ?c)\n\t\t       (ontray ?s ?t)\n\t\t       (waiting ?c ?p)\n\t\t       (no_gluten_sandwich ?s)\n                       (at ?t ?p)\n\t\t       )\n\t:effect (and (not (ontray ?s ?t))\n\t\t     (served ?c)))\n\n(:action serve_sandwich\n\t:parameters (?s - sandwich ?c - child ?t - tray ?p - place)\n\t:precondition (and (not_allergic_gluten ?c)\n\t                   (waiting ?c ?p)\n\t\t\t   (ontray ?s ?t)\n\t\t\t   (at ?t ?p))\n\t:effect (and (not (ontray ?s ?t))\n\t\t     (served ?c)))\n\n(:action move_tray\n\t :parameters (?t - tray ?p1 ?p2 - place)\n\t :precondition (and (at ?t ?p1))\n\t :effect (and (not (at ?t ?p1))\n\t\t      (at ?t ?p2)))\n\n)\n"
    },
    {
        "file_name": "data-network",
        "pddl_domain": ";; Distributed Computing Planning Domain\n;; Authors: Manuel Heusner, Florian Pommerening, Alvaro Torralba\n;;\n;; In a given network of servers, each server can produce data by processing\n;; existing data and send the data to connected servers. Each server has a disk\n;; and random access memory (RAM). Data that is saved on the disk of a server\n;; must be loaded into RAM of the server in order to be processed or sent to the\n;; RAM of another server.\n;;\n;; The ability to process and distribute the data in the network is constrained\n;; by\n;;     - the connections between servers,\n;;     - the capacity of server's RAM,\n;;     - the availability of scripts on servers, and\n;;     - the cost of\n;;         - load and save actions, which depends on the data size and the (disk's io performance of a) server,\n;;         - send action, which depends on the data size and (bandwidth of a) connection, and\n;;         - process action, which depends on the script and (clock rate and numbers of processors of a) server.\n\n\n(define (domain data-network)\n(:requirements :adl :typing :negative-preconditions :equality :action-costs)\n\n(:types data script server numbers)\n\n(:predicates (SCRIPT-IO ?s - script ?in1 - data ?in2 - data ?out - data)\n             (CONNECTED ?from - server ?to - server)\n             (DATA-SIZE ?d - data ?n - numbers)\n             (CAPACITY ?s - server ?n - numbers)\n             (SUM ?n1 - numbers ?n2 - numbers ?sum - numbers)\n             (LESS-EQUAL ?n1 - numbers ?n2 - numbers)\n             (saved ?d - data ?s - server)\n             (cached ?d - data ?s - server)\n             (usage ?s - server ?n - numbers))\n\n(:functions (total-cost) - number\n            (process-cost ?sc - script ?s - server) - number\n            (send-cost ?from ?to - server ?size - numbers) - number\n            (io-cost ?s - server ?size - numbers) - number)\n\n\n;; Release data from RAM.\n(:action release\n :parameters (?d - data ?s - server ?size ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (SUM ?after ?size ?before)\n                    (cached ?d ?s)\n                    (usage ?s ?before))\n :effect (and (not (cached ?d ?s))\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) 0)))\n\n;; Save data from RAM to disk.\n(:action save\n :parameters (?d - data ?size - numbers ?s - server)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (cached ?d ?s))\n :effect (and (saved ?d ?s)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n;; Load data from disk into RAM.\n(:action load\n :parameters (?d - data ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (saved ?d ?s)\n                    (not (cached ?d ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?d ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n;; Send data from RAM of one server to RAM of another server.\n(:action send\n :parameters (?d - data ?from ?to - server  ?size ?limit ?before ?after - numbers)\n :precondition (and (CONNECTED ?from ?to)\n                    (DATA-SIZE ?d ?size)\n                    (CAPACITY ?to ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?d ?from)\n                    (not (cached ?d ?to))\n                    (usage ?to ?before))\n :effect (and (cached ?d ?to)\n              (not (usage ?to ?before))\n              (usage ?to ?after)\n              (increase (total-cost) (send-cost ?from ?to ?size))))\n\n;; Executes a script that processes two data items from RAM and produces another data item in RAM.\n(:action process\n :parameters (?in1 ?in2 ?out - data ?sc - script ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (SCRIPT-IO ?sc ?in1 ?in2 ?out)\n                    (DATA-SIZE ?out ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?in1 ?s)\n                    (cached ?in2 ?s)\n                    (not (cached ?out ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?out ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (process-cost ?sc ?s))))\n)\n",
        "batch_id": 2,
        "id": 67,
        "tokens": 6552,
        "corrected_description": "### General\nThis domain models a distributed computing environment where servers process and exchange data. Servers have limited RAM and disk space. Data must be loaded into RAM from a server's disk to be processed or sent to another server. The domain includes actions for loading, saving, sending, and processing data, with costs associated with each action based on data size, server capacity, and network bandwidth.\n\n### Types\n- **data**: Represents individual pieces of data that can be processed or transferred.\n- **script**: Represents processing scripts that can transform data items.\n- **server**: Represents computing servers in the network.\n- **numbers**: Represents numerical values, such as data sizes and capacities.\n\n### Predicates\n- **SCRIPT-IO (?s - script ?in1 - data ?in2 - data ?out - data)**: Indicates that script ?s takes inputs ?in1 and ?in2 to produce output ?out.\n- **CONNECTED (?from - server ?to - server)**: Indicates that there is a network connection from server ?from to server ?to.\n- **DATA-SIZE (?d - data ?n - numbers)**: Relates a piece of data ?d to its size ?n.\n- **CAPACITY (?s - server ?n - numbers)**: Relates a server ?s to its RAM capacity ?n.\n- **SUM (?n1 - numbers ?n2 - numbers ?sum - numbers)**: Represents the sum of ?n1 and ?n2 is ?sum.\n- **LESS-EQUAL (?n1 - numbers ?n2 - numbers)**: Indicates that ?n1 is less than or equal to ?n2.\n- **saved (?d - data ?s - server)**: Indicates that data ?d is saved on the disk of server ?s.\n- **cached (?d - data ?s - server)**: Indicates that data ?d is loaded into the RAM of server ?s.\n- **usage (?s - server ?n - numbers)**: Relates a server ?s to the amount of RAM in use ?n.\n\n### Actions\n- **release <?d> <?s> <?size> <?before> <?after>**: Releases data from a server's RAM, freeing up space.   \n\n- **save <?d> <?size> <?s>**: Saves data from RAM to a server's disk.  \n\n- **load <?d> <?s> <?size> <?limit> <?before> <?after>**: Loads data from a server's disk into RAM.  \n\n- **send <?d> <?from> <?to> <?size> <?limit> <?before> <?after>**: Sends data from the RAM of one server to another.  \n\n- **process <?in1> <?in2> <?out> <?sc> <?s> <?size> <?limit> <?before> <?after>**: Processes two data items to produce a new data item.",
        "pddl_domain_processed": "\n\n(define (domain data-network)\n(:requirements :adl :typing :negative-preconditions :equality :action-costs)\n\n(:types data script server numbers)\n\n(:predicates (SCRIPT-IO ?s - script ?in1 - data ?in2 - data ?out - data)\n             (CONNECTED ?from - server ?to - server)\n             (DATA-SIZE ?d - data ?n - numbers)\n             (CAPACITY ?s - server ?n - numbers)\n             (SUM ?n1 - numbers ?n2 - numbers ?sum - numbers)\n             (LESS-EQUAL ?n1 - numbers ?n2 - numbers)\n             (saved ?d - data ?s - server)\n             (cached ?d - data ?s - server)\n             (usage ?s - server ?n - numbers))\n\n(:functions (total-cost) - number\n            (process-cost ?sc - script ?s - server) - number\n            (send-cost ?from ?to - server ?size - numbers) - number\n            (io-cost ?s - server ?size - numbers) - number)\n\n(:action release\n :parameters (?d - data ?s - server ?size ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (SUM ?after ?size ?before)\n                    (cached ?d ?s)\n                    (usage ?s ?before))\n :effect (and (not (cached ?d ?s))\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) 0)))\n\n(:action save\n :parameters (?d - data ?size - numbers ?s - server)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (cached ?d ?s))\n :effect (and (saved ?d ?s)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n(:action load\n :parameters (?d - data ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (DATA-SIZE ?d ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (saved ?d ?s)\n                    (not (cached ?d ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?d ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (io-cost ?s ?size))))\n\n(:action send\n :parameters (?d - data ?from ?to - server  ?size ?limit ?before ?after - numbers)\n :precondition (and (CONNECTED ?from ?to)\n                    (DATA-SIZE ?d ?size)\n                    (CAPACITY ?to ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?d ?from)\n                    (not (cached ?d ?to))\n                    (usage ?to ?before))\n :effect (and (cached ?d ?to)\n              (not (usage ?to ?before))\n              (usage ?to ?after)\n              (increase (total-cost) (send-cost ?from ?to ?size))))\n\n(:action process\n :parameters (?in1 ?in2 ?out - data ?sc - script ?s - server ?size ?limit ?before ?after - numbers)\n :precondition (and (SCRIPT-IO ?sc ?in1 ?in2 ?out)\n                    (DATA-SIZE ?out ?size)\n                    (CAPACITY ?s ?limit)\n                    (SUM ?before ?size ?after)\n                    (LESS-EQUAL ?after ?limit)\n                    (cached ?in1 ?s)\n                    (cached ?in2 ?s)\n                    (not (cached ?out ?s))\n                    (usage ?s ?before))\n :effect (and (cached ?out ?s)\n              (not (usage ?s ?before))\n              (usage ?s ?after)\n              (increase (total-cost) (process-cost ?sc ?s))))\n)\n"
    },
    {
        "file_name": "tsp",
        "pddl_domain": "(define (domain tsp)\n  (:predicates\n     (at ?x)\n     (visited ?x))\n\n  (:action move\n\t:parameters (?x ?y)\n\t:precondition (at ?x)\n\t:effect (and (at ?y) (visited ?y) (not (at ?x)))))\n",
        "batch_id": 2,
        "id": 68,
        "tokens": 4615,
        "corrected_description": "### General\nThis domain models a simplified version of the Traveling Salesperson Problem (TSP), where the goal is to visit a series of locations. The domain includes actions for moving between locations and marking locations as visited.\n\n### Predicates\n- (at ?x): Indicates the current location.\n- (visited ?x): Indicates that location ?x has been visited.\n\n### Actions\n- **move <?x> <?y>**: Allows moving from location ?x to location ?y.",
        "pddl_domain_processed": "(define (domain tsp)\n  (:predicates\n     (at ?x)\n     (visited ?x))\n\n  (:action move\n\t:parameters (?x ?y)\n\t:precondition (at ?x)\n\t:effect (and (at ?y) (visited ?y) (not (at ?x)))))\n"
    },
    {
        "file_name": "tpp",
        "pddl_domain": "; IPC5 Domain: TPP Propositional\n; Authors: Alfonso Gerevini and Alessandro Saetti \n\n(define (domain TPP-Propositional)\n(:requirements :strips :typing)\n(:types place locatable level - object\n\tdepot market - place\n\ttruck goods - locatable)\n\n(:predicates (loaded ?g - goods ?t - truck ?l - level)\n\t     (ready-to-load ?g - goods ?m - market ?l - level) \n\t     (stored ?g - goods ?l - level) \n\t     (on-sale ?g - goods ?m -  market ?l - level)\n\t     (next ?l1 ?l2 - level)\n\t     (at ?t - truck ?p - place)\n\t     (connected ?p1 ?p2 - place))\n\n(:action drive\n :parameters (?t - truck ?from ?to - place)\n :precondition (and (at ?t ?from) (connected ?from ?to))\n :effect (and (not (at ?t ?from)) (at ?t ?to)))\n\n\n; ### LOAD ###\n; ?l1 is the level of ?g ready to be loaded at ?m before loading\n; ?l2 is the level of ?g ready to be loaded at ?m after loading\n; ?l3 is the level of ?g in ?t before loading\n; ?l4 is the level of ?g in ?t after loading\n\n(:action load\n :parameters (?g - goods ?t - truck ?m - market ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?m) (loaded ?g ?t ?l3)\n\t\t    (ready-to-load ?g ?m ?l2) (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (loaded ?g ?t ?l4) (not (loaded ?g ?t ?l3)) \n\t      (ready-to-load ?g ?m ?l1) (not (ready-to-load ?g ?m ?l2))))\n\n\n; ### UNLOAD ###\n; ?l1 is the level of ?g in ?t before unloading\n; ?l2 is the level of ?g in ?t after unloading\n; ?l3 is the level of ?g in ?d before unloading\n; ?l4 is the level of ?g in ?d after unloading\n\n(:action unload\n :parameters (?g - goods ?t - truck ?d - depot ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?d) (loaded ?g ?t ?l2)\n\t\t    (stored ?g ?l3) (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (loaded ?g ?t ?l1) (not (loaded ?g ?t ?l2)) \n\t      (stored ?g ?l4) (not (stored ?g ?l3))))\n\n\n; ### BUY ###\n; ?l1 is the level of ?g on sale at ?m before buying\n; ?l2 is the level of ?g on sale at ?m after buying \n; ?l3 is the level of ?g ready to be loaded at ?m before buying\n; ?l4 is the level of ?g ready to be loaded at ?m after buying\n\n(:action buy\n :parameters (?t - truck ?g - goods ?m - market ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?m) (on-sale ?g ?m ?l2) (ready-to-load ?g ?m ?l3)\n\t\t    (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (on-sale ?g ?m ?l1) (not (on-sale ?g ?m ?l2)) \n\t      (ready-to-load ?g ?m ?l4) (not (ready-to-load ?g ?m ?l3))))\n\n)",
        "batch_id": 2,
        "id": 71,
        "tokens": 5938,
        "corrected_description": "### General\nThe TPP (Transportation Planning Problem) Propositional domain involves managing the transportation and sale of goods. Trucks move between depots and markets, goods are bought at markets, loaded onto trucks, transported, and then unloaded at depots. The domain models a simplified supply chain from purchasing goods to storing them.\n\n### Types\n- **object**: The base type for all objects in the domain.\n- **place**: Represents locations in the domain, including depots and markets.\n- **locatable**: Represents entities that can be moved or are involved in transactions, including trucks and goods.\n- **level**: Represents quantities or levels of goods.\n- **depot**: A subtype of place, represents storage locations for goods.\n- **market**: A subtype of place, represents locations where goods can be bought.\n- **truck**: A subtype of locatable, represents vehicles used for transporting goods.\n- **goods**: A subtype of locatable, represents items that can be bought, sold, and transported.\n\n### Predicates\n- **(loaded ?g - goods ?t - truck ?l - level)**: Indicates that goods ?g are loaded onto truck ?t at level ?l.\n- **(ready-to-load ?g - goods ?m - market ?l - level)**: Indicates that goods ?g are ready to be loaded at market ?m at level ?l.\n- **(stored ?g - goods ?l - level)**: Indicates that goods ?g are stored at level ?l.\n- **(on-sale ?g - goods ?m - market ?l - level)**: Indicates that goods ?g are on sale at market ?m at level ?l.\n- **(next ?l1 ?l2 - level)**: Indicates that level ?l2 is immediately after level ?l1.\n- **(at ?t - truck ?p - place)**: Indicates that truck ?t is at place ?p.\n- **(connected ?p1 ?p2 - place)**: Indicates that place ?p1 is connected to place ?p2, allowing for travel between them.\n\n### Actions\n- **drive <?t> <?from> <?to>**: Allows a truck (?t) to drive from one place (?from) to another place (?to). The preconditions for this action are that the truck must be at the starting place (?from), and the starting place (?from) must be connected to the destination place (?to). The effect of this action is that the truck is no longer at the starting place (?from) and is now at the destination place (?to).\n\n- **load <?g> <?t> <?m> <?l1> <?l2> <?l3> <?l4>**: Loads goods (?g) onto a truck (?t) at a market (?m), updating the levels before and after loading.  \n\n- **unload <?g> <?t> <?d> <?l1> <?l2> <?l3> <?l4>**: Unloads goods (?g) from a truck (?t) at a depot (?d), updating the levels before and after unloading.  \n\n- **buy <?t> <?g> <?m> <?l1> <?l2> <?l3> <?l4>**: Allows a truck (?t) to buy goods (?g) at a market (?m), updating the levels before and after buying.",
        "pddl_domain_processed": "\n\n(define (domain TPP-Propositional)\n(:requirements :strips :typing)\n(:types place locatable level - object\n\tdepot market - place\n\ttruck goods - locatable)\n\n(:predicates (loaded ?g - goods ?t - truck ?l - level)\n\t     (ready-to-load ?g - goods ?m - market ?l - level) \n\t     (stored ?g - goods ?l - level) \n\t     (on-sale ?g - goods ?m -  market ?l - level)\n\t     (next ?l1 ?l2 - level)\n\t     (at ?t - truck ?p - place)\n\t     (connected ?p1 ?p2 - place))\n\n(:action drive\n :parameters (?t - truck ?from ?to - place)\n :precondition (and (at ?t ?from) (connected ?from ?to))\n :effect (and (not (at ?t ?from)) (at ?t ?to)))\n\n(:action load\n :parameters (?g - goods ?t - truck ?m - market ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?m) (loaded ?g ?t ?l3)\n\t\t    (ready-to-load ?g ?m ?l2) (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (loaded ?g ?t ?l4) (not (loaded ?g ?t ?l3)) \n\t      (ready-to-load ?g ?m ?l1) (not (ready-to-load ?g ?m ?l2))))\n\n(:action unload\n :parameters (?g - goods ?t - truck ?d - depot ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?d) (loaded ?g ?t ?l2)\n\t\t    (stored ?g ?l3) (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (loaded ?g ?t ?l1) (not (loaded ?g ?t ?l2)) \n\t      (stored ?g ?l4) (not (stored ?g ?l3))))\n\n(:action buy\n :parameters (?t - truck ?g - goods ?m - market ?l1 ?l2 ?l3 ?l4 - level)\n :precondition (and (at ?t ?m) (on-sale ?g ?m ?l2) (ready-to-load ?g ?m ?l3)\n\t\t    (next ?l2 ?l1) (next ?l4 ?l3))\n :effect (and (on-sale ?g ?m ?l1) (not (on-sale ?g ?m ?l2)) \n\t      (ready-to-load ?g ?m ?l4) (not (ready-to-load ?g ?m ?l3))))\n\n)"
    },
    {
        "file_name": "woodworking",
        "pddl_domain": ";; Woodworking\n;;\n\n(define (domain woodworking)\n  (:requirements :typing :action-costs)\n  (:types\n      acolour awood woodobj machine \n      surface treatmentstatus\n      aboardsize apartsize - object\n      highspeed-saw glazer grinder immersion-varnisher\n      planer saw spray-varnisher - machine\n      board part - woodobj)\n\n  (:constants\n              verysmooth smooth rough - surface\n              varnished glazed untreated colourfragments - treatmentstatus\n              natural - acolour\n              small medium large - apartsize)\n\n  (:predicates \n            (unused ?obj - part)\n            (available ?obj - woodobj)\n\n            (surface-condition ?obj - woodobj ?surface - surface)\n            (treatment ?obj - part ?treatment - treatmentstatus)\n            (colour ?obj - part ?colour - acolour)\n            (wood ?obj - woodobj ?wood - awood)\n            (boardsize ?board - board ?size - aboardsize)\n            (goalsize ?part - part ?size - apartsize)\n            (boardsize-successor ?size1 ?size2 - aboardsize)\n\n            (in-highspeed-saw ?b - board ?m - highspeed-saw)\n            (empty ?m - highspeed-saw)\n            (has-colour ?machine - machine ?colour - acolour)\n            (contains-part ?b - board ?p - part)\n            (grind-treatment-change ?old ?new - treatmentstatus)\n            (is-smooth ?surface - surface))\n      \n  (:functions (total-cost) - number\n            (spray-varnish-cost ?obj - part) - number\n            (glaze-cost ?obj - part) - number\n            (grind-cost ?obj - part) - number\n            (plane-cost ?obj - part) - number)\n\n  (:action do-immersion-varnish\n    :parameters (?x - part ?m - immersion-varnisher \n                 ?newcolour - acolour ?surface - surface)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (surface-condition ?x ?surface)\n            (is-smooth ?surface)\n            (treatment ?x untreated))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (treatment ?x untreated))\n            (treatment ?x varnished)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-spray-varnish\n    :parameters (?x - part ?m - spray-varnisher \n                 ?newcolour - acolour ?surface - surface)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (surface-condition ?x ?surface)\n            (is-smooth ?surface)\n            (treatment ?x untreated))\n    :effect (and \n            (increase (total-cost) (spray-varnish-cost ?x))\n            (not (treatment ?x untreated))\n            (treatment ?x varnished)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-glaze\n    :parameters (?x - part ?m - glazer \n                 ?newcolour - acolour)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (treatment ?x untreated))\n    :effect (and \n            (increase (total-cost) (glaze-cost ?x))\n            (not (treatment ?x untreated))\n            (treatment ?x glazed)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-grind\n    :parameters (?x - part ?m - grinder ?oldsurface - surface\n                 ?oldcolour - acolour \n                 ?oldtreatment ?newtreatment - treatmentstatus) \n    :precondition (and \n            (available ?x)\n            (surface-condition ?x ?oldsurface)\n            (is-smooth ?oldsurface)\n            (colour ?x ?oldcolour)\n            (treatment ?x ?oldtreatment)\n            (grind-treatment-change ?oldtreatment ?newtreatment))\n    :effect (and\n            (increase (total-cost) (grind-cost ?x))\n            (not (surface-condition ?x ?oldsurface))\n            (surface-condition ?x verysmooth)\n            (not (treatment ?x ?oldtreatment))\n            (treatment ?x ?newtreatment)\n            (not (colour ?x ?oldcolour))\n            (colour ?x natural)))\n\n  (:action do-plane\n    :parameters (?x - part ?m - planer ?oldsurface - surface\n                 ?oldcolour - acolour ?oldtreatment - treatmentstatus) \n    :precondition (and \n            (available ?x)\n            (surface-condition ?x ?oldsurface)\n            (treatment ?x ?oldtreatment)\n            (colour ?x ?oldcolour))\n    :effect (and\n            (increase (total-cost) (plane-cost ?x))\n            (not (surface-condition ?x ?oldsurface))\n            (surface-condition ?x smooth)\n            (not (treatment ?x ?oldtreatment))\n            (treatment ?x untreated)\n            (not (colour ?x ?oldcolour))\n            (colour ?x natural)))\n\n  (:action load-highspeed-saw\n    :parameters (?b - board ?m - highspeed-saw)\n    :precondition (and\n            (empty ?m)\n            (available ?b))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (available ?b))\n            (not (empty ?m))\n            (in-highspeed-saw ?b ?m)))\n            \n  (:action unload-highspeed-saw\n    :parameters (?b - board ?m - highspeed-saw)\n    :precondition (in-highspeed-saw ?b ?m)\n    :effect (and\n            (increase (total-cost) 10)\n            (available ?b)\n            (not (in-highspeed-saw ?b ?m))\n            (empty ?m)))\n            \n  (:action cut-board-small\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface ?size_before ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p small)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action cut-board-medium\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p medium)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\n\t    (not (boardsize ?b ?size_before))\n))\n\n  (:action cut-board-large\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?s2 ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p large)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?s2)\n            (boardsize-successor ?s2 ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action do-saw-small\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface ?size_before ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p small)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\t\n\t    (not (boardsize ?b ?size_before))\n))\n\n  (:action do-saw-medium\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p medium)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action do-saw-large\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?s2 ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p large)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?s2)\n            (boardsize-successor ?s2 ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\t    ;; Added line to mark change in size of board\n\t    (not (boardsize ?b ?size_before))))\n)\n\n",
        "batch_id": 2,
        "id": 73,
        "tokens": 7993,
        "corrected_description": "### General\nThis domain is designed for a woodworking scenario where various woodworking tasks such as cutting boards, varnishing, glazing, grinding, and planing are performed. It involves different types of machines, wood objects, and actions to manipulate these objects to achieve desired characteristics like size, surface condition, and treatment status.\n\n### Types\n- **acolour**: Represents different colors that can be applied to parts.\n- **awood**: Represents types of wood.\n- **woodobj**: A general category for objects made of wood.\n- **machine**: Represents various machines used in woodworking.\n- **surface**: Represents the surface condition of wood objects.\n- **treatmentstatus**: Represents the treatment status of parts.\n- **aboardsize, apartsize**: Represent sizes for boards and parts, respectively.\n- **highspeed-saw, glazer, grinder, immersion-varnisher, planer, saw, spray-varnisher**: Specific types of machines used for different woodworking tasks.\n- **board, part**: Subtypes of woodobj, representing different wood objects.\n\n### Predicates\n- **(unused ?obj - part)**: Indicates that a part is unused.\n- **(available ?obj - woodobj)**: Indicates that a wood object is available for use.\n- **(surface-condition ?obj - woodobj ?surface - surface)**: Describes the surface condition of a wood object.\n- **(treatment ?obj - part ?treatment - treatmentstatus)**: Describes the treatment status of a part.\n- **(colour ?obj - part ?colour - acolour)**: Indicates the color of a part.\n- **(wood ?obj - woodobj ?wood - awood)**: Indicates the type of wood of a wood object.\n- **(boardsize ?board - board ?size - aboardsize)**: Indicates the size of a board.\n- **(goalsize ?part - part ?size - apartsize)**: Indicates the goal size for a part.\n- **(boardsize-successor ?size1 ?size2 - aboardsize)**: Indicates the successor relationship between board sizes.\n- **(in-highspeed-saw ?b - board ?m - highspeed-saw)**: Indicates that a board is in a high-speed saw.\n- **(empty ?m - highspeed-saw)**: Indicates that a high-speed saw is empty.\n- **(has-colour ?machine - machine ?colour - acolour)**: Indicates that a machine can apply a specific color.\n- **(contains-part ?b - board ?p - part)**: Indicates that a board contains a part.\n- **(grind-treatment-change ?old ?new - treatmentstatus)**: Indicates the change in treatment status due to grinding.\n- **(is-smooth ?surface - surface)**: Indicates that a surface condition is smooth.\n\n#### Functions\n- **(total-cost) - number**: This function represents the total cost accumulated from performing various actions.\n- **(spray-varnish-cost ?obj - part) - number**: This function calculates the cost of spray varnishing a part (?obj).\n- **(glaze-cost ?obj - part) - number**: This function calculates the cost of glazing a part (?obj).\n- **(grind-cost ?obj - part) - number**: This function calculates the cost of grinding a part (?obj).\n- **(plane-cost ?obj - part) - number**: This function calculates the cost of planing a part (?obj).\n\n### Actions\n- **do-immersion-varnish <?x> <?m> <?newcolour> <?surface>**: Applies varnish to a part using an immersion varnisher, changing its color and treatment status and the total cost is increased by 10.  \n\n- **do-spray-varnish <?x> <?m> <?newcolour> <?surface>**: Applies varnish to a part using a spray varnisher, changing its color and treatment status, with the cost depending on the part .  \n\n- **do-glaze <?x> <?m> <?newcolour>**: Applies glaze to a part, changing its color and treatment status, with the cost depending on the part.  \n\n- **do-grind <?x> <?m> <?oldsurface> <?oldcolour> <?oldtreatment> <?newtreatment>**: Grinds a part to change its surface condition to very smooth, its color to natural, and its treatment status according to specified parameters, with the cost depending on the part.  \n\n- **do-plane <?x> <?m> <?oldsurface> <?oldcolour> <?oldtreatment>**: Planes a part to change its surface condition to smooth, its color to natural, and its treatment status to untreated, with the cost depending on the part.  \n\n- **load-highspeed-saw <?b> <?m>**: Loads a board into a high-speed saw, marking it as unavailable and the saw as not empty with the total cost is increased by 30.  \n\n- **unload-highspeed-saw <?b> <?m>**: Unloads a board from a high-speed saw, making it available again and the saw empty with the total cost is increased by 10.  \n\n- **cut-board-small/medium/large <?b> <?p> <?m> <?w> <?surface> <?size_before> <?s1> <?s2> <?size_after>**: Cuts a board to a smaller size to create a part of a specified goal size, changing the board's size and marking the part as available with the total cost is increased by 10.  \n\n- **do-saw-small/medium/large <?b> <?p> <?m> <?w> <?surface> <?size_before> <?s1> <?s2> <?size_after>**: Similar to cut-board actions but uses a different saw, with the cost and effects tailored to the size of the part being cut with the total cost is increased by 30.",
        "pddl_domain_processed": "\n\n(define (domain woodworking)\n  (:requirements :typing :action-costs)\n  (:types\n      acolour awood woodobj machine \n      surface treatmentstatus\n      aboardsize apartsize - object\n      highspeed-saw glazer grinder immersion-varnisher\n      planer saw spray-varnisher - machine\n      board part - woodobj)\n\n  (:constants\n              verysmooth smooth rough - surface\n              varnished glazed untreated colourfragments - treatmentstatus\n              natural - acolour\n              small medium large - apartsize)\n\n  (:predicates \n            (unused ?obj - part)\n            (available ?obj - woodobj)\n\n            (surface-condition ?obj - woodobj ?surface - surface)\n            (treatment ?obj - part ?treatment - treatmentstatus)\n            (colour ?obj - part ?colour - acolour)\n            (wood ?obj - woodobj ?wood - awood)\n            (boardsize ?board - board ?size - aboardsize)\n            (goalsize ?part - part ?size - apartsize)\n            (boardsize-successor ?size1 ?size2 - aboardsize)\n\n            (in-highspeed-saw ?b - board ?m - highspeed-saw)\n            (empty ?m - highspeed-saw)\n            (has-colour ?machine - machine ?colour - acolour)\n            (contains-part ?b - board ?p - part)\n            (grind-treatment-change ?old ?new - treatmentstatus)\n            (is-smooth ?surface - surface))\n\n  (:functions (total-cost) - number\n            (spray-varnish-cost ?obj - part) - number\n            (glaze-cost ?obj - part) - number\n            (grind-cost ?obj - part) - number\n            (plane-cost ?obj - part) - number)\n\n  (:action do-immersion-varnish\n    :parameters (?x - part ?m - immersion-varnisher \n                 ?newcolour - acolour ?surface - surface)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (surface-condition ?x ?surface)\n            (is-smooth ?surface)\n            (treatment ?x untreated))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (treatment ?x untreated))\n            (treatment ?x varnished)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-spray-varnish\n    :parameters (?x - part ?m - spray-varnisher \n                 ?newcolour - acolour ?surface - surface)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (surface-condition ?x ?surface)\n            (is-smooth ?surface)\n            (treatment ?x untreated))\n    :effect (and \n            (increase (total-cost) (spray-varnish-cost ?x))\n            (not (treatment ?x untreated))\n            (treatment ?x varnished)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-glaze\n    :parameters (?x - part ?m - glazer \n                 ?newcolour - acolour)\n    :precondition (and\n            (available ?x)\n            (has-colour ?m ?newcolour)\n            (treatment ?x untreated))\n    :effect (and \n            (increase (total-cost) (glaze-cost ?x))\n            (not (treatment ?x untreated))\n            (treatment ?x glazed)\n            (not (colour ?x natural))\n            (colour ?x ?newcolour)))\n\n  (:action do-grind\n    :parameters (?x - part ?m - grinder ?oldsurface - surface\n                 ?oldcolour - acolour \n                 ?oldtreatment ?newtreatment - treatmentstatus) \n    :precondition (and \n            (available ?x)\n            (surface-condition ?x ?oldsurface)\n            (is-smooth ?oldsurface)\n            (colour ?x ?oldcolour)\n            (treatment ?x ?oldtreatment)\n            (grind-treatment-change ?oldtreatment ?newtreatment))\n    :effect (and\n            (increase (total-cost) (grind-cost ?x))\n            (not (surface-condition ?x ?oldsurface))\n            (surface-condition ?x verysmooth)\n            (not (treatment ?x ?oldtreatment))\n            (treatment ?x ?newtreatment)\n            (not (colour ?x ?oldcolour))\n            (colour ?x natural)))\n\n  (:action do-plane\n    :parameters (?x - part ?m - planer ?oldsurface - surface\n                 ?oldcolour - acolour ?oldtreatment - treatmentstatus) \n    :precondition (and \n            (available ?x)\n            (surface-condition ?x ?oldsurface)\n            (treatment ?x ?oldtreatment)\n            (colour ?x ?oldcolour))\n    :effect (and\n            (increase (total-cost) (plane-cost ?x))\n            (not (surface-condition ?x ?oldsurface))\n            (surface-condition ?x smooth)\n            (not (treatment ?x ?oldtreatment))\n            (treatment ?x untreated)\n            (not (colour ?x ?oldcolour))\n            (colour ?x natural)))\n\n  (:action load-highspeed-saw\n    :parameters (?b - board ?m - highspeed-saw)\n    :precondition (and\n            (empty ?m)\n            (available ?b))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (available ?b))\n            (not (empty ?m))\n            (in-highspeed-saw ?b ?m)))\n\n  (:action unload-highspeed-saw\n    :parameters (?b - board ?m - highspeed-saw)\n    :precondition (in-highspeed-saw ?b ?m)\n    :effect (and\n            (increase (total-cost) 10)\n            (available ?b)\n            (not (in-highspeed-saw ?b ?m))\n            (empty ?m)))\n\n  (:action cut-board-small\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface ?size_before ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p small)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action cut-board-medium\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p medium)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))\n))\n\n  (:action cut-board-large\n    :parameters (?b - board ?p - part ?m - highspeed-saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?s2 ?size_after - aboardsize)\n    :precondition (and\n            (unused ?p)\n            (goalsize ?p large)\n            (in-highspeed-saw ?b ?m)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?s2)\n            (boardsize-successor ?s2 ?size_before))\n    :effect (and\n            (increase (total-cost) 10)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural)\n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action do-saw-small\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface ?size_before ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p small)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))\n))\n\n  (:action do-saw-medium\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p medium)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))\n\t    ))\n\n  (:action do-saw-large\n    :parameters (?b - board ?p - part ?m - saw ?w - awood\n                 ?surface - surface \n                 ?size_before ?s1 ?s2 ?size_after - aboardsize) \n    :precondition (and \n            (unused ?p)\n            (goalsize ?p large)\n            (available ?b)\n            (wood ?b ?w)\n            (surface-condition ?b ?surface)\n            (boardsize ?b ?size_before)\n            (boardsize-successor ?size_after ?s1)\n            (boardsize-successor ?s1 ?s2)\n            (boardsize-successor ?s2 ?size_before))\n    :effect (and\n            (increase (total-cost) 30)\n            (not (unused ?p))\n            (available ?p)\n            (wood ?p ?w)\n            (surface-condition ?p ?surface)\n            (colour ?p natural) \n            (treatment ?p untreated)\n            (boardsize ?b ?size_after)\n\n\t    (not (boardsize ?b ?size_before))))\n)\n\n"
    },
    {
        "file_name": "hanoi",
        "pddl_domain": "\n(define (domain hanoi)\n(:requirements :strips)\n(:predicates (clear ?x)\n             (on ?x ?y)\n             (smaller ?x ?y))\n\n(:action move\n:parameters (?disc ?from ?to)\n:precondition (and (smaller ?disc ?to) \n                   (on ?disc ?from) \n                   (clear ?disc) \n                   (clear ?to))\n:effect  (and (clear ?from) \n              (on ?disc ?to) \n              (not (on ?disc ?from))  \n              (not (clear ?to)))\n )) \n",
        "batch_id": 2,
        "id": 74,
        "tokens": 4892,
        "corrected_description": "### General\nThe domain models the classic Tower of Hanoi puzzle, where the objective is to move a stack of discs from one peg to another, following certain rules. The puzzle consists of three pegs and a number of discs of different sizes, which can slide onto any peg. The puzzle starts with the discs in a neat stack in ascending order of size on one peg, the smallest at the top, thus making a conical shape. The goal is to move the entire stack to another peg, obeying the following simple rules: only one disc can be moved at a time, each move consists of taking the upper disc from one of the stacks and placing it on top of another stack, and no disc may be placed on top of a smaller disc.\n\n### Predicates\n(clear ?x): Indicates that there is no disc on top of disc or peg ?x, making it possible to place another disc on it.\n(on ?x ?y): Indicates that disc ?x is directly on top of disc or peg ?y.\n(smaller ?x ?y): Indicates that disc ?x is smaller than disc or peg ?y, allowing ?x to be placed on ?y according to the puzzle rules.\n\n### Actions\n- **move <?disc> <?from> <?to>**: Allows moving a disc from one peg to another.",
        "pddl_domain_processed": "\n(define (domain hanoi)\n(:requirements :strips)\n(:predicates (clear ?x)\n             (on ?x ?y)\n             (smaller ?x ?y))\n\n(:action move\n:parameters (?disc ?from ?to)\n:precondition (and (smaller ?disc ?to) \n                   (on ?disc ?from) \n                   (clear ?disc) \n                   (clear ?to))\n:effect  (and (clear ?from) \n              (on ?disc ?to) \n              (not (on ?disc ?from))  \n              (not (clear ?to)))\n )) \n"
    },
    {
        "file_name": "pegsol",
        "pddl_domain": ";; Peg Solitaire sequential domain\n\n(define (domain pegsolitaire-sequential)\n    (:requirements :typing :action-costs)\n    (:types location - object)\n    (:predicates\n        (IN-LINE ?x ?y ?z - location)\n        (occupied ?l - location)\n        (free ?l - location)\n        (move-ended)\n        (last-visited ?l - location)\n    )\n    (:functions (total-cost) - number)\n\n    (:action jump-new-move\n     :parameters (?from - location ?over - location ?to - location)\n     :precondition (and\n                       (move-ended)\n                       (IN-LINE ?from ?over ?to)\n                       (occupied ?from)\n                       (occupied ?over)\n                       (free ?to)\n                   )\n     :effect (and\n                 (not (move-ended))\n                 (not (occupied ?from))\n                 (not (occupied ?over))\n                 (not (free ?to))\n                 (free ?from)\n                 (free ?over)\n                 (occupied ?to)\n                 (last-visited ?to)\n                 (increase (total-cost) 1)\n             )\n    )\n\n    (:action jump-continue-move\n     :parameters (?from - location ?over - location ?to - location)\n     :precondition (and\n                       (last-visited ?from)\n                       (IN-LINE ?from ?over ?to)\n                       (occupied ?from)\n                       (occupied ?over)\n                       (free ?to)\n                   )\n     :effect (and\n                 (not (occupied ?from))\n                 (not (occupied ?over))\n                 (not (free ?to))\n                 (free ?from)\n                 (free ?over)\n                 (occupied ?to)\n                 (not (last-visited ?from))\n                 (last-visited ?to)\n             )\n    )\n\n    (:action end-move\n     :parameters (?loc - location)\n     :precondition (last-visited ?loc)\n     :effect (and\n                 (move-ended)\n                 (not (last-visited ?loc))\n             )\n    )\n)\n",
        "batch_id": 2,
        "id": 75,
        "tokens": 5487,
        "corrected_description": "### General\nThis domain models the game of Peg Solitaire in a sequential manner. It involves moving pegs on a board with the objective of eliminating pegs by jumping over them into empty spaces, following specific rules. The game is played on a board with locations, where each move consists of a peg jumping over another peg into a free location, thereby removing the jumped peg from the board. The actions are designed to support the initiation of a new move, continuation of a move, and ending a move, with the goal of minimizing the number of pegs on the board.\n\n### Types\n- **location**: Represents the different positions on the Peg Solitaire board.\n\n### Predicates\n- **(IN-LINE ?x ?y ?z - location)**: Determines if locations ?x, ?y, and ?z are in a straight line, which is a requirement for a peg to jump over another.\n- **(occupied ?l - location)**: Indicates that a location ?l is occupied by a peg.\n- **(free ?l - location)**: Indicates that a location ?l is free (no peg is present).\n- **(move-ended)**: Indicates that a move has ended, allowing for a new move to start.\n- **(last-visited ?l - location)**: Marks the last visited location ?l in a move, used for chaining jumps in a single move.\n\n#### Functions\n- **(total-cost) - number**: This function represents the total cost accumulated from performing various actions.\n\n### Actions\n- **jump-new-move <?from> <?over> <?to>**: Initiates a new move by jumping a peg from location ?from over a peg at location ?over to a free location ?to with the total cost is increased by 1.  \n\n- **jump-continue-move <?from> <?over> <?to>**: Continues a move by jumping a peg from the last visited location ?from over another peg at location ?over to a free location ?to.  \n\n- **end-move <?loc>**: Ends a move at location ?loc, allowing for a new move to start.",
        "pddl_domain_processed": "\n\n(define (domain pegsolitaire-sequential)\n    (:requirements :typing :action-costs)\n    (:types location - object)\n    (:predicates\n        (IN-LINE ?x ?y ?z - location)\n        (occupied ?l - location)\n        (free ?l - location)\n        (move-ended)\n        (last-visited ?l - location)\n    )\n    (:functions (total-cost) - number)\n\n    (:action jump-new-move\n     :parameters (?from - location ?over - location ?to - location)\n     :precondition (and\n                       (move-ended)\n                       (IN-LINE ?from ?over ?to)\n                       (occupied ?from)\n                       (occupied ?over)\n                       (free ?to)\n                   )\n     :effect (and\n                 (not (move-ended))\n                 (not (occupied ?from))\n                 (not (occupied ?over))\n                 (not (free ?to))\n                 (free ?from)\n                 (free ?over)\n                 (occupied ?to)\n                 (last-visited ?to)\n                 (increase (total-cost) 1)\n             )\n    )\n\n    (:action jump-continue-move\n     :parameters (?from - location ?over - location ?to - location)\n     :precondition (and\n                       (last-visited ?from)\n                       (IN-LINE ?from ?over ?to)\n                       (occupied ?from)\n                       (occupied ?over)\n                       (free ?to)\n                   )\n     :effect (and\n                 (not (occupied ?from))\n                 (not (occupied ?over))\n                 (not (free ?to))\n                 (free ?from)\n                 (free ?over)\n                 (occupied ?to)\n                 (not (last-visited ?from))\n                 (last-visited ?to)\n             )\n    )\n\n    (:action end-move\n     :parameters (?loc - location)\n     :precondition (last-visited ?loc)\n     :effect (and\n                 (move-ended)\n                 (not (last-visited ?loc))\n             )\n    )\n)\n"
    },
    {
        "file_name": "termes",
        "pddl_domain": "(define (domain termes)\n    (:requirements :typing :negative-preconditions)\n    (:types\n        numb - object\n        position - object\n        robot - object\n    )\n\n    (:predicates\n        (height ?p - position ?h - numb)\n        (at ?r - robot ?p - position)\n        (has-block ?r - robot)\n        (occupied ?p - position)\n        (SUCC ?n1 - numb ?n2 - numb)\n        (NEIGHBOR ?p1 - position ?p2 - position)\n        (IS-DEPOT ?p - position)\n    )\n\n    (:action move\n        :parameters (?r - robot ?from - position ?to - position ?h - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?h)\n            (height ?to ?h)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action move-up\n        :parameters (?r - robot ?from - position ?hfrom - numb ?to - position ?hto - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?hfrom)\n            (height ?to ?hto)\n            (SUCC ?hfrom ?hto)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action move-down\n        :parameters (?r - robot ?from - position ?hfrom - numb ?to - position ?hto - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?hfrom)\n            (height ?to ?hto)\n            (SUCC ?hto ?hfrom)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action place-block\n        :parameters (?r - robot ?rpos - position ?bpos - position ?hbefore - numb ?hafter - numb)\n        :precondition (and\n            (at ?r ?rpos)\n            (not (occupied ?bpos))\n            (NEIGHBOR ?rpos ?bpos)\n            (height ?rpos ?hbefore)\n            (height ?bpos ?hbefore)\n            (SUCC ?hbefore ?hafter)\n            (has-block ?r)\n        )\n        :effect (and\n            (not (height ?bpos ?hbefore))\n            (height ?bpos ?hafter)\n            (not (has-block ?r))\n        )\n    )\n\n    (:action remove-block\n        :parameters (?r - robot ?rpos - position ?bpos - position ?hbefore - numb ?hafter - numb)\n        :precondition (and\n            (at ?r ?rpos)\n            (not (occupied ?bpos))\n            (NEIGHBOR ?rpos ?bpos)\n            (height ?rpos ?hafter)\n            (height ?bpos ?hbefore)\n            (SUCC ?hafter ?hbefore)\n            (not (has-block ?r))\n        )\n        :effect (and\n            (not (height ?bpos ?hbefore))\n            (height ?bpos ?hafter)\n            (has-block ?r)\n        )\n    )\n\n    (:action create-block\n        :parameters (?r - robot ?p - position)\n        :precondition (and\n            (at ?r ?p)\n            (not (has-block ?r))\n            (IS-DEPOT ?p)\n        )\n        :effect (and\n            (has-block ?r)\n        )\n    )\n\n    (:action destroy-block\n        :parameters (?r - robot ?p - position)\n        :precondition (and\n            (at ?r ?p)\n            (has-block ?r)\n            (IS-DEPOT ?p)\n        )\n        :effect (and\n            (not (has-block ?r))\n        )\n    )\n\n\n)\n",
        "batch_id": 2,
        "id": 76,
        "tokens": 5974,
        "corrected_description": "### General\nThe Termes domain simulates a robotic construction environment where robots can move around a grid, carry blocks, and build structures by placing blocks at various heights. The robots can also move up and down the structures they are building. The domain includes actions for moving robots on the same level, moving up and down between levels, placing and removing blocks, and creating or destroying blocks at depots.\n\n### Types\n- **numb**: Represents numbers, used for heights in the domain.\n- **position**: Represents positions on the grid or within structures.\n- **robot**: Represents the robots operating in the environment.\n\n### Predicates\n- **(height ?p - position ?h - numb)**: Indicates the height of a position ?p is ?h.\n- **(at ?r - robot ?p - position)**: Indicates robot ?r is at position ?p.\n- **(has-block ?r - robot)**: Indicates robot ?r is currently carrying a block.\n- **(occupied ?p - position)**: Indicates position ?p is occupied.\n- **(SUCC ?n1 - numb ?n2 - numb)**: Indicates ?n2 is the successor number of ?n1, used for representing incremental heights.\n- **(NEIGHBOR ?p1 - position ?p2 - position)**: Indicates positions ?p1 and ?p2 are adjacent to each other.\n- **(IS-DEPOT ?p - position)**: Indicates position ?p is a depot where blocks can be created or destroyed.\n\n### Actions\n- **move <?r> <?from> <?to> <?h>**: Allows a robot to move from one position to another at the same height if the destination is not occupied and is a neighbor.  \n\n- **move-up <?r> <?from> <?hfrom> <?to> <?hto>**: Allows a robot to move up from one position to a higher adjacent position if the destination is not occupied.  \n\n- **move-down <?r> <?from> <?hfrom> <?to> <?hto>**: Allows a robot to move down from one position to a lower adjacent position if the destination is not occupied.  \n\n- **place-block <?r> <?rpos> <?bpos> <?hbefore> <?hafter>**: Allows a robot to place a block at an adjacent position, increasing the height of that position, if the robot is carrying a block.  \n\n- **remove-block <?r> <?rpos> <?bpos> <?hbefore> <?hafter>**: Allows a robot to remove a block from an adjacent position, decreasing the height of that position, and carry the block.  \n\n- **create-block <?r> <?p>**: Allows a robot to create a block at a depot if it is not already carrying a block.  \n\n- **destroy-block <?r> <?p>**: Allows a robot to destroy a block at a depot if it is carrying a block.",
        "pddl_domain_processed": "(define (domain termes)\n    (:requirements :typing :negative-preconditions)\n    (:types\n        numb - object\n        position - object\n        robot - object\n    )\n\n    (:predicates\n        (height ?p - position ?h - numb)\n        (at ?r - robot ?p - position)\n        (has-block ?r - robot)\n        (occupied ?p - position)\n        (SUCC ?n1 - numb ?n2 - numb)\n        (NEIGHBOR ?p1 - position ?p2 - position)\n        (IS-DEPOT ?p - position)\n    )\n\n    (:action move\n        :parameters (?r - robot ?from - position ?to - position ?h - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?h)\n            (height ?to ?h)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action move-up\n        :parameters (?r - robot ?from - position ?hfrom - numb ?to - position ?hto - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?hfrom)\n            (height ?to ?hto)\n            (SUCC ?hfrom ?hto)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action move-down\n        :parameters (?r - robot ?from - position ?hfrom - numb ?to - position ?hto - numb)\n        :precondition (and\n            (at ?r ?from)\n            (not (occupied ?to))\n            (NEIGHBOR ?from ?to)\n            (height ?from ?hfrom)\n            (height ?to ?hto)\n            (SUCC ?hto ?hfrom)\n        )\n        :effect (and\n            (not (at ?r ?from))\n            (at ?r ?to)\n            (not (occupied ?from))\n            (occupied ?to)\n        )\n    )\n\n    (:action place-block\n        :parameters (?r - robot ?rpos - position ?bpos - position ?hbefore - numb ?hafter - numb)\n        :precondition (and\n            (at ?r ?rpos)\n            (not (occupied ?bpos))\n            (NEIGHBOR ?rpos ?bpos)\n            (height ?rpos ?hbefore)\n            (height ?bpos ?hbefore)\n            (SUCC ?hbefore ?hafter)\n            (has-block ?r)\n        )\n        :effect (and\n            (not (height ?bpos ?hbefore))\n            (height ?bpos ?hafter)\n            (not (has-block ?r))\n        )\n    )\n\n    (:action remove-block\n        :parameters (?r - robot ?rpos - position ?bpos - position ?hbefore - numb ?hafter - numb)\n        :precondition (and\n            (at ?r ?rpos)\n            (not (occupied ?bpos))\n            (NEIGHBOR ?rpos ?bpos)\n            (height ?rpos ?hafter)\n            (height ?bpos ?hbefore)\n            (SUCC ?hafter ?hbefore)\n            (not (has-block ?r))\n        )\n        :effect (and\n            (not (height ?bpos ?hbefore))\n            (height ?bpos ?hafter)\n            (has-block ?r)\n        )\n    )\n\n    (:action create-block\n        :parameters (?r - robot ?p - position)\n        :precondition (and\n            (at ?r ?p)\n            (not (has-block ?r))\n            (IS-DEPOT ?p)\n        )\n        :effect (and\n            (has-block ?r)\n        )\n    )\n\n    (:action destroy-block\n        :parameters (?r - robot ?p - position)\n        :precondition (and\n            (at ?r ?p)\n            (has-block ?r)\n            (IS-DEPOT ?p)\n        )\n        :effect (and\n            (not (has-block ?r))\n        )\n    )\n\n)\n"
    },
    {
        "file_name": "citycar",
        "pddl_domain": "(define (domain citycar)\n(:requirements :typing :equality :negative-preconditions :action-costs :conditional-effects)\n  (:types  \n\tcar\n\tjunction\t\n\tgarage\n\troad\n\t)\n\n  (:predicates\n    (same_line ?xy - junction ?xy2 - junction) ;; junctions in line (row)\n    (diagonal ?x - junction ?y - junction ) ;; junctions in diagonal (on the map)\n    (at_car_jun ?c - car ?x - junction) ;; a car is at the junction\n    (at_car_road ?c - car ?x - road) ;; a car is in a road\n    (starting ?c - car ?x - garage) ;; a car is in its initial position\n    (arrived ?c - car ?x - junction) ;; a car arrived at destination\n    (road_connect ?r1 - road ?xy - junction ?xy2 - junction) ;; there is a road that connects 2 junctions\n    (clear ?xy - junction ) ;; the junction is clear \n    (in_place ?x - road);; the road has been put in place\n    (at_garage ?g - garage ?xy - junction ) ;; position of the starting garage\n\n  )\n(:functions (total-cost) - number)\n\n;; move the car in a road: no limit on the number of cars on the road\n(:action move_car_in_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?machine - car ?r1 - road)\n  :precondition (and \n\t\t(at_car_jun ?machine ?xy_initial)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(road_connect ?r1 ?xy_initial ?xy_final) \n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(clear ?xy_initial)\n\t\t(at_car_road ?machine ?r1)\n\t\t(not (at_car_jun ?machine ?xy_initial) )\n\t\t(increase (total-cost) 1)\n\t\t)\n)\n\n;; move the car out of the road to a junction. Junction must be clear.\n(:action move_car_out_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?machine - car ?r1 - road)\n  :precondition (and \n\t\t(at_car_road ?machine ?r1)\n\t\t(clear ?xy_final) \n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(road_connect ?r1 ?xy_initial ?xy_final) \n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(at_car_jun ?machine ?xy_final)\n\t\t(not (clear ?xy_final))\n\t\t(not (at_car_road ?machine ?r1) )\n\t\t(increase (total-cost) 1)\n\t\t)\n)\n\n;; car in the final position. They are removed from the network and position is cleared.\n(:action car_arrived\n  :parameters (?xy_final - junction ?machine - car )\n  :precondition (and \n\t\t(at_car_jun ?machine ?xy_final)\n\t\t)\n  :effect (and  \n\t\t(clear ?xy_final)\n\t\t(arrived ?machine ?xy_final)\n\t\t(not (at_car_jun ?machine ?xy_final))\n\t\t)\n)\n\n;; car moved from the initial garage in the network.\n(:action car_start\n  :parameters (?xy_final - junction ?machine - car ?g - garage)\n  :precondition (and \n\t\t(at_garage ?g ?xy_final)\n\t\t(starting ?machine ?g)\n\t\t(clear ?xy_final)\n\t\t)\n  :effect (and  \n\t\t(not (clear ?xy_final))\n\t\t(at_car_jun ?machine ?xy_final)\n\t\t(not (starting ?machine ?g))\n\t\t)\n)\n\n;; build diagonal road\n(:action build_diagonal_oneway\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(clear ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(not (in_place ?r1))\n\t\t(diagonal ?xy_initial ?xy_final) \n\t\t)\n  :effect (and  \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(in_place ?r1)\n                (increase (total-cost) 30)\n\t\t)\n)\n\n;; build straight road\n(:action build_straight_oneway\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(clear ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(same_line ?xy_initial ?xy_final) \n\t\t(not (in_place ?r1))\n\t\t)\n  :effect (and  \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(in_place ?r1)\n                (increase (total-cost) 20)\n\t\t)\n)\n\n;; remove a road\n(:action destroy_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(not (in_place ?r1))\n\t\t(not (road_connect ?r1 ?xy_initial ?xy_final))\n                (increase (total-cost) 10)\n\t\t(forall (?c1 - car)\n                     (when (at_car_road ?c1 ?r1) \n\t\t\t(and\n\t\t\t  (not (at_car_road ?c1 ?r1))\n\t\t\t  (at_car_jun ?c1 ?xy_initial)\n\t\t\t)\n\t\t      )\n\t\t   )\n\t\t)\n)\n\n\n\n\n)\n",
        "batch_id": 2,
        "id": 79,
        "tokens": 6268,
        "corrected_description": "### General\nThis domain models a city transportation system where cars move between junctions via roads. Cars can start from garages, move along roads, and reach their destinations. Roads can be built or destroyed, affecting the cars' ability to navigate the city.\n\n### Types\n- **car**: Represents the cars moving around the city.\n- **junction**: Represents the junctions or intersections where roads meet.\n- **garage**: Represents the starting points for cars.\n- **road**: Represents the roads connecting junctions.\n\n### Predicates\n- **(same_line ?xy - junction ?xy2 - junction)**: True if junctions ?xy and ?xy2 are in the same line (row).\n- **(diagonal ?x - junction ?y - junction)**: True if junctions ?x and ?y are diagonally aligned on the map.\n- **(at_car_jun ?c - car ?x - junction)**: True if car ?c is at junction ?x.\n- **(at_car_road ?c - car ?x - road)**: True if car ?c is on road ?x.\n- **(starting ?c - car ?x - garage)**: True if car ?c is starting from garage ?x.\n- **(arrived ?c - car ?x - junction)**: True if car ?c has arrived at its destination junction ?x.\n- **(road_connect ?r1 - road ?xy - junction ?xy2 - junction)**: True if road ?r1 connects junction ?xy with junction ?xy2.\n- **(clear ?xy - junction)**: True if junction ?xy is clear of cars.\n- **(in_place ?x - road)**: True if road ?x has been built and is in place.\n- **(at_garage ?g - garage ?xy - junction)**: True if garage ?g is located at junction ?xy.\n\n#### Functions\n- **(total-cost) - number**: This function represents the total cost accumulated from performing various actions.\n\n### Actions\n- **move_car_in_road <?xy_initial> <?xy_final> <?machine> <?r1>**: Moves a car from one junction to another via a road. Increases the total cost by 1. This action has no limit on the number of cars on the road.  \n\n- **move_car_out_road <?xy_initial> <?xy_final> <?machine> <?r1>**: Moves a car from a road to a clear junction. Increases the total cost by 1.  \n\n- **car_arrived <?xy_final> <?machine>**: Marks a car as arrived at its destination junction and clears the junction.  \n\n- **car_start <?xy_final> <?machine> <?g>**: Moves a car from its starting garage to a clear junction.  \n\n- **build_diagonal_oneway <?xy_initial> <?xy_final> <?r1>**: Builds a diagonal road between two junctions. Increases the total cost by 30.  \n\n- **build_straight_oneway <?xy_initial> <?xy_final> <?r1>**: Builds a straight road between two junctions. Increases the total cost by 20.  \n\n- **destroy_road <?xy_initial> <?xy_final> <?r1>**: Removes a road, potentially affecting cars on it. Increases the total cost by 10 and moves any cars on the road back to the initial junction.",
        "pddl_domain_processed": "(define (domain citycar)\n(:requirements :typing :equality :negative-preconditions :action-costs :conditional-effects)\n  (:types  \n\tcar\n\tjunction\t\n\tgarage\n\troad\n\t)\n\n  (:predicates\n    (same_line ?xy - junction ?xy2 - junction) \n    (diagonal ?x - junction ?y - junction ) \n    (at_car_jun ?c - car ?x - junction) \n    (at_car_road ?c - car ?x - road) \n    (starting ?c - car ?x - garage) \n    (arrived ?c - car ?x - junction) \n    (road_connect ?r1 - road ?xy - junction ?xy2 - junction) \n    (clear ?xy - junction ) \n    (in_place ?x - road)\n    (at_garage ?g - garage ?xy - junction ) \n\n  )\n(:functions (total-cost) - number)\n\n(:action move_car_in_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?machine - car ?r1 - road)\n  :precondition (and \n\t\t(at_car_jun ?machine ?xy_initial)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(road_connect ?r1 ?xy_initial ?xy_final) \n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(clear ?xy_initial)\n\t\t(at_car_road ?machine ?r1)\n\t\t(not (at_car_jun ?machine ?xy_initial) )\n\t\t(increase (total-cost) 1)\n\t\t)\n)\n\n(:action move_car_out_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?machine - car ?r1 - road)\n  :precondition (and \n\t\t(at_car_road ?machine ?r1)\n\t\t(clear ?xy_final) \n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(road_connect ?r1 ?xy_initial ?xy_final) \n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(at_car_jun ?machine ?xy_final)\n\t\t(not (clear ?xy_final))\n\t\t(not (at_car_road ?machine ?r1) )\n\t\t(increase (total-cost) 1)\n\t\t)\n)\n\n(:action car_arrived\n  :parameters (?xy_final - junction ?machine - car )\n  :precondition (and \n\t\t(at_car_jun ?machine ?xy_final)\n\t\t)\n  :effect (and  \n\t\t(clear ?xy_final)\n\t\t(arrived ?machine ?xy_final)\n\t\t(not (at_car_jun ?machine ?xy_final))\n\t\t)\n)\n\n(:action car_start\n  :parameters (?xy_final - junction ?machine - car ?g - garage)\n  :precondition (and \n\t\t(at_garage ?g ?xy_final)\n\t\t(starting ?machine ?g)\n\t\t(clear ?xy_final)\n\t\t)\n  :effect (and  \n\t\t(not (clear ?xy_final))\n\t\t(at_car_jun ?machine ?xy_final)\n\t\t(not (starting ?machine ?g))\n\t\t)\n)\n\n(:action build_diagonal_oneway\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(clear ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(not (in_place ?r1))\n\t\t(diagonal ?xy_initial ?xy_final) \n\t\t)\n  :effect (and  \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(in_place ?r1)\n                (increase (total-cost) 30)\n\t\t)\n)\n\n(:action build_straight_oneway\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(clear ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(same_line ?xy_initial ?xy_final) \n\t\t(not (in_place ?r1))\n\t\t)\n  :effect (and  \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(in_place ?r1)\n                (increase (total-cost) 20)\n\t\t)\n)\n\n(:action destroy_road\n  :parameters (?xy_initial - junction ?xy_final - junction ?r1 - road)\n  :precondition (and \n\t\t(road_connect ?r1 ?xy_initial ?xy_final)\n\t\t(not (= ?xy_initial ?xy_final))\n\t\t(in_place ?r1)\n\t\t)\n  :effect (and  \n\t\t(not (in_place ?r1))\n\t\t(not (road_connect ?r1 ?xy_initial ?xy_final))\n                (increase (total-cost) 10)\n\t\t(forall (?c1 - car)\n                     (when (at_car_road ?c1 ?r1) \n\t\t\t(and\n\t\t\t  (not (at_car_road ?c1 ?r1))\n\t\t\t  (at_car_jun ?c1 ?xy_initial)\n\t\t\t)\n\t\t      )\n\t\t   )\n\t\t)\n)\n\n)\n"
    },
    {
        "file_name": "elevators",
        "pddl_domain": "(define (domain elevators-sequencedstrips)\n  (:requirements :typing :action-costs)\n  (:types   elevator - object\n            slow-elevator fast-elevator - elevator\n            passenger - object\n            count - object\n         )\n\n(:predicates\n    (passenger-at ?person - passenger ?floor - count)\n    (boarded ?person - passenger ?lift - elevator)\n    (lift-at ?lift - elevator ?floor - count)\n    (reachable-floor ?lift - elevator ?floor - count)\n    (above ?floor1 - count ?floor2 - count)\n    (passengers ?lift - elevator ?n - count)\n    (can-hold ?lift - elevator ?n - count)\n    (next ?n1 - count ?n2 - count)\n)\n\n(:functions (total-cost) - number\n            (travel-slow ?f1 - count ?f2 - count) - number\n            (travel-fast ?f1 - count ?f2 - count) - number\n)\n\n(:action move-up-slow\n  :parameters (?lift - slow-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f1 ?f2 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-slow ?f1 ?f2))))\n\n(:action move-down-slow\n  :parameters (?lift - slow-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f2 ?f1 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-slow ?f2 ?f1))))\n\n(:action move-up-fast\n  :parameters (?lift - fast-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f1 ?f2 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-fast ?f1 ?f2))))\n\n(:action move-down-fast\n  :parameters (?lift - fast-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f2 ?f1 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-fast ?f2 ?f1))))\n\n(:action board\n  :parameters (?p - passenger ?lift - elevator ?f - count ?n1 - count ?n2 - count)\n  :precondition (and  (lift-at ?lift ?f) (passenger-at ?p ?f) (passengers ?lift ?n1) (next ?n1 ?n2) (can-hold ?lift ?n2) )\n  :effect (and (not (passenger-at ?p ?f)) (boarded ?p ?lift) (not (passengers ?lift ?n1)) (passengers ?lift ?n2) ))\n\n(:action leave\n  :parameters (?p - passenger ?lift - elevator ?f - count ?n1 - count ?n2 - count)\n  :precondition (and  (lift-at ?lift ?f) (boarded ?p ?lift) (passengers ?lift ?n1) (next ?n2 ?n1) )\n  :effect (and (passenger-at ?p ?f) (not (boarded ?p ?lift)) (not (passengers ?lift ?n1)) (passengers ?lift ?n2) ))\n\n)\n\n",
        "batch_id": 2,
        "id": 81,
        "tokens": 5952,
        "corrected_description": "### General\nThis domain models an elevator system with the capability to move passengers between floors. It distinguishes between slow and fast elevators, allowing for different travel costs associated with moving between floors. The domain supports actions for moving elevators up and down, boarding passengers, and passengers leaving elevators. It also incorporates action costs to model the efficiency of elevator movements.\n\n### Types\n- **object**: The base type for all entities in the domain.\n- **elevator**: Represents all elevators in the system. It is further specialized into slow and fast elevators.\n- **slow-elevator**, **fast-elevator**: Subtypes of elevator, representing slow and fast elevators, respectively.\n- **passenger**: Represents individuals using the elevators.\n- **count**: Represents numerical values, such as floor numbers and passenger counts within elevators.\n\n### Predicates\n- **(passenger-at ?person - passenger ?floor - count)**: Indicates that a passenger is at a specific floor.\n- **(boarded ?person - passenger ?lift - elevator)**: Indicates that a passenger is on board an elevator.\n- **(lift-at ?lift - elevator ?floor - count)**: Indicates that an elevator is at a specific floor.\n- **(reachable-floor ?lift - elevator ?floor - count)**: Indicates that a floor is reachable by an elevator.\n- **(above ?floor1 - count ?floor2 - count)**: Indicates that floor2 is above floor1.\n- **(passengers ?lift - elevator ?n - count)**: Indicates the number of passengers currently in an elevator.\n- **(can-hold ?lift - elevator ?n - count)**: Indicates the maximum capacity of passengers an elevator can hold.\n- **(next ?n1 - count ?n2 - count)**: Represents a successor relation between counts, useful for incrementing passenger counts.\n\n### Functions\n- **(total-cost)**: Represents the cumulative cost of all actions taken.\n- **(travel-slow ?f1 - count ?f2 - count)**: Represents the cost of a slow elevator traveling between two floors.\n- **(travel-fast ?f1 - count ?f2 - count)**: Represents the cost of a fast elevator traveling between two floors.\n\n### Actions\n- **move-up-slow <?lift> <?f1> <?f2>**: Moves a slow elevator (?lift) up from one floor (?f1) to another floor (?f2) with a cost based on the distance traveled.  \n\n- **move-down-slow <?lift> <?f1> <?f2>**: Moves a slow elevator (?lift) down from one floor (?f1) to another floor (?f2) with a cost based on the distance traveled.  \n\n- **move-up-fast <?lift> <?f1> <?f2>**: Moves a fast elevator (?lift) up from one floor (?f1) to another floor (?f2) with a cost based on the distance traveled.  \n\n- **move-down-fast <?lift> <?f1> <?f2>**: Moves a fast elevator (?lift) down from one floor (?f1) to another floor (?f2) with a cost based on the distance traveled.  \n\n- **board <?p> <?lift> <?f> <?n1> <?n2>**: Allows a passenger (?p) to board an elevator (?lift) at a floor (?f), increasing the number of passengers in the lift.  \n\n- **leave <?p> <?lift> <?f> <?n1> <?n2>**: Allows a passenger (?p) to leave an elevator (?lift) at a floor (?f), decreasing the number of passengers in the lift.",
        "pddl_domain_processed": "(define (domain elevators-sequencedstrips)\n  (:requirements :typing :action-costs)\n  (:types   elevator - object\n            slow-elevator fast-elevator - elevator\n            passenger - object\n            count - object\n         )\n\n(:predicates\n    (passenger-at ?person - passenger ?floor - count)\n    (boarded ?person - passenger ?lift - elevator)\n    (lift-at ?lift - elevator ?floor - count)\n    (reachable-floor ?lift - elevator ?floor - count)\n    (above ?floor1 - count ?floor2 - count)\n    (passengers ?lift - elevator ?n - count)\n    (can-hold ?lift - elevator ?n - count)\n    (next ?n1 - count ?n2 - count)\n)\n\n(:functions (total-cost) - number\n            (travel-slow ?f1 - count ?f2 - count) - number\n            (travel-fast ?f1 - count ?f2 - count) - number\n)\n\n(:action move-up-slow\n  :parameters (?lift - slow-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f1 ?f2 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-slow ?f1 ?f2))))\n\n(:action move-down-slow\n  :parameters (?lift - slow-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f2 ?f1 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-slow ?f2 ?f1))))\n\n(:action move-up-fast\n  :parameters (?lift - fast-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f1 ?f2 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-fast ?f1 ?f2))))\n\n(:action move-down-fast\n  :parameters (?lift - fast-elevator ?f1 - count ?f2 - count )\n  :precondition (and (lift-at ?lift ?f1) (above ?f2 ?f1 ) (reachable-floor ?lift ?f2) )\n  :effect (and (lift-at ?lift ?f2) (not (lift-at ?lift ?f1)) (increase (total-cost) (travel-fast ?f2 ?f1))))\n\n(:action board\n  :parameters (?p - passenger ?lift - elevator ?f - count ?n1 - count ?n2 - count)\n  :precondition (and  (lift-at ?lift ?f) (passenger-at ?p ?f) (passengers ?lift ?n1) (next ?n1 ?n2) (can-hold ?lift ?n2) )\n  :effect (and (not (passenger-at ?p ?f)) (boarded ?p ?lift) (not (passengers ?lift ?n1)) (passengers ?lift ?n2) ))\n\n(:action leave\n  :parameters (?p - passenger ?lift - elevator ?f - count ?n1 - count ?n2 - count)\n  :precondition (and  (lift-at ?lift ?f) (boarded ?p ?lift) (passengers ?lift ?n1) (next ?n2 ?n1) )\n  :effect (and (passenger-at ?p ?f) (not (boarded ?p ?lift)) (not (passengers ?lift ?n1)) (passengers ?lift ?n2) ))\n\n)\n\n"
    },
    {
        "file_name": "floortile",
        "pddl_domain": ";;Created by Tomas de la Rosa\n;;Domain for painting floor tiles with two colors\n;;See MIT License attached\n\n(define (domain floor-tile)\n(:requirements :typing :action-costs)\n(:types robot tile color - object)\n\n(:predicates \t\n\t\t(robot-at ?r - robot ?x - tile)\n\t\t(up ?x - tile ?y - tile)\n\t\t(down ?x - tile ?y - tile)\n\t\t(right ?x - tile ?y - tile)\n\t\t(left ?x - tile ?y - tile)\n\t\t\n\t\t(clear ?x - tile)\n                (painted ?x - tile ?c - color)\n\t\t(robot-has ?r - robot ?c - color)\n                (available-color ?c - color)\n                (free-color ?r - robot))\n\n(:functions (total-cost) - number)\n\n(:action change-color\n  :parameters (?r - robot ?c - color ?c2 - color)\n  :precondition (and (robot-has ?r ?c) (available-color ?c2))\n  :effect (and (not (robot-has ?r ?c)) (robot-has ?r ?c2)\n               (increase (total-cost) 5))\n) \n\n\n(:action paint-up\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n               (increase (total-cost) 2))\n)\n\n\n(:action paint-down\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n(increase (total-cost) 2))\n)\n\n\n; Robot movements\n(:action up \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 3))\n)\n\n\n(:action down \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n(:action right \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (right ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n\t       (increase (total-cost) 1))\n)\n\n(:action left \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (left ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n)\n",
        "batch_id": 2,
        "id": 82,
        "tokens": 5870,
        "corrected_description": "### General\nThis domain is designed for a scenario where robots are tasked with painting floor tiles in two colors. It includes actions for robots to change colors, paint tiles in different directions, and move around the grid of tiles. The domain supports action costs, allowing for the calculation of the total cost associated with a sequence of actions.\n\n### Types\n- **robot**: Represents the robots that will perform the painting and moving actions.\n- **tile**: Represents the individual tiles on the floor that can be painted.\n- **color**: Represents the colors available for painting the tiles.\n\n### Predicates\n- **(robot-at ?r - robot ?x - tile)**: Indicates that robot ?r is located at tile ?x.\n- **(up ?x - tile ?y - tile)**: Indicates that tile ?x is directly above tile ?y.\n- **(down ?x - tile ?y - tile)**: Indicates that tile ?x is directly below tile ?y.\n- **(right ?x - tile ?y - tile)**: Indicates that tile ?x is directly to the right of tile ?y.\n- **(left ?x - tile ?y - tile)**: Indicates that tile ?x is directly to the left of tile ?y.\n- **(clear ?x - tile)**: Indicates that tile ?x is clear and can be painted or moved onto.\n- **(painted ?x - tile ?c - color)**: Indicates that tile ?x has been painted with color ?c.\n- **(robot-has ?r - robot ?c - color)**: Indicates that robot ?r is currently holding paint of color ?c.\n- **(available-color ?c - color)**: Indicates that color ?c is available for painting.\n- **(free-color ?r - robot)**: Indicates that the robot ?r is not currently holding any paint color.\n\n### Functions\n- **(total-cost)**: Represents the total cost accumulated through actions performed by the robots.\n\n### Actions\n- **change-color <?r> <?c> <?c2>**: Allows a robot to change the color it is currently holding to another available color. This action increases the total cost by 5.  \n\n- **paint-up <?r> <?y> <?x> <?c>**: Allows a robot to paint the tile ?y directly above its current position ?x, provided the tile is clear. This action increases the total cost by 2.  \n\n- **paint-down <?r> <?y> <?x> <?c>**: Allows a robot to paint the tile ?y directly below its current position ?x, provided the tile is clear. This action increases the total cost by 2.  \n\n- **up <?r> <?x> <?y>**: Moves the robot to the tile ?y directly above its current position ?x if the tile is clear. This action increases the total cost by 3.  \n\n- **down <?r> <?x> <?y>**: Moves the robot to the tile ?y directly below its current position ?x if the tile is clear. This action increases the total cost by 1.  \n\n- **right <?r> <?x> <?y>**: Moves the robot to the tile ?y directly to its right if the tile is clear. This action increases the total cost by 1.  \n\n- **left <?r> <?x> <?y>**: Moves the robot to the tile ?y directly to its left if the tile is clear. This action increases the total cost by 1.",
        "pddl_domain_processed": "\n\n(define (domain floor-tile)\n(:requirements :typing :action-costs)\n(:types robot tile color - object)\n\n(:predicates \t\n\t\t(robot-at ?r - robot ?x - tile)\n\t\t(up ?x - tile ?y - tile)\n\t\t(down ?x - tile ?y - tile)\n\t\t(right ?x - tile ?y - tile)\n\t\t(left ?x - tile ?y - tile)\n\n\t\t(clear ?x - tile)\n                (painted ?x - tile ?c - color)\n\t\t(robot-has ?r - robot ?c - color)\n                (available-color ?c - color)\n                (free-color ?r - robot))\n\n(:functions (total-cost) - number)\n\n(:action change-color\n  :parameters (?r - robot ?c - color ?c2 - color)\n  :precondition (and (robot-has ?r ?c) (available-color ?c2))\n  :effect (and (not (robot-has ?r ?c)) (robot-has ?r ?c2)\n               (increase (total-cost) 5))\n) \n\n(:action paint-up\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n               (increase (total-cost) 2))\n)\n\n(:action paint-down\n  :parameters (?r - robot ?y - tile ?x - tile ?c - color)\n  :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (not (clear ?y)) (painted ?y ?c)\n(increase (total-cost) 2))\n)\n\n(:action up \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (up ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 3))\n)\n\n(:action down \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (down ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n(:action right \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (right ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n\t       (increase (total-cost) 1))\n)\n\n(:action left \n  :parameters (?r - robot ?x - tile ?y - tile)\n  :precondition (and (robot-at ?r ?x) (left ?y ?x) (clear ?y))\n  :effect (and (robot-at ?r ?y) (not (robot-at ?r ?x))\n               (clear ?x) (not (clear ?y))\n               (increase (total-cost) 1))\n)\n\n)\n"
    },
    {
        "file_name": "depots",
        "pddl_domain": "(define (domain depots)\n(:requirements :strips :typing)\n(:types place locatable - object\n\tdepot distributor - place\n        truck hoist surface - locatable\n        pallet crate - surface)\n\n(:predicates (at ?x - locatable ?y - place)\n             (on ?x - crate ?y - surface)\n             (in ?x - crate ?y - truck)\n             (lifting ?x - hoist ?y - crate)\n             (available ?x - hoist)\n             (clear ?x - surface))\n\t\n(:action Drive\n  :parameters (?x - truck ?y - place ?z - place) \n  :precondition (and (at ?x ?y))\n  :effect (and (not (at ?x ?y)) (at ?x ?z)))\n\n(:action Lift\n  :parameters (?x - hoist ?y - crate ?z - surface ?p - place)\n  :precondition (and (at ?x ?p) (available ?x) (at ?y ?p) (on ?y ?z) (clear ?y))\n  :effect (and (not (at ?y ?p)) (lifting ?x ?y) (not (clear ?y)) (not (available ?x)) (clear ?z) (not (on ?y ?z))))\n\n(:action Drop \n  :parameters (?x - hoist ?y - crate ?z - surface ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (clear ?z) (lifting ?x ?y))\n  :effect (and (available ?x) (not (lifting ?x ?y)) (at ?y ?p) (not (clear ?z)) (clear ?y)(on ?y ?z)))\n\n(:action Load\n  :parameters (?x - hoist ?y - crate ?z - truck ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (lifting ?x ?y))\n  :effect (and (not (lifting ?x ?y)) (in ?y ?z) (available ?x)))\n\n(:action Unload \n  :parameters (?x - hoist ?y - crate ?z - truck ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (available ?x) (in ?y ?z))\n  :effect (and (not (in ?y ?z)) (not (available ?x)) (lifting ?x ?y)))\n)\n",
        "batch_id": 2,
        "id": 86,
        "tokens": 5686,
        "corrected_description": "### General\nThe domain models a logistics scenario involving depots, where trucks and hoists are used to move crates between different locations. The goal is to efficiently manage the transportation and handling of crates, ensuring they reach their intended destinations.\n\n### Types\n- **object**: The base type for all entities in the domain.\n- **place**: A subtype of object, representing locations such as depots and distributors.\n- **locatable**: A subtype of object, representing entities that can be located at places or on other locatable entities.\n- **depot**, **distributor**: Subtypes of place, representing different kinds of locations within the logistics network.\n- **truck**, **hoist**, **surface**: Subtypes of locatable, representing vehicles, lifting equipment, and surfaces on which crates can be placed, respectively.\n- **pallet**, **crate**: Subtypes of surface, representing containers and items that can be transported.\n\n### Predicates\n- **(at ?x - locatable ?y - place)**: Indicates that locatable ?x is at place ?y.\n- **(on ?x - crate ?y - surface)**: Indicates that crate ?x is on surface ?y.\n- **(in ?x - crate ?y - truck)**: Indicates that crate ?x is inside truck ?y.\n- **(lifting ?x - hoist ?y - crate)**: Indicates that hoist ?x is lifting crate ?y.\n- **(available ?x - hoist)**: Indicates that hoist ?x is available for lifting crates.\n- **(clear ?x - surface)**: Indicates that surface ?x has no crates on it.\n\n### Actions\n- **Drive <?x> <?y> <?z>**: Allows a truck ?x to move from one place ?y to another ?z.  \n\n- **Lift <?x> <?y> <?z> <?p>**: Allows a hoist ?x to lift a crate ?y from a surface ?z at place ?p.  \n\n- **Drop <?x> <?y> <?z> <?p>**: Allows a hoist ?x to drop a crate ?y onto a surface ?z at place ?p.  \n\n- **Load <?x> <?y> <?z> <?p>**: Allows a hoist ?x to load a crate ?y into a truck ?z at place ?p.  \n\n- **Unload <?x> <?y> <?z> <?p>**: Allows a hoist ?x to unload a crate ?y from a truck ?z at place ?p.",
        "pddl_domain_processed": "(define (domain depots)\n(:requirements :strips :typing)\n(:types place locatable - object\n\tdepot distributor - place\n        truck hoist surface - locatable\n        pallet crate - surface)\n\n(:predicates (at ?x - locatable ?y - place)\n             (on ?x - crate ?y - surface)\n             (in ?x - crate ?y - truck)\n             (lifting ?x - hoist ?y - crate)\n             (available ?x - hoist)\n             (clear ?x - surface))\n\n(:action Drive\n  :parameters (?x - truck ?y - place ?z - place) \n  :precondition (and (at ?x ?y))\n  :effect (and (not (at ?x ?y)) (at ?x ?z)))\n\n(:action Lift\n  :parameters (?x - hoist ?y - crate ?z - surface ?p - place)\n  :precondition (and (at ?x ?p) (available ?x) (at ?y ?p) (on ?y ?z) (clear ?y))\n  :effect (and (not (at ?y ?p)) (lifting ?x ?y) (not (clear ?y)) (not (available ?x)) (clear ?z) (not (on ?y ?z))))\n\n(:action Drop \n  :parameters (?x - hoist ?y - crate ?z - surface ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (clear ?z) (lifting ?x ?y))\n  :effect (and (available ?x) (not (lifting ?x ?y)) (at ?y ?p) (not (clear ?z)) (clear ?y)(on ?y ?z)))\n\n(:action Load\n  :parameters (?x - hoist ?y - crate ?z - truck ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (lifting ?x ?y))\n  :effect (and (not (lifting ?x ?y)) (in ?y ?z) (available ?x)))\n\n(:action Unload \n  :parameters (?x - hoist ?y - crate ?z - truck ?p - place)\n  :precondition (and (at ?x ?p) (at ?z ?p) (available ?x) (in ?y ?z))\n  :effect (and (not (in ?y ?z)) (not (available ?x)) (lifting ?x ?y)))\n)\n"
    },
    {
        "file_name": "scanalyzer",
        "pddl_domain": "(define (domain scanalyzer3d)\n  (:requirements :typing :action-costs)\n  (:types segment car - object)\n  (:predicates (on ?c - car ?s - segment)\n\t       (analyzed ?c - car)\n\t       (CYCLE-2 ?s1 ?s2 - segment)\n\t       (CYCLE-4 ?s1 ?s2 ?s3 ?s4 - segment)\n\t       (CYCLE-2-WITH-ANALYSIS ?s1 ?s2 - segment)\n\t       (CYCLE-4-WITH-ANALYSIS ?s1 ?s2 ?s3 ?s4 - segment))\n  (:functions (total-cost) - number)\n\n  (:action analyze-2\n   :parameters (?s1 ?s2 - segment ?c1 ?c2 - car)\n   :precondition (and (CYCLE-2-WITH-ANALYSIS ?s1 ?s2)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(on ?c1 ?s2)\n\t\t(on ?c2 ?s1)\n\t\t(analyzed ?c1)\n\t\t(increase (total-cost) 3)\n\t   )\n   )\n\n  (:action analyze-4\n   :parameters (?s1 ?s2 ?s3 ?s4 - segment ?c1 ?c2 ?c3 ?c4 - car)\n   :precondition (and (CYCLE-4-WITH-ANALYSIS ?s1 ?s2 ?s3 ?s4)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t      (on ?c3 ?s3)\n\t\t      (on ?c4 ?s4)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(not (on ?c3 ?s3))\n\t\t(not (on ?c4 ?s4))\n\t\t(on ?c1 ?s4)\n\t\t(on ?c2 ?s1)\n\t\t(on ?c3 ?s2)\n\t\t(on ?c4 ?s3)\n\t\t(analyzed ?c1)\n\t\t(increase (total-cost) 3)\n\t   )\n   )\n\t       \n  (:action rotate-2\n   :parameters (?s1 ?s2 - segment ?c1 ?c2 - car)\n   :precondition (and (CYCLE-2 ?s1 ?s2)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(on ?c1 ?s2)\n\t\t(on ?c2 ?s1)\n\t\t(increase (total-cost) 1)\n\t   )\n  )\n\n  (:action rotate-4\n   :parameters (?s1 ?s2 ?s3 ?s4 - segment ?c1 ?c2 ?c3 ?c4 - car)\n   :precondition (and (CYCLE-4 ?s1 ?s2 ?s3 ?s4)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t      (on ?c3 ?s3)\n\t\t      (on ?c4 ?s4)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(not (on ?c3 ?s3))\n\t\t(not (on ?c4 ?s4))\n\t\t(on ?c1 ?s4)\n\t\t(on ?c2 ?s1)\n\t\t(on ?c3 ?s2)\n\t\t(on ?c4 ?s3)\n\t\t(increase (total-cost) 1)\n\t   )\n   )\n)\n\n\n;; different costs for analyze and swap?\n",
        "batch_id": 2,
        "id": 87,
        "tokens": 5973,
        "corrected_description": "### General\nThe Scanalyzer3D domain involves a scenario where cars are placed on segments and can be analyzed or rotated between these segments. The domain includes actions for analyzing cars in pairs or groups of four, as well as rotating them without analysis. The goal is to efficiently analyze and/or reposition cars while managing the total cost associated with these actions.\n\n### Types\n- **segment**: Represents the different segments on which cars can be placed.\n- **car**: Represents the cars that are to be analyzed or moved.\n\n### Predicates\n- **(on ?c - car ?s - segment)**: Indicates that car ?c is on segment ?s.\n- **(analyzed ?c - car)**: Indicates that car ?c has been analyzed.\n- **(CYCLE-2 ?s1 ?s2 - segment)**: Represents a two-segment cycle that can be used for rotating cars.\n- **(CYCLE-4 ?s1 ?s2 ?s3 ?s4 - segment)**: Represents a four-segment cycle that can be used for rotating cars.\n- **(CYCLE-2-WITH-ANALYSIS ?s1 ?s2 - segment)**: Represents a two-segment cycle that can be used for analyzing and rotating cars.\n- **(CYCLE-4-WITH-ANALYSIS ?s1 ?s2 ?s3 ?s4 - segment)**: Represents a four-segment cycle that can be used for analyzing and rotating cars in groups of four.\n\n### Functions\n- **(total-cost)**: Represents the total cost accumulated from actions taken within the domain. This function is used to track the cost of analyzing and rotating cars.\n\n### Actions\n- **analyze-2 <?s1> <?s2> <?c1> <?c2>**: Analyzes two cars by swapping their positions between two segments with the total cost increased by 3.  \n  \n- **analyze-4 <?s1> <?s2> <?s3> <?s4> <?c1> <?c2> <?c3> <?c4>**: Analyzes four cars by rotating their positions among four segments with the total cost increased by 3.  \n  \n- **rotate-2 <?s1> <?s2> <?c1> <?c2>**: Rotates two cars between two segments and the total cost is increased by 1, without analyzing them.  \n  \n- **rotate-4 <?s1> <?s2> <?s3> <?s4> <?c1> <?c2> <?c3> <?c4>**: Rotates four cars among four segments and the total cost is increased by 1, without analyzing them.",
        "pddl_domain_processed": "(define (domain scanalyzer3d)\n  (:requirements :typing :action-costs)\n  (:types segment car - object)\n  (:predicates (on ?c - car ?s - segment)\n\t       (analyzed ?c - car)\n\t       (CYCLE-2 ?s1 ?s2 - segment)\n\t       (CYCLE-4 ?s1 ?s2 ?s3 ?s4 - segment)\n\t       (CYCLE-2-WITH-ANALYSIS ?s1 ?s2 - segment)\n\t       (CYCLE-4-WITH-ANALYSIS ?s1 ?s2 ?s3 ?s4 - segment))\n  (:functions (total-cost) - number)\n\n  (:action analyze-2\n   :parameters (?s1 ?s2 - segment ?c1 ?c2 - car)\n   :precondition (and (CYCLE-2-WITH-ANALYSIS ?s1 ?s2)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(on ?c1 ?s2)\n\t\t(on ?c2 ?s1)\n\t\t(analyzed ?c1)\n\t\t(increase (total-cost) 3)\n\t   )\n   )\n\n  (:action analyze-4\n   :parameters (?s1 ?s2 ?s3 ?s4 - segment ?c1 ?c2 ?c3 ?c4 - car)\n   :precondition (and (CYCLE-4-WITH-ANALYSIS ?s1 ?s2 ?s3 ?s4)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t      (on ?c3 ?s3)\n\t\t      (on ?c4 ?s4)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(not (on ?c3 ?s3))\n\t\t(not (on ?c4 ?s4))\n\t\t(on ?c1 ?s4)\n\t\t(on ?c2 ?s1)\n\t\t(on ?c3 ?s2)\n\t\t(on ?c4 ?s3)\n\t\t(analyzed ?c1)\n\t\t(increase (total-cost) 3)\n\t   )\n   )\n\n  (:action rotate-2\n   :parameters (?s1 ?s2 - segment ?c1 ?c2 - car)\n   :precondition (and (CYCLE-2 ?s1 ?s2)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(on ?c1 ?s2)\n\t\t(on ?c2 ?s1)\n\t\t(increase (total-cost) 1)\n\t   )\n  )\n\n  (:action rotate-4\n   :parameters (?s1 ?s2 ?s3 ?s4 - segment ?c1 ?c2 ?c3 ?c4 - car)\n   :precondition (and (CYCLE-4 ?s1 ?s2 ?s3 ?s4)\n\t\t      (on ?c1 ?s1)\n\t\t      (on ?c2 ?s2)\n\t\t      (on ?c3 ?s3)\n\t\t      (on ?c4 ?s4)\n\t\t  )\n   :effect (and (not (on ?c1 ?s1))\n\t\t(not (on ?c2 ?s2))\n\t\t(not (on ?c3 ?s3))\n\t\t(not (on ?c4 ?s4))\n\t\t(on ?c1 ?s4)\n\t\t(on ?c2 ?s1)\n\t\t(on ?c3 ?s2)\n\t\t(on ?c4 ?s3)\n\t\t(increase (total-cost) 1)\n\t   )\n   )\n)\n\n"
    },
    {
        "file_name": "ferry",
        "pddl_domain": "(define (domain ferry)\n   (:predicates (not-eq ?x ?y)\n\t\t(car ?c)\n\t\t(location ?l)\n\t\t(at-ferry ?l)\n\t\t(at ?c ?l)\n\t\t(empty-ferry)\n\t\t(on ?c))\n\n   (:action sail\n       :parameters  (?from ?to)\n       :precondition (and (not-eq ?from ?to) \n                          (location ?from) (location ?to) (at-ferry ?from))\n       :effect (and  (at-ferry ?to)\n\t\t     (not (at-ferry ?from))))\n\n\n   (:action board\n       :parameters (?car ?loc)\n       :precondition  (and  (car ?car) (location ?loc)\n\t\t\t    (at ?car ?loc) (at-ferry ?loc) (empty-ferry))\n       :effect (and (on ?car)\n\t\t    (not (at ?car ?loc)) \n\t\t    (not (empty-ferry))))\n\n   (:action debark\n       :parameters  (?car  ?loc)\n       :precondition  (and  (car ?car) (location ?loc)\n\t\t\t    (on ?car) (at-ferry ?loc))\n       :effect (and (at ?car ?loc)\n\t\t    (empty-ferry)\n\t\t    (not (on ?car)))))\n",
        "batch_id": 2,
        "id": 88,
        "tokens": 5133,
        "corrected_description": "### General\nYou are operating a ferry that can transport cars between different locations. The goal is to find a plan that moves cars to their desired locations using the ferry.\n\n### Predicates\n(not-eq ?x ?y): Indicates that ?x and ?y are different entities.\n(car ?c): Indicates that ?c is a car.\n(location ?l): Indicates that ?l is a location.\n(at-ferry ?l): Indicates that the ferry is at location ?l.\n(at ?c ?l): Indicates that car ?c is at location ?l.\n(empty-ferry): Indicates that the ferry is empty.\n(on ?c): Indicates that car ?c is on the ferry.\n\n### Actions\n- **sail <?from> <?to>**: Allows the ferry to sail from one location to another.  \n\n- **board <?car> <?loc>**: Allows a car to board the ferry if the ferry is at the same location as the car and the ferry is empty.  \n\n- **debark <?car> <?loc>**: Allows a car to debark from the ferry to a location if the ferry is at that location and the car is on the ferry.",
        "pddl_domain_processed": "(define (domain ferry)\n   (:predicates (not-eq ?x ?y)\n\t\t(car ?c)\n\t\t(location ?l)\n\t\t(at-ferry ?l)\n\t\t(at ?c ?l)\n\t\t(empty-ferry)\n\t\t(on ?c))\n\n   (:action sail\n       :parameters  (?from ?to)\n       :precondition (and (not-eq ?from ?to) \n                          (location ?from) (location ?to) (at-ferry ?from))\n       :effect (and  (at-ferry ?to)\n\t\t     (not (at-ferry ?from))))\n\n   (:action board\n       :parameters (?car ?loc)\n       :precondition  (and  (car ?car) (location ?loc)\n\t\t\t    (at ?car ?loc) (at-ferry ?loc) (empty-ferry))\n       :effect (and (on ?car)\n\t\t    (not (at ?car ?loc)) \n\t\t    (not (empty-ferry))))\n\n   (:action debark\n       :parameters  (?car  ?loc)\n       :precondition  (and  (car ?car) (location ?loc)\n\t\t\t    (on ?car) (at-ferry ?loc))\n       :effect (and (at ?car ?loc)\n\t\t    (empty-ferry)\n\t\t    (not (on ?car)))))\n"
    },
    {
        "file_name": "satellite",
        "pddl_domain": "(define (domain satellite)\n  (:requirements :strips :typing)\n  (:types satellite direction instrument mode)\n  (:predicates \n\t(on_board ?i - instrument ?s - satellite)\n\t(supports ?i - instrument ?m - mode)\n\t(pointing ?s - satellite ?d - direction)\n\t(power_avail ?s - satellite)\n\t(power_on ?i - instrument)\n\t(calibrated ?i - instrument)\n\t(have_image ?d - direction ?m - mode)\n\t(calibration_target ?i - instrument ?d - direction))\n \n  (:action turn_to\n   :parameters (?s - satellite ?d_new - direction ?d_prev - direction)\n   :precondition (and (pointing ?s ?d_prev))\n   :effect (and  (pointing ?s ?d_new)\n                 (not (pointing ?s ?d_prev))))\n \n  (:action switch_on\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s) \n                      (power_avail ?s))\n   :effect (and (power_on ?i)\n                (not (calibrated ?i))\n                (not (power_avail ?s))))\n\n  (:action switch_off\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s)\n                      (power_on ?i))\n   :effect (and (not (power_on ?i))\n                (power_avail ?s)))\n\n  (:action calibrate\n   :parameters (?s - satellite ?i - instrument ?d - direction)\n   :precondition (and (on_board ?i ?s)\n\t\t      (calibration_target ?i ?d)\n                      (pointing ?s ?d)\n                      (power_on ?i))\n   :effect (calibrated ?i))\n\n  (:action take_image\n   :parameters (?s - satellite ?d - direction ?i - instrument ?m - mode)\n   :precondition (and (calibrated ?i)\n                      (on_board ?i ?s)\n                      (supports ?i ?m)\n                      (power_on ?i)\n                      (pointing ?s ?d))\n   :effect (have_image ?d ?m)))\n\n",
        "batch_id": 2,
        "id": 89,
        "tokens": 5489,
        "corrected_description": "### General\nThis domain models a satellite system where satellites can turn to point in different directions, switch instruments on and off, calibrate instruments, and take images in various modes. The goal is to manage the satellite's operations to ensure it captures required images while managing its power and instrument calibration.\n\n### Types\n- **satellite**: Represents the satellites in the domain.\n- **direction**: Represents the directions in which the satellite can point.\n- **instrument**: Represents the instruments onboard the satellite.\n- **mode**: Represents the modes in which the satellite can capture images.\n\n### Predicates\n- **(on_board ?i - instrument ?s - satellite)**: Indicates that instrument ?i is on board satellite ?s.\n- **(supports ?i - instrument ?m - mode)**: Indicates that instrument ?i supports capturing images in mode ?m.\n- **(pointing ?s - satellite ?d - direction)**: Indicates that satellite ?s is pointing in direction ?d.\n- **(power_avail ?s - satellite)**: Indicates that there is power available on satellite ?s.\n- **(power_on ?i - instrument)**: Indicates that instrument ?i is powered on.\n- **(calibrated ?i - instrument)**: Indicates that instrument ?i is calibrated.\n- **(have_image ?d - direction ?m - mode)**: Indicates that an image has been captured in direction ?d in mode ?m.\n- **(calibration_target ?i - instrument ?d - direction)**: Indicates that direction ?d is a calibration target for instrument ?i.\n\n### Actions\n- **turn_to <?s> <?d_new> <?d_prev>**: Allows a satellite to turn from one direction to another. \n  \n- **switch_on <?i> <?s>**: Allows turning on an instrument on a satellite. \n  \n- **switch_off <?i> <?s>**: Allows turning off an instrument on a satellite. \n  \n- **calibrate <?s> <?i> <?d>**: Allows calibrating an instrument on a satellite if the instrument is on board, the satellite is pointing at the calibration target, and the instrument is powered on. The effect is that the instrument is calibrated.\n  \n- **take_image <?s> <?d> <?i> <?m>**: Allows a satellite to take an image in a specific direction and mode if the instrument is calibrated, on board, supports the mode, is powered on, and the satellite is pointing in the direction. The effect is that an image has been captured in the specified direction and mode.",
        "pddl_domain_processed": "(define (domain satellite)\n  (:requirements :strips :typing)\n  (:types satellite direction instrument mode)\n  (:predicates \n\t(on_board ?i - instrument ?s - satellite)\n\t(supports ?i - instrument ?m - mode)\n\t(pointing ?s - satellite ?d - direction)\n\t(power_avail ?s - satellite)\n\t(power_on ?i - instrument)\n\t(calibrated ?i - instrument)\n\t(have_image ?d - direction ?m - mode)\n\t(calibration_target ?i - instrument ?d - direction))\n\n  (:action turn_to\n   :parameters (?s - satellite ?d_new - direction ?d_prev - direction)\n   :precondition (and (pointing ?s ?d_prev))\n   :effect (and  (pointing ?s ?d_new)\n                 (not (pointing ?s ?d_prev))))\n\n  (:action switch_on\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s) \n                      (power_avail ?s))\n   :effect (and (power_on ?i)\n                (not (calibrated ?i))\n                (not (power_avail ?s))))\n\n  (:action switch_off\n   :parameters (?i - instrument ?s - satellite)\n   :precondition (and (on_board ?i ?s)\n                      (power_on ?i))\n   :effect (and (not (power_on ?i))\n                (power_avail ?s)))\n\n  (:action calibrate\n   :parameters (?s - satellite ?i - instrument ?d - direction)\n   :precondition (and (on_board ?i ?s)\n\t\t      (calibration_target ?i ?d)\n                      (pointing ?s ?d)\n                      (power_on ?i))\n   :effect (calibrated ?i))\n\n  (:action take_image\n   :parameters (?s - satellite ?d - direction ?i - instrument ?m - mode)\n   :precondition (and (calibrated ?i)\n                      (on_board ?i ?s)\n                      (supports ?i ?m)\n                      (power_on ?i)\n                      (pointing ?s ?d))\n   :effect (have_image ?d ?m)))\n\n"
    },
    {
        "file_name": "spider",
        "pddl_domain": "(define (domain spider)\n    (:requirements :typing :conditional-effects :action-costs :negative-preconditions)\n    (:types\n        cardposition - object\n\tcard_or_tableau - cardposition\n        card - card_or_tableau\n        tableau - card_or_tableau\n        deal - cardposition\n    )\n\n    (:constants\n        discard - cardposition\n    )\n\n; Each deal, deal-i, is represented by a list of cards where the card going to pile-0 is\n;   clear and the last card is placed on deal-i.  Moreover, TO-DEAL stores the information\n;   of on which deal each card must be placed.  TO-DEAL and on have redundant\n;   information. This is done this way because TO-DEAL is static, reducing the number of\n;   instantiations of the deal-card schema. On is used on top of TO-DEAL for cards in the\n;   deal so that cards are always somewhere.\n\n    (:predicates\n        (on ?c1 - card ?c2 - cardposition)\n        (clear ?c - cardposition)\n        (in-play ?c - card)\n        (current-deal ?d - deal)\n        ;\n        ; static predicates\n        (CAN-CONTINUE-GROUP ?c1 - card ?c2 - cardposition)\n        (CAN-BE-PLACED-ON ?c1 - card ?c2 - card)\n        (IS-ACE ?c - card)\n        (IS-KING ?c - card)\n        (NEXT-DEAL ?d ?nd - deal)\n        (TO-DEAL ?c - card ?p - tableau ?d - deal ?next - cardposition)\n        ;\n        ; control flags for dealing\n        (currently-dealing)\n        ;\n        ; control flags for collecting cards\n        (currently-collecting-deck)\n        (collect-card ?c - cardposition)\n        ;\n        ; derived predicates\n        (part-of-tableau ?c - cardposition ?t - tableau)\n        (movable ?c - card)\n        ;\n        ; control flags for derived predicates\n        (currently-updating-unmovable)\n        (make-unmovable ?c - card)\n        (currently-updating-movable)\n        (make-movable ?c - cardposition)\n        (currently-updating-part-of-tableau)\n        (make-part-of-tableau ?c - card ?t - tableau)\n    )\n    (:functions (total-cost) - number)\n\n    (:action start-dealing\n        :parameters ()\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (not (currently-dealing))\n        )\n        :effect (and\n            (currently-dealing)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action deal-card\n        :parameters (?c - card  ?from - cardposition ?fromdeal - deal ?to - card ?totableau - tableau)\n        :precondition (and\n            (currently-dealing)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (current-deal ?fromdeal)\n            (TO-DEAL ?c ?totableau ?fromdeal ?from)\n            (clear ?c)\n            (on ?c ?from)\n            (part-of-tableau ?to ?totableau)\n            (clear ?to)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (in-play ?c)\n            (part-of-tableau ?c ?totableau)\n            (movable ?c)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?to))\n                (and (currently-updating-unmovable) (make-unmovable ?to))\n            )\n        )\n    )\n\n    (:action finish-dealing\n        :parameters (?d ?nd - deal)\n        :precondition (and\n            (currently-dealing)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (current-deal ?d)\n            (clear ?d)\n            (NEXT-DEAL ?d ?nd)\n        )\n        :effect (and\n            (not (currently-dealing))\n            (not (current-deal ?d))\n            (current-deal ?nd)\n        )\n    )\n\n    (:action move-to-card\n        :parameters (?c - card ?from - card_or_tableau ?to - card ?totableau - tableau)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (movable ?c)\n            (in-play ?c)\n            (clear ?to)\n            (in-play ?to)\n            (part-of-tableau ?to ?totableau)\n            (CAN-BE-PLACED-ON ?c ?to)\n            (on ?c ?from)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?from))\n                (and (currently-updating-movable) (make-movable ?from))\n            )\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?to))\n                (and (currently-updating-unmovable) (make-unmovable ?to))\n            )\n            (currently-updating-part-of-tableau)\n            (make-part-of-tableau ?c ?totableau)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action move-to-tableau\n        :parameters (?c - card ?from - card_or_tableau ?to - tableau)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (movable ?c)\n            (in-play ?c)\n            (clear ?to)\n            (on ?c ?from)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?from))\n                (and (currently-updating-movable) (make-movable ?from))\n            )\n            (currently-updating-part-of-tableau)\n            (make-part-of-tableau ?c ?to)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action change-tableau-and-continue\n        :parameters (?c - card ?tbefore - tableau ?t - tableau ?next - card)\n        :precondition (and\n            (currently-updating-part-of-tableau)\n            (not (currently-collecting-deck))\n            (on ?next ?c)\n            (make-part-of-tableau ?c ?t)\n            (part-of-tableau ?c ?tbefore)\n        )\n        :effect (and\n            (not (part-of-tableau ?c ?tbefore))\n            (part-of-tableau ?c ?t)\n            (not  (make-part-of-tableau ?c ?t))\n            (make-part-of-tableau ?next ?t)\n        )\n    )\n\n    (:action change-tableau-and-stop\n        :parameters (?c - card ?tbefore - tableau ?t - tableau)\n        :precondition (and\n            (currently-updating-part-of-tableau)\n            (not (currently-collecting-deck))\n            (make-part-of-tableau ?c ?t)\n            (part-of-tableau ?c ?tbefore)\n            (clear ?c)\n        )\n        :effect (and\n            (not (part-of-tableau ?c ?tbefore))\n            (part-of-tableau ?c ?t)\n            (not  (make-part-of-tableau ?c ?t))\n            (not (currently-updating-part-of-tableau))\n        )\n    )\n\n    (:action make-unmovable-and-continue\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?nextcard)\n            (make-unmovable ?c)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n            (movable ?nextcard)\n        )\n        :effect (and\n            (not (movable ?c))\n            (make-unmovable ?nextcard)\n            (not (make-unmovable ?c))\n        )\n    )\n\n    (:action make-unmovable-and-stop-at-tableau\n        :parameters (?c - card ?t - tableau)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?t)\n            (make-unmovable ?c)\n        )\n        :effect (and\n            (not (movable ?c))\n            (not (make-unmovable ?c))\n            (not (currently-updating-unmovable))\n        )\n    )\n\n    (:action make-unmovable-and-stop-at-unmovable\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?nextcard)\n            (make-unmovable ?c)\n            (not (movable ?nextcard))\n        )\n        :effect (and\n            (not (movable ?c))\n            (not (make-unmovable ?c))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n        )\n    )\n\n    (:action make-movable-and-continue\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (on ?c ?nextcard)\n            (make-movable ?c)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n        )\n        :effect (and\n            (make-movable ?nextcard)\n            (not  (make-movable ?c))\n            (movable ?c)\n        )\n    )\n\n    (:action make-movable-ignore-pile\n        :parameters (?p - tableau)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (make-movable ?p)\n        )\n        :effect (and\n            (not (make-movable ?p))\n            (not (currently-updating-movable))\n        )\n    )\n\n    (:action make-movable-and-stop\n        :parameters (?c - card ?nextcard - cardposition)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (on ?c ?nextcard)\n            (make-movable ?c)\n            (not (CAN-CONTINUE-GROUP ?c ?nextcard))\n        )\n        :effect (and\n            (not (make-movable ?c))\n            (not (currently-updating-movable))\n            (movable ?c)\n        )\n    )\n\n    (:action start-collecting-deck\n        :parameters (?c - card)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (not (currently-dealing))\n            (clear ?c)\n            (IS-ACE ?c)\n            (in-play ?c)\n        )\n        :effect (and\n            (currently-collecting-deck)\n            (collect-card ?c)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action collect-card\n        :parameters (?c - card ?nextcard - cardposition ?p - tableau)\n        :precondition (and\n            (currently-collecting-deck)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (collect-card ?c)\n            (on ?c ?nextcard)\n            (in-play ?c)\n            (part-of-tableau ?c ?p)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n        )\n        :effect (and\n            (not (on ?c ?nextcard))\n            (on ?c discard)\n            (clear ?nextcard)\n            (not (in-play ?c))\n            (not (part-of-tableau ?c ?p))\n            (not (movable ?c))\n            (not (collect-card ?c))\n            (collect-card ?nextcard)\n        )\n    )\n\n    (:action finish-collecting-deck\n        :parameters (?c - card ?nextcard - cardposition ?p - tableau)\n        :precondition (and\n            (currently-collecting-deck)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (on ?c ?nextcard)\n            (collect-card ?c)\n            (IS-KING ?c)\n            (in-play ?c)\n            (part-of-tableau ?c ?p)\n        )\n        :effect (and\n            (not (on ?c ?nextcard))\n            (on ?c discard)\n            (clear ?nextcard)\n            (not (in-play ?c))\n            (not (part-of-tableau ?c ?p))\n            (not (movable ?c))\n            (not (collect-card ?c))\n            (not (currently-collecting-deck))\n            (make-movable ?nextcard)\n            (currently-updating-movable)\n        )\n    )\n\n)\n",
        "batch_id": 2,
        "id": 91,
        "tokens": 8584,
        "corrected_description": "### General\nThis domain models a solitaire-like card game involving a spider solitaire setup. It includes actions for dealing cards, moving cards between tableaus, making cards movable or unmovable, and collecting a deck from Ace to King. The domain supports conditional effects, action costs, and negative preconditions, which are essential for accurately representing the game's rules and mechanics.\n\n### Types\n- **cardposition**: The base type for all positions a card can be in.\n- **card_or_tableau**: A subtype of cardposition, representing either a card or a tableau.\n- **card**: A subtype of card_or_tableau, representing individual cards.\n- **tableau**: A subtype of card_or_tableau, representing groups of cards in a layout.\n- **deal**: A subtype of cardposition, representing the deal positions from where cards are dealt.\n\n### Predicates\n- **(on ?c1 - card ?c2 - cardposition)**: Indicates that card ?c1 is on cardposition ?c2.\n- **(clear ?c - cardposition)**: Indicates that cardposition ?c is clear of any cards on top of it.\n- **(in-play ?c - card)**: Indicates that card ?c is in play.\n- **(current-deal ?d - deal)**: Indicates the current deal being processed.\n- **(CAN-CONTINUE-GROUP ?c1 - card ?c2 - cardposition)**: Static predicate to check if a card can continue a group with another cardposition.\n- **(CAN-BE-PLACED-ON ?c1 - card ?c2 - card)**: Static predicate to check if a card can be placed on another card.\n- **(IS-ACE ?c - card)**: Static predicate to check if a card is an Ace.\n- **(IS-KING ?c - card)**: Static predicate to check if a card is a King.\n- **(NEXT-DEAL ?d ?nd - deal)**: Static predicate to indicate the next deal in sequence.\n- **(TO-DEAL ?c - card ?p - tableau ?d - deal ?next - cardposition)**: Static predicate indicating where a card should be dealt.\n- **(currently-dealing)**: Control flag indicating that dealing is currently happening.\n- **(currently-collecting-deck)**: Control flag indicating that a deck is being collected.\n- **(collect-card ?c - cardposition)**: Indicates that cardposition ?c is being collected.\n- **(part-of-tableau ?c - cardposition ?t - tableau)**: Derived predicate indicating that cardposition ?c is part of tableau ?t.\n- **(movable ?c - card)**: Derived predicate indicating that card ?c is movable.\n- **(make-unmovable ?c - card)**, **(make-movable ?c - cardposition)**, **(make-part-of-tableau ?c - card ?t - tableau)**: Control flags for updating the status of cards.\n\n### Actions\n- **start-dealing**: Begins the dealing process, ensuring no other major actions are currently happening.  \n\n- **deal-card <?c> <?from> <?fromdeal> <?to> <?totableau>**: Deals a card from a deal to a tableau or card, updating the clear status and in-play status of the involved cards.  \n\n- **finish-dealing <?d> <?nd>**: Marks the end of a dealing process, updating the current deal.  \n\n- **move-to-card <?c> <?from> <?to>**: Moves a card to another card or tableau, applying conditional effects based on the ability to continue groups.  \n\n- **move-to-tableau <?c> <?from> <?to>**: This action moves a card to a tableau.  \n\n- **change-tableau-and-continue<?c> <?tbefore> <?t> <?next>**: This action changes the tableau association of a card and continues processing.  \n\n- **change-tableau-and-stop <?c> <?tbefore> <?t>**: This action updates the tableau association of a card and stops further processing.  \n\n- **make-unmovable-and-continue <?c> <?nextcard>**: This action marks a card as unmovable and continues processing.  \n\n- **make-unmovable-and-stop-at-tableau <?c> <?t>**: This action marks a card as unmovable and stops processing at a tableau.  \n\n- **make-unmovable-and-stop-at-unmovable <?c> <?nextcard>**: This action marks a card as unmovable and stops processing if the next card is also unmovable.  \n\n- **make-movable-and-continue <?c> <?nextcard>**: This action marks a card as movable and continues processing.  \n\n- **make-movable-ignore-pile <?p>**: This action marks a tableau as movable and ignores the pile.  \n\n- **make-movable-and-stop <?c> <?nextcard>**: This action marks a card as movable and stops further processing if the next card does not continue the group.  \n\n- **start-collecting-deck <?c>**: This action begins the process of collecting a deck starting with an Ace.  \n\n- **collect-card <?c> <?nextcard>**: This action collects a card as part of deck collection.  \n\n- **finish-collecting-deck <?c> <?nextcard>**: This action completes the deck collection process with the King.",
        "pddl_domain_processed": "(define (domain spider)\n    (:requirements :typing :conditional-effects :action-costs :negative-preconditions)\n    (:types\n        cardposition - object\n\tcard_or_tableau - cardposition\n        card - card_or_tableau\n        tableau - card_or_tableau\n        deal - cardposition\n    )\n\n    (:constants\n        discard - cardposition\n    )\n\n    (:predicates\n        (on ?c1 - card ?c2 - cardposition)\n        (clear ?c - cardposition)\n        (in-play ?c - card)\n        (current-deal ?d - deal)\n\n        (CAN-CONTINUE-GROUP ?c1 - card ?c2 - cardposition)\n        (CAN-BE-PLACED-ON ?c1 - card ?c2 - card)\n        (IS-ACE ?c - card)\n        (IS-KING ?c - card)\n        (NEXT-DEAL ?d ?nd - deal)\n        (TO-DEAL ?c - card ?p - tableau ?d - deal ?next - cardposition)\n\n        (currently-dealing)\n\n        (currently-collecting-deck)\n        (collect-card ?c - cardposition)\n\n        (part-of-tableau ?c - cardposition ?t - tableau)\n        (movable ?c - card)\n\n        (currently-updating-unmovable)\n        (make-unmovable ?c - card)\n        (currently-updating-movable)\n        (make-movable ?c - cardposition)\n        (currently-updating-part-of-tableau)\n        (make-part-of-tableau ?c - card ?t - tableau)\n    )\n    (:functions (total-cost) - number)\n\n    (:action start-dealing\n        :parameters ()\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (not (currently-dealing))\n        )\n        :effect (and\n            (currently-dealing)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action deal-card\n        :parameters (?c - card  ?from - cardposition ?fromdeal - deal ?to - card ?totableau - tableau)\n        :precondition (and\n            (currently-dealing)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (current-deal ?fromdeal)\n            (TO-DEAL ?c ?totableau ?fromdeal ?from)\n            (clear ?c)\n            (on ?c ?from)\n            (part-of-tableau ?to ?totableau)\n            (clear ?to)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (in-play ?c)\n            (part-of-tableau ?c ?totableau)\n            (movable ?c)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?to))\n                (and (currently-updating-unmovable) (make-unmovable ?to))\n            )\n        )\n    )\n\n    (:action finish-dealing\n        :parameters (?d ?nd - deal)\n        :precondition (and\n            (currently-dealing)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (current-deal ?d)\n            (clear ?d)\n            (NEXT-DEAL ?d ?nd)\n        )\n        :effect (and\n            (not (currently-dealing))\n            (not (current-deal ?d))\n            (current-deal ?nd)\n        )\n    )\n\n    (:action move-to-card\n        :parameters (?c - card ?from - card_or_tableau ?to - card ?totableau - tableau)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (movable ?c)\n            (in-play ?c)\n            (clear ?to)\n            (in-play ?to)\n            (part-of-tableau ?to ?totableau)\n            (CAN-BE-PLACED-ON ?c ?to)\n            (on ?c ?from)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?from))\n                (and (currently-updating-movable) (make-movable ?from))\n            )\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?to))\n                (and (currently-updating-unmovable) (make-unmovable ?to))\n            )\n            (currently-updating-part-of-tableau)\n            (make-part-of-tableau ?c ?totableau)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action move-to-tableau\n        :parameters (?c - card ?from - card_or_tableau ?to - tableau)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (movable ?c)\n            (in-play ?c)\n            (clear ?to)\n            (on ?c ?from)\n        )\n        :effect (and\n            (not (on ?c ?from))\n            (on ?c ?to)\n            (not (clear ?to))\n            (clear ?from)\n            (when\n                (not (CAN-CONTINUE-GROUP ?c ?from))\n                (and (currently-updating-movable) (make-movable ?from))\n            )\n            (currently-updating-part-of-tableau)\n            (make-part-of-tableau ?c ?to)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action change-tableau-and-continue\n        :parameters (?c - card ?tbefore - tableau ?t - tableau ?next - card)\n        :precondition (and\n            (currently-updating-part-of-tableau)\n            (not (currently-collecting-deck))\n            (on ?next ?c)\n            (make-part-of-tableau ?c ?t)\n            (part-of-tableau ?c ?tbefore)\n        )\n        :effect (and\n            (not (part-of-tableau ?c ?tbefore))\n            (part-of-tableau ?c ?t)\n            (not  (make-part-of-tableau ?c ?t))\n            (make-part-of-tableau ?next ?t)\n        )\n    )\n\n    (:action change-tableau-and-stop\n        :parameters (?c - card ?tbefore - tableau ?t - tableau)\n        :precondition (and\n            (currently-updating-part-of-tableau)\n            (not (currently-collecting-deck))\n            (make-part-of-tableau ?c ?t)\n            (part-of-tableau ?c ?tbefore)\n            (clear ?c)\n        )\n        :effect (and\n            (not (part-of-tableau ?c ?tbefore))\n            (part-of-tableau ?c ?t)\n            (not  (make-part-of-tableau ?c ?t))\n            (not (currently-updating-part-of-tableau))\n        )\n    )\n\n    (:action make-unmovable-and-continue\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?nextcard)\n            (make-unmovable ?c)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n            (movable ?nextcard)\n        )\n        :effect (and\n            (not (movable ?c))\n            (make-unmovable ?nextcard)\n            (not (make-unmovable ?c))\n        )\n    )\n\n    (:action make-unmovable-and-stop-at-tableau\n        :parameters (?c - card ?t - tableau)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?t)\n            (make-unmovable ?c)\n        )\n        :effect (and\n            (not (movable ?c))\n            (not (make-unmovable ?c))\n            (not (currently-updating-unmovable))\n        )\n    )\n\n    (:action make-unmovable-and-stop-at-unmovable\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-unmovable)\n            (not (currently-collecting-deck))\n            (not (currently-updating-part-of-tableau))\n            (on ?c ?nextcard)\n            (make-unmovable ?c)\n            (not (movable ?nextcard))\n        )\n        :effect (and\n            (not (movable ?c))\n            (not (make-unmovable ?c))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n        )\n    )\n\n    (:action make-movable-and-continue\n        :parameters (?c - card ?nextcard - card)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (on ?c ?nextcard)\n            (make-movable ?c)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n        )\n        :effect (and\n            (make-movable ?nextcard)\n            (not  (make-movable ?c))\n            (movable ?c)\n        )\n    )\n\n    (:action make-movable-ignore-pile\n        :parameters (?p - tableau)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (make-movable ?p)\n        )\n        :effect (and\n            (not (make-movable ?p))\n            (not (currently-updating-movable))\n        )\n    )\n\n    (:action make-movable-and-stop\n        :parameters (?c - card ?nextcard - cardposition)\n        :precondition (and\n            (currently-updating-movable)\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (on ?c ?nextcard)\n            (make-movable ?c)\n            (not (CAN-CONTINUE-GROUP ?c ?nextcard))\n        )\n        :effect (and\n            (not (make-movable ?c))\n            (not (currently-updating-movable))\n            (movable ?c)\n        )\n    )\n\n    (:action start-collecting-deck\n        :parameters (?c - card)\n        :precondition (and\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-collecting-deck))\n            (not (currently-dealing))\n            (clear ?c)\n            (IS-ACE ?c)\n            (in-play ?c)\n        )\n        :effect (and\n            (currently-collecting-deck)\n            (collect-card ?c)\n            (increase (total-cost) 1)\n        )\n    )\n\n    (:action collect-card\n        :parameters (?c - card ?nextcard - cardposition ?p - tableau)\n        :precondition (and\n            (currently-collecting-deck)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (collect-card ?c)\n            (on ?c ?nextcard)\n            (in-play ?c)\n            (part-of-tableau ?c ?p)\n            (CAN-CONTINUE-GROUP ?c ?nextcard)\n        )\n        :effect (and\n            (not (on ?c ?nextcard))\n            (on ?c discard)\n            (clear ?nextcard)\n            (not (in-play ?c))\n            (not (part-of-tableau ?c ?p))\n            (not (movable ?c))\n            (not (collect-card ?c))\n            (collect-card ?nextcard)\n        )\n    )\n\n    (:action finish-collecting-deck\n        :parameters (?c - card ?nextcard - cardposition ?p - tableau)\n        :precondition (and\n            (currently-collecting-deck)\n            (not (currently-updating-movable))\n            (not (currently-updating-unmovable))\n            (not (currently-updating-part-of-tableau))\n            (not (currently-dealing))\n            (on ?c ?nextcard)\n            (collect-card ?c)\n            (IS-KING ?c)\n            (in-play ?c)\n            (part-of-tableau ?c ?p)\n        )\n        :effect (and\n            (not (on ?c ?nextcard))\n            (on ?c discard)\n            (clear ?nextcard)\n            (not (in-play ?c))\n            (not (part-of-tableau ?c ?p))\n            (not (movable ?c))\n            (not (collect-card ?c))\n            (not (currently-collecting-deck))\n            (make-movable ?nextcard)\n            (currently-updating-movable)\n        )\n    )\n\n)\n"
    },
    {
        "file_name": "spanner",
        "pddl_domain": "(define (domain spanner)                    \n(:requirements :typing :strips)                \n(:types \n\tlocation locatable - object\n\tman nut spanner - locatable\t\n)                                           \n                                                                               \n(:predicates \n\t(at ?m - locatable ?l - location)\n\t(carrying ?m - man ?s - spanner)\n\t(useable ?s - spanner)\n\t(link ?l1 - location ?l2 - location)\n\t(tightened ?n - nut)\n\t(loose ?n - nut))                                                                                           \n(:action walk \n        :parameters (?start - location ?end - location ?m - man)\n        :precondition (and (at ?m ?start) \n                           (link ?start ?end))                                                          \n        :effect (and (not (at ?m ?start)) (at ?m ?end)))\n\n(:action pickup_spanner \n        :parameters (?l - location ?s - spanner ?m - man)\n        :precondition (and (at ?m ?l) \n                           (at ?s ?l))\n        :effect (and (not (at ?s ?l))\n                     (carrying ?m ?s)))\n\n(:action tighten_nut \n        :parameters (?l - location ?s - spanner ?m - man ?n - nut)\n        :precondition (and (at ?m ?l) \n\t\t      \t   (at ?n ?l)\n\t\t\t   (carrying ?m ?s)\n\t\t\t   (useable ?s)\n\t\t\t   (loose ?n))\n        :effect (and (not (loose ?n))(not (useable ?s)) (tightened ?n)))\n)",
        "batch_id": 2,
        "id": 92,
        "tokens": 5311,
        "corrected_description": "### General\nThis domain involves a scenario where a man can walk between locations, pick up a spanner, and use it to tighten nuts. The domain models the actions of moving between linked locations, picking up a spanner that is in the same location as the man, and using the spanner to tighten loose nuts. The spanner becomes unusable after tightening a nut.\n\n### Types\n- **location**: Represents different places the man can be or move to.\n- **locatable**: A general type for objects that can have a location, including the man, nuts, and spanners.\n- **man**: Represents the person who can carry a spanner and tighten nuts.\n- **nut**: Represents nuts that can be either tightened or loose.\n- **spanner**: Represents spanners that can be used to tighten nuts and can be carried by the man.\n\n### Predicates\n- **(at ?m - locatable ?l - location)**: Indicates that a locatable object (?m) is at a specific location (?l).\n- **(carrying ?m - man ?s - spanner)**: Indicates that the man (?m) is carrying a spanner (?s).\n- **(useable ?s - spanner)**: Indicates that a spanner (?s) is useable.\n- **(link ?l1 - location ?l2 - location)**: Indicates that two locations (?l1 and ?l2) are directly connected and one can walk between them.\n- **(tightened ?n - nut)**: Indicates that a nut (?n) has been tightened.\n- **(loose ?n - nut)**: Indicates that a nut (?n) is loose and needs to be tightened.\n\n### Actions\n- **walk <?start> <?end> <?m>**: This action moves a man from one location to another.  \n  \n- **pickup_spanner <?l> <?s> <?m>**: This action allows a man to pick up a spanner from a location.  \n  \n- **tighten_nut <?l> <?s> <?m> <?n>**: Allows the man to tighten a loose nut using a useable spanner he is carrying, at the same location as the nut.",
        "pddl_domain_processed": "(define (domain spanner)                    \n(:requirements :typing :strips)                \n(:types \n\tlocation locatable - object\n\tman nut spanner - locatable\t\n)                                           \n\n(:predicates \n\t(at ?m - locatable ?l - location)\n\t(carrying ?m - man ?s - spanner)\n\t(useable ?s - spanner)\n\t(link ?l1 - location ?l2 - location)\n\t(tightened ?n - nut)\n\t(loose ?n - nut))                                                                                           \n(:action walk \n        :parameters (?start - location ?end - location ?m - man)\n        :precondition (and (at ?m ?start) \n                           (link ?start ?end))                                                          \n        :effect (and (not (at ?m ?start)) (at ?m ?end)))\n\n(:action pickup_spanner \n        :parameters (?l - location ?s - spanner ?m - man)\n        :precondition (and (at ?m ?l) \n                           (at ?s ?l))\n        :effect (and (not (at ?s ?l))\n                     (carrying ?m ?s)))\n\n(:action tighten_nut \n        :parameters (?l - location ?s - spanner ?m - man ?n - nut)\n        :precondition (and (at ?m ?l) \n\t\t      \t   (at ?n ?l)\n\t\t\t   (carrying ?m ?s)\n\t\t\t   (useable ?s)\n\t\t\t   (loose ?n))\n        :effect (and (not (loose ?n))(not (useable ?s)) (tightened ?n)))\n)"
    },
    {
        "file_name": "maintenance",
        "pddl_domain": "; There are mechanics who on any day may work at one\n; of several cities where the airplane maintenance\n; company has facilities. There are airplanes each of\n; which has to be maintained during the given time period.\n; The airplanes are guaranteed to visit some of the cities\n; on given days. The problem is to schedule the presence\n; of the mechanics so that each plane will get maintenance.\n\n(define (domain maintenance-scheduling-domain)\n (:requirements :adl :typing :conditional-effects)\n (:types plane day airport)\n (:predicates  (done ?p - plane)\n  (today ?d - day)\n  (at ?p - plane ?d - day ?c - airport)\n  (next ?d - day ?d2 - day) )\n\n (:action workat\n  :parameters (?day - day ?airport - airport)\n  :precondition (today ?day)\n  :effect (and\n     (not (today ?day))\n     (forall (?plane - plane) (when (at ?plane ?day ?airport) (done ?plane)))))\n\n)\n",
        "batch_id": 2,
        "id": 93,
        "tokens": 4957,
        "corrected_description": "### General\nThis domain is designed for scheduling maintenance for airplanes by assigning mechanics to various airports on specific days. The goal is to ensure that each airplane receives maintenance at an airport on the day it is scheduled to be there.\n\n### Types\n- **plane**: Represents the airplanes that require maintenance.\n- **day**: Represents the days within the scheduling period.\n- **airport**: Represents the locations where maintenance can be performed.\n\n### Predicates\n- **(done ?p - plane)**: Indicates that maintenance has been completed on plane ?p.\n- **(today ?d - day)**: Indicates that the current day is ?d.\n- **(at ?p - plane ?d - day ?c - airport)**: Indicates that plane ?p is at airport ?c on day ?d.\n- **(next ?d - day ?d2 - day)**: Represents the sequence of days, where ?d2 is the day following ?d.\n\n### Actions\n**workat <?day> <?airport>**: Assigns mechanics to work at a specific airport on a given day.",
        "pddl_domain_processed": "\n\n(define (domain maintenance-scheduling-domain)\n (:requirements :adl :typing :conditional-effects)\n (:types plane day airport)\n (:predicates  (done ?p - plane)\n  (today ?d - day)\n  (at ?p - plane ?d - day ?c - airport)\n  (next ?d - day ?d2 - day) )\n\n (:action workat\n  :parameters (?day - day ?airport - airport)\n  :precondition (today ?day)\n  :effect (and\n     (not (today ?day))\n     (forall (?plane - plane) (when (at ?plane ?day ?airport) (done ?plane)))))\n\n)\n"
    },
    {
        "file_name": "briefcaseworld",
        "pddl_domain": "(define (domain briefcase)\n(:requirements :adl)\n(:types portable location)\n(:predicates (at ?y - portable ?x - location)\n             (in ?x - portable)\n             (is-at ?x - location))\n\n\n(:action move\n  :parameters (?m ?l - location)\n  :precondition  (is-at ?m)\n  :effect (and (is-at ?l) (not (is-at ?m))\n\t\t    (forall (?x - portable) (when (in ?x)\n\t\t      (and (at ?x ?l) (not (at ?x ?m)))))))\n\n  (:action take-out\n      :parameters (?x - portable)\n      :precondition (in ?x)\n      :effect (not (in ?x)))\n      \n  (:action put-in\n      :parameters (?x - portable ?l - location)\n      :precondition (and (not (in ?x)) (at ?x ?l) (is-at ?l))\n      :effect (in ?x)))\n\n",
        "batch_id": 2,
        "id": 95,
        "tokens": 5113,
        "corrected_description": "### General\nThis domain models the actions of moving a briefcase between locations and managing portable items by taking them out or putting them in the briefcase. The goal is to manipulate the location of portable items and the briefcase itself to achieve a desired configuration.\n\n### Types\n- **portable**: Represents items that can be moved around and placed inside the briefcase.\n- **location**: Represents different places where the briefcase and portable items can be located.\n\n### Predicates\n- **(at ?y - portable ?x - location)**: Indicates that the portable item ?y is at location ?x.\n- **(in ?x - portable)**: Indicates that the portable item ?x is inside the briefcase.\n- **(is-at ?x - location)**: Indicates that the briefcase is at location ?x.\n\n### Actions\n- **move <?m> <?l>**: Allows the briefcase to be moved from its current location to a new location.  \n\n- **take-out <?x>**: Allows a portable item to be taken out of the briefcase.  \n\n- **put-in <?x> <?l>**: Allows a portable item to be put inside the briefcase, assuming the item is at the same location as the briefcase and not already inside.",
        "pddl_domain_processed": "(define (domain briefcase)\n(:requirements :adl)\n(:types portable location)\n(:predicates (at ?y - portable ?x - location)\n             (in ?x - portable)\n             (is-at ?x - location))\n\n(:action move\n  :parameters (?m ?l - location)\n  :precondition  (is-at ?m)\n  :effect (and (is-at ?l) (not (is-at ?m))\n\t\t    (forall (?x - portable) (when (in ?x)\n\t\t      (and (at ?x ?l) (not (at ?x ?m)))))))\n\n  (:action take-out\n      :parameters (?x - portable)\n      :precondition (in ?x)\n      :effect (not (in ?x)))\n\n  (:action put-in\n      :parameters (?x - portable ?l - location)\n      :precondition (and (not (in ?x)) (at ?x ?l) (is-at ?l))\n      :effect (in ?x)))\n\n"
    },
    {
        "file_name": "nomystery",
        "pddl_domain": "(define (domain transport-strips)\n(:requirements :typing :action-costs)\n\n(:types location fuellevel locatable - object \n\tpackage truck - locatable\n)\n\n(:predicates \n(connected ?l1 ?l2 - location)\n(at ?o - locatable ?l - location)\n(in ?p - package ?t - truck)\n(fuel ?t - truck ?level - fuellevel)\n(fuelcost ?level - fuellevel ?l1 ?l2 - location)\n(sum ?a ?b ?c - fuellevel)\n)\n\n(:functions \n(total-cost) - number)\n\n(:action LOAD\n:parameters\n(?p - package\n?t - truck\n?l - location)\n:precondition\n(and (at ?t ?l) (at ?p ?l))\n:effect\n(and (not (at ?p ?l)) (in ?p ?t) (increase (total-cost) 1))\n)\n\n(:action UNLOAD\n:parameters\n(?p - package\n?t - truck\n?l - location)\n:precondition\n(and (at ?t ?l) (in ?p ?t))\n:effect\n(and (at ?p ?l) (not (in ?p ?t)) (increase (total-cost) 1))\n)\n\n(:action DRIVE\n:parameters\n(?t - truck\n?l1 - location\n?l2 - location\n?fuelpost - fuellevel\n?fueldelta - fuellevel\n?fuelpre - fuellevel)\n:precondition\n(and \n(connected ?l1 ?l2)\n(fuelcost ?fueldelta ?l1 ?l2)\n(fuel ?t ?fuelpre)\n(sum ?fuelpost ?fueldelta ?fuelpre)\n(at ?t ?l1)\n)\n:effect\n(and (not (at ?t ?l1)) \n     (at ?t ?l2) \n     (not (fuel ?t ?fuelpre)) \n     (fuel ?t ?fuelpost)\n     (increase (total-cost) 1))\n)\n\n)\n\n\n",
        "batch_id": 2,
        "id": 96,
        "tokens": 5529,
        "corrected_description": "### General\nThis domain models a transportation system where trucks move packages between different locations. The system accounts for fuel levels in trucks and the cost associated with actions. The goal is to efficiently transport packages while managing fuel consumption and minimizing total action costs.\n\n### Types\n- **location**: Represents different places where packages can be picked up or delivered.\n- **fuellevel**: Represents different levels of fuel that a truck can have.\n- **locatable**: A general type for objects that can be located at a location. This includes both packages and trucks.\n- **package**: Represents items that need to be transported.\n- **truck**: Represents vehicles used for transporting packages.\n\n### Predicates\n- **(connected ?l1 ?l2 - location)**: Indicates that location ?l1 is directly connected to location ?l2, allowing trucks to travel between them.\n- **(at ?o - locatable ?l - location)**: Indicates that a locatable object (either a package or a truck) is at a specific location.\n- **(in ?p - package ?t - truck)**: Indicates that package ?p is loaded in truck ?t.\n- **(fuel ?t - truck ?level - fuellevel)**: Indicates the current fuel level of truck ?t.\n- **(fuelcost ?level - fuellevel ?l1 ?l2 - location)**: Represents the fuel cost for a truck to travel from location ?l1 to location ?l2.\n- **(sum ?a ?b ?c - fuellevel)**: A helper predicate used to calculate the new fuel level after a truck moves or performs an action.\n\n### Functions\n- **(total-cost) - number**: Represents the total cost incurred from performing actions. This is used to track the efficiency of the transportation plan.\n\n### Actions\n- **LOAD <?p> <?t> <?l>**: Loads package <?p> into truck <?t> at location <?l>. This action increases the total cost by 1.  \n\n- **UNLOAD <?p> <?t> <?l>**: Unloads package <?p> from truck <?t> at location <?l>. This action also increases the total cost by 1.  \n\n- **DRIVE <?t> <?l1> <?l2> <?fuelpost> <?fueldelta> <?fuelpre>**: Moves truck <?t> from location <?l1> to location <?l2>, adjusting the fuel level according to the fuel cost of the trip. This action increases the total cost by 1.",
        "pddl_domain_processed": "(define (domain transport-strips)\n(:requirements :typing :action-costs)\n\n(:types location fuellevel locatable - object \n\tpackage truck - locatable\n)\n\n(:predicates \n(connected ?l1 ?l2 - location)\n(at ?o - locatable ?l - location)\n(in ?p - package ?t - truck)\n(fuel ?t - truck ?level - fuellevel)\n(fuelcost ?level - fuellevel ?l1 ?l2 - location)\n(sum ?a ?b ?c - fuellevel)\n)\n\n(:functions \n(total-cost) - number)\n\n(:action LOAD\n:parameters\n(?p - package\n?t - truck\n?l - location)\n:precondition\n(and (at ?t ?l) (at ?p ?l))\n:effect\n(and (not (at ?p ?l)) (in ?p ?t) (increase (total-cost) 1))\n)\n\n(:action UNLOAD\n:parameters\n(?p - package\n?t - truck\n?l - location)\n:precondition\n(and (at ?t ?l) (in ?p ?t))\n:effect\n(and (at ?p ?l) (not (in ?p ?t)) (increase (total-cost) 1))\n)\n\n(:action DRIVE\n:parameters\n(?t - truck\n?l1 - location\n?l2 - location\n?fuelpost - fuellevel\n?fueldelta - fuellevel\n?fuelpre - fuellevel)\n:precondition\n(and \n(connected ?l1 ?l2)\n(fuelcost ?fueldelta ?l1 ?l2)\n(fuel ?t ?fuelpre)\n(sum ?fuelpost ?fueldelta ?fuelpre)\n(at ?t ?l1)\n)\n:effect\n(and (not (at ?t ?l1)) \n     (at ?t ?l2) \n     (not (fuel ?t ?fuelpre)) \n     (fuel ?t ?fuelpost)\n     (increase (total-cost) 1))\n)\n\n)\n\n"
    },
    {
        "file_name": "blocksworld/3ops",
        "pddl_domain": "(define (domain blocksworld-3ops)\n(:predicates (clear ?x)\n             (on-table ?x)\n             (on ?x ?y))\n\n(:action move-b-to-b\n  :parameters (?bm ?bf ?bt)\n  :precondition (and (clear ?bm) (clear ?bt) (on ?bm ?bf))\n  :effect (and (not (clear ?bt)) (not (on ?bm ?bf))\n               (on ?bm ?bt) (clear ?bf)))\n\n(:action move-b-to-t\n  :parameters (?bm ?bf)\n  :precondition (and (clear ?bm) (on ?bm ?bf))\n  :effect (and (not (on ?bm ?bf))\n               (on-table ?bm) (clear ?bf)))\n\n(:action move-t-to-b\n  :parameters (?bm ?bt)\n  :precondition (and (clear ?bm) (clear ?bt) (on-table ?bm))\n  :effect (and (not (clear ?bt)) (not (on-table ?bm))\n               (on ?bm ?bt))))\n\n",
        "batch_id": 2,
        "id": 98,
        "tokens": 5075,
        "corrected_description": "### General\nThis domain represents a simplified version of the classic blocksworld problem, featuring a robot that can move blocks around. The robot can perform three types of actions: moving a block from another block to the table, moving a block from the table to another block, and moving a block from one block to another block. The domain assumes a world where blocks can be stacked on top of each other and placed on a table.\n\n### Predicates\n(clear ?x): Indicates that the top of block ?x is clear, with no other blocks on it.\n(on-table ?x): Indicates that block ?x is directly on the table.\n(on ?x ?y): Indicates that block ?x is directly on top of block ?y.\n\n### Actions\nmove-b-to-b <?bm> <?bf> <?bt>: Allows moving a block (?bm) from on top of another block (?bf) to on top of a third block (?bt). \n\nmove-b-to-t <?bm> <?bf>: Allows moving a block (?bm) from on top of another block (?bf) to the table. \n\nmove-t-to-b <?bm> <?bt>: Allows moving a block (?bm) from the table to on top of another block (?bt).",
        "pddl_domain_processed": "(define (domain blocksworld-3ops)\n(:predicates (clear ?x)\n             (on-table ?x)\n             (on ?x ?y))\n\n(:action move-b-to-b\n  :parameters (?bm ?bf ?bt)\n  :precondition (and (clear ?bm) (clear ?bt) (on ?bm ?bf))\n  :effect (and (not (clear ?bt)) (not (on ?bm ?bf))\n               (on ?bm ?bt) (clear ?bf)))\n\n(:action move-b-to-t\n  :parameters (?bm ?bf)\n  :precondition (and (clear ?bm) (on ?bm ?bf))\n  :effect (and (not (on ?bm ?bf))\n               (on-table ?bm) (clear ?bf)))\n\n(:action move-t-to-b\n  :parameters (?bm ?bt)\n  :precondition (and (clear ?bm) (clear ?bt) (on-table ?bm))\n  :effect (and (not (clear ?bt)) (not (on-table ?bm))\n               (on ?bm ?bt))))\n\n"
    },
    {
        "file_name": "rovers",
        "pddl_domain": "(define (domain rover)\n(:requirements :strips :typing)\n(:types rover waypoint store camera mode lander objective)\n\n(:predicates (at ?x - rover ?y - waypoint) \n             (at_lander ?x - lander ?y - waypoint)\n             (can_traverse ?r - rover ?x - waypoint ?y - waypoint)\n\t     (equipped_for_soil_analysis ?r - rover)\n             (equipped_for_rock_analysis ?r - rover)\n             (equipped_for_imaging ?r - rover)\n             (empty ?s - store)\n             (have_rock_analysis ?r - rover ?w - waypoint)\n             (have_soil_analysis ?r - rover ?w - waypoint)\n             (full ?s - store)\n\t     (calibrated ?c - camera ?r - rover) \n\t     (supports ?c - camera ?m - mode)\n             (available ?r - rover)\n             (visible ?w - waypoint ?p - waypoint)\n             (have_image ?r - rover ?o - objective ?m - mode)\n             (communicated_soil_data ?w - waypoint)\n             (communicated_rock_data ?w - waypoint)\n             (communicated_image_data ?o - objective ?m - mode)\n\t     (at_soil_sample ?w - waypoint)\n\t     (at_rock_sample ?w - waypoint)\n             (visible_from ?o - objective ?w - waypoint)\n\t     (store_of ?s - store ?r - rover)\n\t     (calibration_target ?i - camera ?o - objective)\n\t     (on_board ?i - camera ?r - rover)\n\t     (channel_free ?l - lander))\n\n(:action navigate\n:parameters (?x - rover ?y - waypoint ?z - waypoint) \n:precondition (and (can_traverse ?x ?y ?z) (available ?x) (at ?x ?y) \n                (visible ?y ?z))\n:effect (and (not (at ?x ?y)) (at ?x ?z)))\n\n(:action sample_soil\n:parameters (?x - rover ?s - store ?p - waypoint)\n:precondition (and (at ?x ?p) (at_soil_sample ?p) \n\t\t   (equipped_for_soil_analysis ?x) (store_of ?s ?x) (empty ?s))\n:effect (and (not (empty ?s)) (full ?s) (have_soil_analysis ?x ?p) \n\t     (not (at_soil_sample ?p))))\n\n(:action sample_rock\n:parameters (?x - rover ?s - store ?p - waypoint)\n:precondition (and (at ?x ?p) (at_rock_sample ?p) \n\t           (equipped_for_rock_analysis ?x) (store_of ?s ?x)(empty ?s))\n:effect (and (not (empty ?s)) (full ?s) (have_rock_analysis ?x ?p) \n\t     (not (at_rock_sample ?p))))\n\n(:action drop\n:parameters (?x - rover ?y - store)\n:precondition (and (store_of ?y ?x) (full ?y))\n:effect (and (not (full ?y)) (empty ?y)))\n\n\n\n(:action calibrate\n :parameters (?r - rover ?i - camera ?t - objective ?w - waypoint)\n :precondition (and (equipped_for_imaging ?r) (calibration_target ?i ?t) \n\t            (at ?r ?w) (visible_from ?t ?w)(on_board ?i ?r))\n :effect (calibrated ?i ?r))\n\n(:action take_image\n :parameters (?r - rover ?p - waypoint ?o - objective ?i - camera ?m - mode)\n :precondition (and (calibrated ?i ?r) (on_board ?i ?r) (equipped_for_imaging ?r)\n                      (supports ?i ?m) (visible_from ?o ?p) (at ?r ?p))\n :effect (and (have_image ?r ?o ?m)(not (calibrated ?i ?r))))\n\n(:action communicate_soil_data\n :parameters (?r - rover ?l - lander ?p - waypoint ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_soil_analysis ?r ?p) \n                   (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t\t(communicated_soil_data ?p)(available ?r)))\n\n(:action communicate_rock_data\n :parameters (?r - rover ?l - lander ?p - waypoint ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_rock_analysis ?r ?p)\n                   (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t      (communicated_rock_data ?p)(available ?r)))\n\n\n(:action communicate_image_data\n :parameters (?r - rover ?l - lander ?o - objective ?m - mode \n\t      ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_image ?r ?o ?m)\n\t            (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t      (communicated_image_data ?o ?m)(available ?r)))\n)\n",
        "batch_id": 2,
        "id": 99,
        "tokens": 6656,
        "corrected_description": "### General\nThis domain models a Mars rover exploration scenario where a rover is tasked with navigating waypoints, collecting soil and rock samples, taking images, and communicating data back to a lander. The rover is equipped with various tools for analysis and imaging, and must manage its storage capacity while ensuring it has the right equipment for each task.\n\n### Types\n- **rover**: Represents the rover exploring Mars.\n- **waypoint**: Locations the rover can navigate to.\n- **store**: Storage units on the rover for holding samples.\n- **camera**: Cameras on the rover for taking images.\n- **mode**: Different modes a camera can be in for taking images.\n- **lander**: Represents the lander which communicates with the rover.\n- **objective**: Points of interest for imaging.\n\n### Predicates\n- **(at ?x - rover ?y - waypoint)**: The rover ?x is at waypoint ?y.\n- **(at_lander ?x - lander ?y - waypoint)**: The lander ?x is at waypoint ?y.\n- **(can_traverse ?r - rover ?x - waypoint ?y - waypoint)**: The rover ?r can traverse from waypoint ?x to waypoint ?y.\n- **(equipped_for_soil_analysis ?r - rover)**: The rover ?r is equipped for soil analysis.\n- **(equipped_for_rock_analysis ?r - rover)**: The rover ?r is equipped for rock analysis.\n- **(equipped_for_imaging ?r - rover)**: The rover ?r is equipped for imaging.\n- **(empty ?s - store)**: The store ?s is empty.\n- **(have_rock_analysis ?r - rover ?w - waypoint)**: The rover ?r has analyzed a rock sample at waypoint ?w.\n- **(have_soil_analysis ?r - rover ?w - waypoint)**: The rover ?r has analyzed a soil sample at waypoint ?w.\n- **(full ?s - store)**: The store ?s is full.\n- **(calibrated ?c - camera ?r - rover)**: The camera ?c on rover ?r is calibrated.\n- **(supports ?c - camera ?m - mode)**: The camera ?c supports mode ?m.\n- **(available ?r - rover)**: The rover ?r is available for tasks.\n- **(visible ?w - waypoint ?p - waypoint)**: Waypoint ?w is visible from waypoint ?p.\n- **(have_image ?r - rover ?o - objective ?m - mode)**: The rover ?r has an image of objective ?o in mode ?m.\n- **(communicated_soil_data ?w - waypoint)**: Soil data from waypoint ?w has been communicated.\n- **(communicated_rock_data ?w - waypoint)**: Rock data from waypoint ?w has been communicated.\n- **(communicated_image_data ?o - objective ?m - mode)**: Image data of objective ?o in mode ?m has been communicated.\n- **(at_soil_sample ?w - waypoint)**: There is a soil sample at waypoint ?w.\n- **(at_rock_sample ?w - waypoint)**: There is a rock sample at waypoint ?w.\n- **(visible_from ?o - objective ?w - waypoint)**: Objective ?o is visible from waypoint ?w.\n- **(store_of ?s - store ?r - rover)**: Store ?s is part of rover ?r.\n- **(calibration_target ?i - camera ?o - objective)**: Camera ?i has objective ?o as a calibration target.\n- **(on_board ?i - camera ?r - rover)**: Camera ?i is on board rover ?r.\n- **(channel_free ?l - lander)**: The communication channel to lander ?l is free.\n\n### Actions\n- **navigate <?x> <?y> <?z>**: Moves the rover from one waypoint to another if the rover can traverse the path and the destination is visible from the current location.  \n\n- **sample_soil <?x> <?s> <?p>**: Collects a soil sample at a waypoint if the rover is equipped for soil analysis and has empty storage.  \n\n- **sample_rock <?x> <?s> <?p>**: Collects a rock sample at a waypoint if the rover is equipped for rock analysis and has empty storage.  \n\n- **drop <?x> <?y>**: Empties the rover's storage.  \n\n- **calibrate <?r> <?i> <?t> <?w>**: Calibrates a camera on the rover for imaging an objective visible from the current waypoint.  \n\n- **take_image <?r> <?p> <?o> <?i> <?m>**: Takes an image of an objective in a specific mode if the camera is calibrated and supports the mode.  \n\n- **communicate_soil_data <?r> <?l> <?p> <?x> <?y>**: Communicates soil data back to the lander if the rover is at a waypoint visible to the lander and the communication channel is free.  \n\n- **communicate_rock_data <?r> <?l> <?p> <?x> <?y>**: Communicates rock data back to the lander under similar conditions as soil data communication.  \n\n- **communicate_image_data <?r> <?l> <?o> <?m> <?x> <?y>**: Communicates image data back to the lander if the rover has an image of an objective in a specific mode and the communication channel is free.",
        "pddl_domain_processed": "(define (domain rover)\n(:requirements :strips :typing)\n(:types rover waypoint store camera mode lander objective)\n\n(:predicates (at ?x - rover ?y - waypoint) \n             (at_lander ?x - lander ?y - waypoint)\n             (can_traverse ?r - rover ?x - waypoint ?y - waypoint)\n\t     (equipped_for_soil_analysis ?r - rover)\n             (equipped_for_rock_analysis ?r - rover)\n             (equipped_for_imaging ?r - rover)\n             (empty ?s - store)\n             (have_rock_analysis ?r - rover ?w - waypoint)\n             (have_soil_analysis ?r - rover ?w - waypoint)\n             (full ?s - store)\n\t     (calibrated ?c - camera ?r - rover) \n\t     (supports ?c - camera ?m - mode)\n             (available ?r - rover)\n             (visible ?w - waypoint ?p - waypoint)\n             (have_image ?r - rover ?o - objective ?m - mode)\n             (communicated_soil_data ?w - waypoint)\n             (communicated_rock_data ?w - waypoint)\n             (communicated_image_data ?o - objective ?m - mode)\n\t     (at_soil_sample ?w - waypoint)\n\t     (at_rock_sample ?w - waypoint)\n             (visible_from ?o - objective ?w - waypoint)\n\t     (store_of ?s - store ?r - rover)\n\t     (calibration_target ?i - camera ?o - objective)\n\t     (on_board ?i - camera ?r - rover)\n\t     (channel_free ?l - lander))\n\n(:action navigate\n:parameters (?x - rover ?y - waypoint ?z - waypoint) \n:precondition (and (can_traverse ?x ?y ?z) (available ?x) (at ?x ?y) \n                (visible ?y ?z))\n:effect (and (not (at ?x ?y)) (at ?x ?z)))\n\n(:action sample_soil\n:parameters (?x - rover ?s - store ?p - waypoint)\n:precondition (and (at ?x ?p) (at_soil_sample ?p) \n\t\t   (equipped_for_soil_analysis ?x) (store_of ?s ?x) (empty ?s))\n:effect (and (not (empty ?s)) (full ?s) (have_soil_analysis ?x ?p) \n\t     (not (at_soil_sample ?p))))\n\n(:action sample_rock\n:parameters (?x - rover ?s - store ?p - waypoint)\n:precondition (and (at ?x ?p) (at_rock_sample ?p) \n\t           (equipped_for_rock_analysis ?x) (store_of ?s ?x)(empty ?s))\n:effect (and (not (empty ?s)) (full ?s) (have_rock_analysis ?x ?p) \n\t     (not (at_rock_sample ?p))))\n\n(:action drop\n:parameters (?x - rover ?y - store)\n:precondition (and (store_of ?y ?x) (full ?y))\n:effect (and (not (full ?y)) (empty ?y)))\n\n(:action calibrate\n :parameters (?r - rover ?i - camera ?t - objective ?w - waypoint)\n :precondition (and (equipped_for_imaging ?r) (calibration_target ?i ?t) \n\t            (at ?r ?w) (visible_from ?t ?w)(on_board ?i ?r))\n :effect (calibrated ?i ?r))\n\n(:action take_image\n :parameters (?r - rover ?p - waypoint ?o - objective ?i - camera ?m - mode)\n :precondition (and (calibrated ?i ?r) (on_board ?i ?r) (equipped_for_imaging ?r)\n                      (supports ?i ?m) (visible_from ?o ?p) (at ?r ?p))\n :effect (and (have_image ?r ?o ?m)(not (calibrated ?i ?r))))\n\n(:action communicate_soil_data\n :parameters (?r - rover ?l - lander ?p - waypoint ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_soil_analysis ?r ?p) \n                   (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t\t(communicated_soil_data ?p)(available ?r)))\n\n(:action communicate_rock_data\n :parameters (?r - rover ?l - lander ?p - waypoint ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_rock_analysis ?r ?p)\n                   (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t      (communicated_rock_data ?p)(available ?r)))\n\n(:action communicate_image_data\n :parameters (?r - rover ?l - lander ?o - objective ?m - mode \n\t      ?x - waypoint ?y - waypoint)\n :precondition (and (at ?r ?x)(at_lander ?l ?y)(have_image ?r ?o ?m)\n\t            (visible ?x ?y)(available ?r)(channel_free ?l))\n :effect (and (not (available ?r))(not (channel_free ?l))\n\t      (communicated_image_data ?o ?m)(available ?r)))\n)\n"
    },
    {
        "file_name": "barman",
        "pddl_domain": "(define (domain barman)\n  (:requirements :strips :typing :action-costs)\n  (:types hand level beverage dispenser container - object\n  \t  ingredient cocktail - beverage\n          shot shaker - container)\n  (:predicates  (ontable ?c - container)\n                (holding ?h - hand ?c - container)\n\t\t(handempty ?h - hand)\n\t\t(empty ?c - container)\n                (contains ?c - container ?b - beverage)\n\t\t(clean ?c - container)\n                (used ?c - container ?b - beverage)\n                (dispenses ?d - dispenser ?i - ingredient)\n\t\t(shaker-empty-level ?s - shaker ?l - level)\n\t\t(shaker-level ?s - shaker ?l - level)\n\t\t(next ?l1 ?l2 - level)\n\t\t(unshaked ?s - shaker)\n\t\t(shaked ?s - shaker)\n                (cocktail-part1 ?c - cocktail ?i - ingredient)\n                (cocktail-part2 ?c - cocktail ?i - ingredient))\n\n(:functions (total-cost) - number)\n\t\t\n  (:action grasp\n             :parameters (?h - hand ?c - container)\n             :precondition (and (ontable ?c) (handempty ?h))\n             :effect (and (not (ontable ?c))\n\t     \t     \t  (not (handempty ?h))\n\t\t\t  (holding ?h ?c)\n\t\t\t  (increase (total-cost) 1)))\n\n  (:action leave\n             :parameters (?h - hand ?c - container)\n             :precondition (holding ?h ?c)\n             :effect (and (not (holding ?h ?c))\n\t     \t     \t  (handempty ?h)\n\t\t\t  (ontable ?c)\n\t\t\t  (increase (total-cost) 1)))\n  \n  (:action fill-shot\n           :parameters (?s - shot ?i - ingredient ?h1 ?h2 - hand ?d - dispenser)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n\t   \t\t      (dispenses ?d ?i)\n                              (empty ?s)\n\t\t\t      (clean ?s))\n           :effect (and (not (empty ?s))\n\t   \t   \t(contains ?s ?i)\n\t   \t   \t(not (clean ?s))\n\t\t\t(used ?s ?i)\n\t\t\t(increase (total-cost) 10)))\n\n\n  (:action refill-shot\n           :parameters (?s - shot ?i - ingredient ?h1 ?h2 - hand ?d - dispenser)\n           :precondition (and (holding ?h1 ?s)\t   \t\t      \n                              (handempty ?h2)\n\t   \t\t      (dispenses ?d ?i)\n                              (empty ?s)\n\t\t\t      (used ?s ?i))\n           :effect (and (not (empty ?s))\n                        (contains ?s ?i)\n\t\t\t(increase (total-cost) 10)))\n\n  (:action empty-shot\n           :parameters (?h - hand ?p - shot ?b - beverage)\n           :precondition (and (holding ?h ?p)\n                              (contains ?p ?b))\n           :effect (and (not (contains ?p ?b))\n\t   \t   \t(empty ?p)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action clean-shot\n  \t   :parameters (?s - shot ?b - beverage ?h1 ?h2 - hand)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\t   \t\t      \n\t\t\t      (empty ?s)\n                              (used ?s ?b))\n           :effect (and (not (used ?s ?b))\n\t   \t   \t(clean ?s)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action pour-shot-to-clean-shaker\n           :parameters (?s - shot ?i - ingredient ?d - shaker ?h1 - hand ?l ?l1 - level)\n           :precondition (and (holding ?h1 ?s)\n\t\t\t      (contains ?s ?i)\n                              (empty ?d)\n\t   \t\t      (clean ?d)                              \n                              (shaker-level ?d ?l)\n                              (next ?l ?l1))\n           :effect (and (not (contains ?s ?i))\n\t   \t   \t(empty ?s)\n\t\t\t(contains ?d ?i)\n                        (not (empty ?d))\n\t\t\t(not (clean ?d))\n\t\t\t(unshaked ?d)\n\t\t\t(not (shaker-level ?d ?l))\n\t\t\t(shaker-level ?d ?l1)\n\t\t\t(increase (total-cost) 1)))\n\n\n  (:action pour-shot-to-used-shaker\n           :parameters (?s - shot ?i - ingredient ?d - shaker ?h1 - hand ?l ?l1 - level)\n           :precondition (and (holding ?h1 ?s)\n\t\t\t      (contains ?s ?i)\n                              (unshaked ?d)\n                              (shaker-level ?d ?l)\n                              (next ?l ?l1))\n           :effect (and (not (contains ?s ?i))\n                        (contains ?d ?i)\n\t   \t   \t(empty ?s)     \n  \t\t\t(not (shaker-level ?d ?l))\n\t\t\t(shaker-level ?d ?l1)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action empty-shaker\n           :parameters (?h - hand ?s - shaker ?b - cocktail ?l ?l1 - level)\n           :precondition (and (holding ?h ?s)\n                              (contains ?s ?b)\n\t\t\t      (shaked ?s)\n\t\t\t      (shaker-level ?s ?l)\n\t\t\t      (shaker-empty-level ?s ?l1))\n           :effect (and (not (shaked ?s))\n\t   \t   \t(not (shaker-level ?s ?l))\n\t   \t   \t(shaker-level ?s ?l1)\n\t\t\t(not (contains ?s ?b))\n\t   \t   \t(empty ?s)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action clean-shaker\n  \t   :parameters (?h1 ?h2 - hand ?s - shaker)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n                              (empty ?s))\n           :effect (and (clean ?s)\n\t\t\t(increase (total-cost) 1)))\n  \n  (:action shake\n  \t   :parameters (?b - cocktail ?d1 ?d2 - ingredient ?s - shaker ?h1 ?h2 - hand)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n\t\t\t      (contains ?s ?d1)\n                              (contains ?s ?d2)\n                              (cocktail-part1 ?b ?d1)\n\t\t\t      (cocktail-part2 ?b ?d2)\n\t\t\t      (unshaked ?s))\t\t\t      \n           :effect (and (not (unshaked ?s))\n\t\t        (not (contains ?s ?d1))\n                        (not (contains ?s ?d2))\n\t   \t   \t(shaked ?s)\n                        (contains ?s ?b)\n\t\t\t(increase (total-cost) 1)))\n                        \n(:action pour-shaker-to-shot\n          :parameters (?b - beverage ?d - shot ?h - hand ?s - shaker ?l ?l1 - level)\n          :precondition (and (holding ?h ?s)\n                  (shaked ?s)\n                  (empty ?d)\n                  (clean ?d)\n                  (contains ?s ?b)\n                             (shaker-level ?s ?l)\n                             (next ?l1 ?l))\n          :effect (and (not (clean ?d))\n                  (not (empty ?d))\n            (contains ?d ?b)\n            (used ?d ?b)\n            (shaker-level ?s ?l1)\n            (not (shaker-level ?s ?l))\n            (increase (total-cost) 1)))\n)\n",
        "batch_id": 2,
        "id": 101,
        "tokens": 7105,
        "corrected_description": "### General\nYou are a robot barman involved in the preparation and serving of drinks. The domain includes handling different types of beverages, using containers like shot glasses and shakers, and operating with drink dispensers. The goal is to efficiently serve a set of desired drinks, optimizing for actions' costs.\n\n### Types\n- **object**: The base type for all objects in the domain.\n- **hand**: Represents the robot's hands.\n- **level**: Represents the levels of liquid in containers.\n- **beverage**: Represents drinks, including both ingredients and cocktails.\n- **dispenser**: Represents the dispensers for ingredients.\n- **container**: Represents objects that can hold beverages.\n- **ingredient**: A subtype of beverage, represents the basic components of cocktails.\n- **cocktail**: A subtype of beverage, represents mixed drinks.\n- **shot**: A subtype of container, represents shot glasses.\n- **shaker**: A subtype of container, represents the cocktail shaker.\n\n### Predicates\n- **(ontable ?c - container)**: Indicates that container ?c is on the table.\n- **(holding ?h - hand ?c - container)**: Indicates that hand ?h is holding container ?c.\n- **(handempty ?h - hand)**: Indicates that hand ?h is empty.\n- **(empty ?c - container)**: Indicates that container ?c is empty.\n- **(contains ?c - container ?b - beverage)**: Indicates that container ?c contains beverage ?b.\n- **(clean ?c - container)**: Indicates that container ?c is clean.\n- **(used ?c - container ?b - beverage)**: Indicates that container ?c has been used for beverage ?b.\n- **(dispenses ?d - dispenser ?i - ingredient)**: Indicates that dispenser ?d dispenses ingredient ?i.\n- **(shaker-empty-level ?s - shaker ?l - level)**: Indicates the empty level ?l of shaker ?s.\n- **(shaker-level ?s - shaker ?l - level)**: Indicates the current level ?l of shaker ?s.\n- **(next ?l1 ?l2 - level)**: Indicates that level ?l2 is next after level ?l1.\n- **(unshaked ?s - shaker)**: Indicates that shaker ?s is unshaked.\n- **(shaked ?s - shaker)**: Indicates that shaker ?s is shaked.\n- **(cocktail-part1 ?c - cocktail ?i - ingredient)**: Indicates that ingredient ?i is the first part of cocktail ?c.\n- **(cocktail-part2 ?c - cocktail ?i - ingredient)**: Indicates that ingredient ?i is the second part of cocktail ?c.\n\n### Functions\n- **(total-cost)**: Represents the total cost accumulated from actions taken within the domain. This function is used to track the cost of analyzing and rotating cars.\n\n### Actions\n- **grasp <?h> <?c>**: The action for a hand (?h) to grasp a container (?c) from the table, increasing the total cost by 1.  \n\n- **leave <?h> <?c>**: The action for a hand (?h) to leave a container (?c) on the table, increasing the total cost by 1.  \n\n- **fill-shot <?s> <?i> <?h1> <?h2> <?d>**: The action for a hand (?h1) to fill a shot (?s) with an ingredient (?i) from a dispenser (?d) using a second empty hand (?h2), increasing the total cost by 10.  \n\n- **refill-shot <?s> <?i> <?h1> <?h2> <?d>**: The action for a hand (?h1) to refill a shot (?s) with an ingredient (?i) from a dispenser (?d) using a second empty hand (?h2), increasing the total cost by 10.  \n\n- **empty-shot <?h> <?p> <?b>**: The action for a hand (?h) to empty a shot (?p) that contains a beverage (?b), increasing the total cost by 1.  \n\n- **clean-shot <?s> <?b> <?h1> <?h2>**: The action for a hand (?h1) to clean a shot (?s) that has been used with a beverage (?b), using a second empty hand (?h2), increasing the total cost by 1.  \n\n- **pour-shot-to-clean-shaker <?s> <?i> <?d> <?h1> <?l> <?l1>**: The action for a hand (?h1) to pour the contents of a shot (?s) into a clean shaker (?d), increasing the total cost by 1.  \n\n- **pour-shot-to-used-shaker <?s> <?i> <?d> <?h1> <?l> <?l1>**: The action for a hand (?h1) to pour the contents of a shot (?s) into a used shaker (?d), increasing the total cost by 1.  \n\n- **empty-shaker <?h> <?s> <?b> <?l> <?l1>**: The action for a hand (?h) to empty a shaker (?s) containing a beverage (?b), increasing the total cost by 1.  \n\n- **clean-shaker <?h1> <?h2> <?s>**: The action for a hand (?h1) to clean a shaker (?s) using a second empty hand (?h2), increasing the total cost by 1.  \n\n- **shake <?b> <?d1> <?d2> <?s> <?h1> <?h2>**: The action for a hand (?h1) to shake a shaker (?s) containing ingredients (?d1) and (?d2) to create a cocktail (?b), using a second empty hand (?h2), increasing the total cost by 1.  \n\n- **pour-shaker-to-shot <?b> <?d> <?h> <?s> <?l> <?l1>**: The action for a hand (?h) to pour the contents of a shaked shaker (?s) into a clean shot (?d), increasing the total cost by 1.",
        "pddl_domain_processed": "(define (domain barman)\n  (:requirements :strips :typing :action-costs)\n  (:types hand level beverage dispenser container - object\n  \t  ingredient cocktail - beverage\n          shot shaker - container)\n  (:predicates  (ontable ?c - container)\n                (holding ?h - hand ?c - container)\n\t\t(handempty ?h - hand)\n\t\t(empty ?c - container)\n                (contains ?c - container ?b - beverage)\n\t\t(clean ?c - container)\n                (used ?c - container ?b - beverage)\n                (dispenses ?d - dispenser ?i - ingredient)\n\t\t(shaker-empty-level ?s - shaker ?l - level)\n\t\t(shaker-level ?s - shaker ?l - level)\n\t\t(next ?l1 ?l2 - level)\n\t\t(unshaked ?s - shaker)\n\t\t(shaked ?s - shaker)\n                (cocktail-part1 ?c - cocktail ?i - ingredient)\n                (cocktail-part2 ?c - cocktail ?i - ingredient))\n\n(:functions (total-cost) - number)\n\n  (:action grasp\n             :parameters (?h - hand ?c - container)\n             :precondition (and (ontable ?c) (handempty ?h))\n             :effect (and (not (ontable ?c))\n\t     \t     \t  (not (handempty ?h))\n\t\t\t  (holding ?h ?c)\n\t\t\t  (increase (total-cost) 1)))\n\n  (:action leave\n             :parameters (?h - hand ?c - container)\n             :precondition (holding ?h ?c)\n             :effect (and (not (holding ?h ?c))\n\t     \t     \t  (handempty ?h)\n\t\t\t  (ontable ?c)\n\t\t\t  (increase (total-cost) 1)))\n\n  (:action fill-shot\n           :parameters (?s - shot ?i - ingredient ?h1 ?h2 - hand ?d - dispenser)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n\t   \t\t      (dispenses ?d ?i)\n                              (empty ?s)\n\t\t\t      (clean ?s))\n           :effect (and (not (empty ?s))\n\t   \t   \t(contains ?s ?i)\n\t   \t   \t(not (clean ?s))\n\t\t\t(used ?s ?i)\n\t\t\t(increase (total-cost) 10)))\n\n  (:action refill-shot\n           :parameters (?s - shot ?i - ingredient ?h1 ?h2 - hand ?d - dispenser)\n           :precondition (and (holding ?h1 ?s)\t   \t\t      \n                              (handempty ?h2)\n\t   \t\t      (dispenses ?d ?i)\n                              (empty ?s)\n\t\t\t      (used ?s ?i))\n           :effect (and (not (empty ?s))\n                        (contains ?s ?i)\n\t\t\t(increase (total-cost) 10)))\n\n  (:action empty-shot\n           :parameters (?h - hand ?p - shot ?b - beverage)\n           :precondition (and (holding ?h ?p)\n                              (contains ?p ?b))\n           :effect (and (not (contains ?p ?b))\n\t   \t   \t(empty ?p)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action clean-shot\n  \t   :parameters (?s - shot ?b - beverage ?h1 ?h2 - hand)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\t   \t\t      \n\t\t\t      (empty ?s)\n                              (used ?s ?b))\n           :effect (and (not (used ?s ?b))\n\t   \t   \t(clean ?s)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action pour-shot-to-clean-shaker\n           :parameters (?s - shot ?i - ingredient ?d - shaker ?h1 - hand ?l ?l1 - level)\n           :precondition (and (holding ?h1 ?s)\n\t\t\t      (contains ?s ?i)\n                              (empty ?d)\n\t   \t\t      (clean ?d)                              \n                              (shaker-level ?d ?l)\n                              (next ?l ?l1))\n           :effect (and (not (contains ?s ?i))\n\t   \t   \t(empty ?s)\n\t\t\t(contains ?d ?i)\n                        (not (empty ?d))\n\t\t\t(not (clean ?d))\n\t\t\t(unshaked ?d)\n\t\t\t(not (shaker-level ?d ?l))\n\t\t\t(shaker-level ?d ?l1)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action pour-shot-to-used-shaker\n           :parameters (?s - shot ?i - ingredient ?d - shaker ?h1 - hand ?l ?l1 - level)\n           :precondition (and (holding ?h1 ?s)\n\t\t\t      (contains ?s ?i)\n                              (unshaked ?d)\n                              (shaker-level ?d ?l)\n                              (next ?l ?l1))\n           :effect (and (not (contains ?s ?i))\n                        (contains ?d ?i)\n\t   \t   \t(empty ?s)     \n  \t\t\t(not (shaker-level ?d ?l))\n\t\t\t(shaker-level ?d ?l1)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action empty-shaker\n           :parameters (?h - hand ?s - shaker ?b - cocktail ?l ?l1 - level)\n           :precondition (and (holding ?h ?s)\n                              (contains ?s ?b)\n\t\t\t      (shaked ?s)\n\t\t\t      (shaker-level ?s ?l)\n\t\t\t      (shaker-empty-level ?s ?l1))\n           :effect (and (not (shaked ?s))\n\t   \t   \t(not (shaker-level ?s ?l))\n\t   \t   \t(shaker-level ?s ?l1)\n\t\t\t(not (contains ?s ?b))\n\t   \t   \t(empty ?s)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action clean-shaker\n  \t   :parameters (?h1 ?h2 - hand ?s - shaker)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n                              (empty ?s))\n           :effect (and (clean ?s)\n\t\t\t(increase (total-cost) 1)))\n\n  (:action shake\n  \t   :parameters (?b - cocktail ?d1 ?d2 - ingredient ?s - shaker ?h1 ?h2 - hand)\n           :precondition (and (holding ?h1 ?s)\n                              (handempty ?h2)\n\t\t\t      (contains ?s ?d1)\n                              (contains ?s ?d2)\n                              (cocktail-part1 ?b ?d1)\n\t\t\t      (cocktail-part2 ?b ?d2)\n\t\t\t      (unshaked ?s))\t\t\t      \n           :effect (and (not (unshaked ?s))\n\t\t        (not (contains ?s ?d1))\n                        (not (contains ?s ?d2))\n\t   \t   \t(shaked ?s)\n                        (contains ?s ?b)\n\t\t\t(increase (total-cost) 1)))\n\n(:action pour-shaker-to-shot\n          :parameters (?b - beverage ?d - shot ?h - hand ?s - shaker ?l ?l1 - level)\n          :precondition (and (holding ?h ?s)\n                  (shaked ?s)\n                  (empty ?d)\n                  (clean ?d)\n                  (contains ?s ?b)\n                             (shaker-level ?s ?l)\n                             (next ?l1 ?l))\n          :effect (and (not (clean ?d))\n                  (not (empty ?d))\n            (contains ?d ?b)\n            (used ?d ?b)\n            (shaker-level ?s ?l1)\n            (not (shaker-level ?s ?l))\n            (increase (total-cost) 1)))\n)\n"
    },
    {
        "file_name": "parking",
        "pddl_domain": "(define (domain parking)\n (:requirements :strips :typing :action-costs)\n (:types car curb)\n (:predicates\n    (at-curb ?car - car)\n    (at-curb-num ?car - car ?curb - curb)\n    (behind-car ?car ?front-car - car)\n    (car-clear ?car - car)\n    (curb-clear ?curb - curb)\n )\n\n(:functions (total-cost) - number)\n\n\t(:action move-curb-to-curb\n\t\t:parameters (?car - car ?curbsrc ?curbdest - curb)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(curb-clear ?curbdest)\n\t\t\t(at-curb-num ?car ?curbsrc)\n                        (not (= ?curbsrc ?curbdest)) ; A car cannot be moved from a curb to the same curb (to avoid contradictory effects)\n\t\t)\n\t\t:effect (and\n\t\t\t(not (curb-clear ?curbdest))\n\t\t\t(curb-clear ?curbsrc)\n\t\t\t(at-curb-num ?car ?curbdest)\n\t\t\t(not (at-curb-num ?car ?curbsrc))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-curb-to-car\n\t\t:parameters (?car - car ?curbsrc - curb ?cardest - car)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(car-clear ?cardest)\n\t\t\t(at-curb-num ?car ?curbsrc)\n\t\t\t(at-curb ?cardest)      \n                        (not (= ?car ?cardest))  ; A car cannot be moved onto itself\n\t\t)\n\t\t:effect (and\n\t\t\t(not (car-clear ?cardest))\n\t\t\t(curb-clear ?curbsrc)\n\t\t\t(behind-car ?car ?cardest)\n\t\t\t(not (at-curb-num ?car ?curbsrc))\n\t\t\t(not (at-curb ?car))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-car-to-curb\n\t\t:parameters (?car - car ?carsrc - car ?curbdest - curb)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(curb-clear ?curbdest)\n\t\t\t(behind-car ?car ?carsrc)\n                        (not (= ?car ?carsrc))  ; A car cannot be moved from itself\n\t\t)\n\t\t:effect (and\n\t\t\t(not (curb-clear ?curbdest))\n\t\t\t(car-clear ?carsrc)\n\t\t\t(at-curb-num ?car ?curbdest)\n\t\t\t(not (behind-car ?car ?carsrc))\n\t\t\t(at-curb ?car)\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-car-to-car\n\t\t:parameters (?car - car ?carsrc - car ?cardest - car)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(car-clear ?cardest)\n\t\t\t(behind-car ?car ?carsrc)\n\t\t\t(at-curb ?cardest)\n                        ; The three cars must be different\n                        (not (= ?car ?carsrc))\n                        (not (= ?carsrc ?cardest))\n                        (not (= ?car ?cardest))\n\t\t)\n\t\t:effect (and\n\t\t\t(not (car-clear ?cardest))\n\t\t\t(car-clear ?carsrc)\n\t\t\t(behind-car ?car ?cardest)\n\t\t\t(not (behind-car ?car ?carsrc))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n)\n",
        "batch_id": 2,
        "id": 102,
        "tokens": 5786,
        "corrected_description": "### General\nThis domain models a parking scenario where cars can be moved between curbs and behind other cars. The goal is to rearrange cars according to certain conditions, taking into account the space available at curbs and behind cars. The domain supports action costs, allowing for the calculation of the total cost of a parking plan.\n\n### Types\n- **car**: Represents the cars that need to be parked or moved.\n- **curb**: Represents the curbs where cars can be parked.\n\n### Predicates\n- **(at-curb ?car - car)**: Indicates that the car is parked at a curb.\n- **(at-curb-num ?car - car ?curb - curb)**: Indicates that the car is parked at a specific curb.\n- **(behind-car ?car ?front-car - car)**: Indicates that one car is parked directly behind another car.\n- **(car-clear ?car - car)**: Indicates that there is no car parked directly behind the specified car, allowing it to be moved.\n- **(curb-clear ?curb - curb)**: Indicates that the curb has space available for parking a car.\n\n### Functions\n- **(total-cost)**: Represents the total cost accumulated from actions taken within the domain. This function is used to track the cost of analyzing and rotating cars.\n\n### Actions\n- **move-curb-to-curb <?car> <?curbsrc> <?curbdest>**: Moves a car (?car) from one curb (?curbsrc) to another curb (?curbdest), increasing the total cost by 1.  \n\n- **move-curb-to-car <?car> <?curbsrc> <?cardest>**: Moves a car (?car) from a curb (?curbsrc) to another car (?cardest), increasing the total cost by 1.  \n\n- **move-car-to-curb <?car> <?carsrc> <?curbdest>**: Moves a car (?car) from behind another car (?carsrc) to a curb (?curbdest), increasing the total cost by 1.  \n\n- **move-car-to-car <?car> <?carsrc> <?cardest>**: Moves a car (?car) from behind another car (?carsrc) to behind a different car (?cardest), increasing the total cost by 1.",
        "pddl_domain_processed": "(define (domain parking)\n (:requirements :strips :typing :action-costs)\n (:types car curb)\n (:predicates\n    (at-curb ?car - car)\n    (at-curb-num ?car - car ?curb - curb)\n    (behind-car ?car ?front-car - car)\n    (car-clear ?car - car)\n    (curb-clear ?curb - curb)\n )\n\n(:functions (total-cost) - number)\n\n\t(:action move-curb-to-curb\n\t\t:parameters (?car - car ?curbsrc ?curbdest - curb)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(curb-clear ?curbdest)\n\t\t\t(at-curb-num ?car ?curbsrc)\n                        (not (= ?curbsrc ?curbdest)) \n\t\t)\n\t\t:effect (and\n\t\t\t(not (curb-clear ?curbdest))\n\t\t\t(curb-clear ?curbsrc)\n\t\t\t(at-curb-num ?car ?curbdest)\n\t\t\t(not (at-curb-num ?car ?curbsrc))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-curb-to-car\n\t\t:parameters (?car - car ?curbsrc - curb ?cardest - car)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(car-clear ?cardest)\n\t\t\t(at-curb-num ?car ?curbsrc)\n\t\t\t(at-curb ?cardest)      \n                        (not (= ?car ?cardest))  \n\t\t)\n\t\t:effect (and\n\t\t\t(not (car-clear ?cardest))\n\t\t\t(curb-clear ?curbsrc)\n\t\t\t(behind-car ?car ?cardest)\n\t\t\t(not (at-curb-num ?car ?curbsrc))\n\t\t\t(not (at-curb ?car))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-car-to-curb\n\t\t:parameters (?car - car ?carsrc - car ?curbdest - curb)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(curb-clear ?curbdest)\n\t\t\t(behind-car ?car ?carsrc)\n                        (not (= ?car ?carsrc))  \n\t\t)\n\t\t:effect (and\n\t\t\t(not (curb-clear ?curbdest))\n\t\t\t(car-clear ?carsrc)\n\t\t\t(at-curb-num ?car ?curbdest)\n\t\t\t(not (behind-car ?car ?carsrc))\n\t\t\t(at-curb ?car)\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n\n\t(:action move-car-to-car\n\t\t:parameters (?car - car ?carsrc - car ?cardest - car)\n\t\t:precondition (and\n\t\t\t(car-clear ?car)\n\t\t\t(car-clear ?cardest)\n\t\t\t(behind-car ?car ?carsrc)\n\t\t\t(at-curb ?cardest)\n\n                        (not (= ?car ?carsrc))\n                        (not (= ?carsrc ?cardest))\n                        (not (= ?car ?cardest))\n\t\t)\n\t\t:effect (and\n\t\t\t(not (car-clear ?cardest))\n\t\t\t(car-clear ?carsrc)\n\t\t\t(behind-car ?car ?cardest)\n\t\t\t(not (behind-car ?car ?carsrc))\n                        (increase (total-cost) 1)\n\t\t)\n\t)\n)\n"
    },
    {
        "file_name": "trucks",
        "pddl_domain": "; IPC5 Domain: Trucks Propositional\n; Authors: Yannis Dimopoulos, Alfonso Gerevini and Alessandro Saetti \n\n(define (domain Trucks) \n(:requirements :typing :adl)  \n\n(:types truckarea time location locatable - object\n        truck package - locatable) \n\n(:predicates (at ?x - locatable ?l - location) \t     \n             (in ?p - package ?t - truck ?a - truckarea) \t     \n             (connected ?x ?y - location)\n             (free ?a - truckarea ?t - truck)\n  \t     (time-now ?t - time)\n \t     (next ?t1 - time ?t2 - time)\n\t     (le ?t1 - time ?t2 - time)\n \t     (delivered ?p - package ?l - location ?t - time)\n\t     (at-destination ?p - package ?l - location)\n \t     (closer ?a1 - truckarea ?a2 - truckarea))\n\n(:action load\n :parameters (?p - package ?t - truck ?a1 - truckarea ?l - location)\n :precondition (and (at ?t ?l) (at ?p ?l) (free ?a1 ?t)\n  \t\t    (forall (?a2 - truckarea)\n  \t\t\t    (imply (closer ?a2 ?a1) (free ?a2 ?t))))\n :effect (and (not (at ?p ?l)) (not (free ?a1 ?t)) (in ?p ?t ?a1)))\n\n(:action unload\n :parameters (?p - package ?t - truck ?a1 - truckarea ?l - location)\n :precondition (and (at ?t ?l) (in ?p ?t ?a1)\n  \t\t    (forall (?a2 - truckarea)\n  \t\t\t    (imply (closer ?a2 ?a1) (free ?a2 ?t))))\n :effect (and (not (in ?p ?t ?a1)) (free ?a1 ?t) (at ?p ?l)))\n\n(:action drive\n :parameters (?t - truck ?from ?to - location ?t1 ?t2 - time)\n :precondition (and (at ?t ?from) (connected ?from ?to) \n\t\t    (time-now ?t1) (next ?t1 ?t2))\n :effect (and (not (at ?t ?from)) (not (time-now ?t1)) \n\t      (time-now ?t2) (at ?t ?to)))\n\n(:action deliver\n :parameters (?p - package ?l - location ?t1 ?t2 - time)\n :precondition (and (at ?p ?l) (time-now ?t1) (le ?t1 ?t2))\n :effect (and (not (at ?p ?l)) (delivered ?p ?l ?t2) (at-destination ?p ?l)))\n\n) \n\n",
        "batch_id": 2,
        "id": 103,
        "tokens": 5724,
        "corrected_description": "### General\nThis domain is designed for planning the delivery of packages using trucks. It involves moving trucks between locations, loading and unloading packages, and ensuring packages are delivered by a certain time. The domain supports advanced planning features such as typing, action duration, and conditional effects.\n\n### Types\n- **object**: The base type for all objects in the domain.\n- **truckarea**: Represents different areas within a truck where packages can be loaded.\n- **time**: Represents points in time.\n- **location**: Represents geographical locations.\n- **locatable**: A superclass of objects that can have a location, including trucks and packages.\n- **truck**: A subtype of locatable, represents trucks used for transporting packages.\n- **package**: A subtype of locatable, represents packages to be delivered.\n\n### Predicates\n- **(at ?x - locatable ?l - location)**: Indicates that locatable object ?x is at location ?l.\n- **(in ?p - package ?t - truck ?a - truckarea)**: Indicates that package ?p is in truck ?t in truckarea ?a.\n- **(connected ?x ?y - location)**: Indicates that location ?x is connected to location ?y, allowing travel between them.\n- **(free ?a - truckarea ?t - truck)**: Indicates that truckarea ?a in truck ?t is free (not occupied by a package).\n- **(time-now ?t - time)**: Indicates the current point in time.\n- **(next ?t1 ?t2 - time)**: Indicates that time ?t2 is the immediate successor of time ?t1.\n- **(le ?t1 ?t2 - time)**: Indicates that time ?t1 is less than or equal to time ?t2.\n- **(delivered ?p - package ?l - location ?t - time)**: Indicates that package ?p has been delivered to location ?l by time ?t.\n- **(at-destination ?p - package ?l - location)**: Indicates that package ?p is at its destination location ?l.\n- **(closer ?a1 ?a2 - truckarea)**: Indicates that truckarea ?a1 is closer to the truck's loading/unloading point than truckarea ?a2.\n\n### Actions\n- **load <?p> <?t> <?a1> <?l>**: Loads a package (?p) into a truck (?t) at a specific location (?l) into a designated truck area (?a1).  \n\n- **unload <?p> <?t> <?a1> <?l>**: Unloads a package (?p) from a truck (?t) at a specific location (?l) from a designated truck area (?a1).  \n\n- **drive <?t> <?from> <?to> <?t1> <?t2>**: Drives a truck (?t) from one location (?from) to another location (?to), transitioning between two times (?t1) and (?t2).  \n\n- **deliver <?p> <?l> <?t1> <?t2>**: Delivers a package (?p) at a location (?l) by a specified time (?t2).",
        "pddl_domain_processed": "\n\n(define (domain Trucks) \n(:requirements :typing :adl)  \n\n(:types truckarea time location locatable - object\n        truck package - locatable) \n\n(:predicates (at ?x - locatable ?l - location) \t     \n             (in ?p - package ?t - truck ?a - truckarea) \t     \n             (connected ?x ?y - location)\n             (free ?a - truckarea ?t - truck)\n  \t     (time-now ?t - time)\n \t     (next ?t1 - time ?t2 - time)\n\t     (le ?t1 - time ?t2 - time)\n \t     (delivered ?p - package ?l - location ?t - time)\n\t     (at-destination ?p - package ?l - location)\n \t     (closer ?a1 - truckarea ?a2 - truckarea))\n\n(:action load\n :parameters (?p - package ?t - truck ?a1 - truckarea ?l - location)\n :precondition (and (at ?t ?l) (at ?p ?l) (free ?a1 ?t)\n  \t\t    (forall (?a2 - truckarea)\n  \t\t\t    (imply (closer ?a2 ?a1) (free ?a2 ?t))))\n :effect (and (not (at ?p ?l)) (not (free ?a1 ?t)) (in ?p ?t ?a1)))\n\n(:action unload\n :parameters (?p - package ?t - truck ?a1 - truckarea ?l - location)\n :precondition (and (at ?t ?l) (in ?p ?t ?a1)\n  \t\t    (forall (?a2 - truckarea)\n  \t\t\t    (imply (closer ?a2 ?a1) (free ?a2 ?t))))\n :effect (and (not (in ?p ?t ?a1)) (free ?a1 ?t) (at ?p ?l)))\n\n(:action drive\n :parameters (?t - truck ?from ?to - location ?t1 ?t2 - time)\n :precondition (and (at ?t ?from) (connected ?from ?to) \n\t\t    (time-now ?t1) (next ?t1 ?t2))\n :effect (and (not (at ?t ?from)) (not (time-now ?t1)) \n\t      (time-now ?t2) (at ?t ?to)))\n\n(:action deliver\n :parameters (?p - package ?l - location ?t1 ?t2 - time)\n :precondition (and (at ?p ?l) (time-now ?t1) (le ?t1 ?t2))\n :effect (and (not (at ?p ?l)) (delivered ?p ?l ?t2) (at-destination ?p ?l)))\n\n) \n\n"
    },
    {
        "file_name": "grippers",
        "pddl_domain": "(define (domain gripper-strips)\n (:requirements :strips :typing) \n (:types room object robot gripper)\n (:predicates (at-robby ?r - robot ?x - room)\n \t      (at ?o - object ?x - room)\n\t      (free ?r - robot ?g - gripper)\n\t      (carry ?r - robot ?o - object ?g - gripper))\n\n   (:action move\n       :parameters  (?r - robot ?from ?to - room)\n       :precondition (and  (at-robby ?r ?from))\n       :effect (and  (at-robby ?r ?to)\n\t\t     (not (at-robby ?r ?from))))\n\n   (:action pick\n       :parameters (?r - robot ?obj - object ?room - room ?g - gripper)\n       :precondition  (and  (at ?obj ?room) (at-robby ?r ?room) (free ?r ?g))\n       :effect (and (carry ?r ?obj ?g)\n\t\t    (not (at ?obj ?room)) \n\t\t    (not (free ?r ?g))))\n\n   (:action drop\n       :parameters (?r - robot ?obj - object ?room - room ?g - gripper)\n       :precondition  (and  (carry ?r ?obj ?g) (at-robby ?r ?room))\n       :effect (and (at ?obj ?room)\n\t\t    (free ?r ?g)\n\t\t    (not (carry ?r ?obj ?g)))))",
        "batch_id": 2,
        "id": 104,
        "tokens": 5240,
        "corrected_description": "### General\nThis domain models a robot with a gripper mechanism in an environment with multiple rooms. The robot, named Robby, can move between rooms and manipulate objects using its gripper. The main tasks involve picking up objects from rooms, carrying them, and dropping them in other rooms as required.\n\n### Types\n- **room**: Represents the different rooms in the environment.\n- **object**: Represents the objects that can be manipulated and moved around by the robot.\n- **robot**: Represents the robot itself, which in this domain is specifically Robby.\n- **gripper**: Represents the gripper mechanism used by the robot to hold objects.\n\n### Predicates\n- **(at-robby ?r - robot ?x - room)**: Indicates that Robby (?r) is currently in room (?x).\n- **(at ?o - object ?x - room)**: Indicates that an object (?o) is located in room (?x).\n- **(free ?r - robot ?g - gripper)**: Indicates that the gripper (?g) of Robby (?r) is free (not holding any object).\n- **(carry ?r - robot ?o - object ?g - gripper)**: Indicates that Robby (?r) is carrying an object (?o) using its gripper (?g).\n\n### Actions\n- **move <?r> <?from> <?to>**: Allows Robby to move from one room to another.  \n\n- **pick <?r> <?obj> <?room> <?g>**: Allows Robby to pick up an object from a room.  \n\n- **drop <?r> <?obj> <?room> <?g>**: Allows Robby to drop an object into a room.",
        "pddl_domain_processed": "(define (domain gripper-strips)\n (:requirements :strips :typing) \n (:types room object robot gripper)\n (:predicates (at-robby ?r - robot ?x - room)\n \t      (at ?o - object ?x - room)\n\t      (free ?r - robot ?g - gripper)\n\t      (carry ?r - robot ?o - object ?g - gripper))\n\n   (:action move\n       :parameters  (?r - robot ?from ?to - room)\n       :precondition (and  (at-robby ?r ?from))\n       :effect (and  (at-robby ?r ?to)\n\t\t     (not (at-robby ?r ?from))))\n\n   (:action pick\n       :parameters (?r - robot ?obj - object ?room - room ?g - gripper)\n       :precondition  (and  (at ?obj ?room) (at-robby ?r ?room) (free ?r ?g))\n       :effect (and (carry ?r ?obj ?g)\n\t\t    (not (at ?obj ?room)) \n\t\t    (not (free ?r ?g))))\n\n   (:action drop\n       :parameters (?r - robot ?obj - object ?room - room ?g - gripper)\n       :precondition  (and  (carry ?r ?obj ?g) (at-robby ?r ?room))\n       :effect (and (at ?obj ?room)\n\t\t    (free ?r ?g)\n\t\t    (not (carry ?r ?obj ?g)))))"
    },
    {
        "file_name": "logistics",
        "pddl_domain": "(define (domain logistics-strips)\n  (:requirements :strips) \n  (:predicates \t(OBJ ?obj)\n\t       \t(TRUCK ?truck)\n               \t(LOCATION ?loc)\n\t\t(AIRPLANE ?airplane)\n                (CITY ?city)\n                (AIRPORT ?airport)\n\t\t(at ?obj ?loc)\n\t\t(in ?obj1 ?obj2)\n\t\t(in-city ?obj ?city))\n \n  ; (:types )\t\t; default object\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj\n    ?truck\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (TRUCK ?truck) (LOCATION ?loc)\n   (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action LOAD-AIRPLANE\n  :parameters\n   (?obj\n    ?airplane\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (AIRPLANE ?airplane) (LOCATION ?loc)\n   (at ?obj ?loc) (at ?airplane ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?airplane)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj\n    ?truck\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (TRUCK ?truck) (LOCATION ?loc)\n        (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action UNLOAD-AIRPLANE\n  :parameters\n   (?obj\n    ?airplane\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (AIRPLANE ?airplane) (LOCATION ?loc)\n        (in ?obj ?airplane) (at ?airplane ?loc))\n  :effect\n   (and (not (in ?obj ?airplane)) (at ?obj ?loc)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck\n    ?loc-from\n    ?loc-to\n    ?city)\n  :precondition\n   (and (TRUCK ?truck) (LOCATION ?loc-from) (LOCATION ?loc-to) (CITY ?city)\n   (at ?truck ?loc-from)\n   (in-city ?loc-from ?city)\n   (in-city ?loc-to ?city))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action FLY-AIRPLANE\n  :parameters\n   (?airplane\n    ?loc-from\n    ?loc-to)\n  :precondition\n   (and (AIRPLANE ?airplane) (AIRPORT ?loc-from) (AIRPORT ?loc-to)\n\t(at ?airplane ?loc-from))\n  :effect\n   (and (not (at ?airplane ?loc-from)) (at ?airplane ?loc-to)))\n)",
        "batch_id": 2,
        "id": 105,
        "tokens": 5675,
        "corrected_description": "### General\nThis domain models a simple logistics system where objects can be transported between different locations using trucks and airplanes. Trucks can move objects within the same city, while airplanes can transport objects between different cities via airports.\n\n### Predicates\n- (OBJ ?obj): Indicates that ?obj is an object that can be transported.\n- (TRUCK ?truck): Indicates that ?truck is a truck.\n- (LOCATION ?loc): Indicates that ?loc is a location.\n- (AIRPLANE ?airplane): Indicates that ?airplane is an airplane.\n- (CITY ?city): Indicates that ?city is a city.\n- (AIRPORT ?airport): Indicates that ?airport is an airport.\n- (at ?obj ?loc): Indicates that object ?obj is at location ?loc.\n- (in ?obj1 ?obj2): Indicates that object ?obj1 is inside object ?obj2 (a truck or an airplane).\n- (in-city ?obj ?city): Indicates that object ?obj is in city ?city.\n\n### Actions\n- **LOAD-TRUCK <?obj> <?truck> <?loc>**: This action loads an object (?obj) into a truck (?truck) at a specific location (?loc).  \n\n- **LOAD-AIRPLANE <?obj> <?airplane> <?loc>**: This action loads an object (?obj) into an airplane (?airplane) at a specific location (?loc).  \n\n- **UNLOAD-TRUCK <?obj> <?truck> <?loc>**: This action unloads an object (?obj) from a truck (?truck) at a specific location (?loc).  \n\n- **UNLOAD-AIRPLANE <?obj> <?airplane> <?loc>**: This action unloads an object (?obj) from an airplane (?airplane) at a specific location (?loc).  \n\n- **DRIVE-TRUCK <?truck> <?loc-from> <?loc-to> <?city>**: This action drives a truck (?truck) from one location (?loc-from) to another location (?loc-to) within a city (?city).  \n\n- **FLY-AIRPLANE <?airplane> <?loc-from> <?loc-to>**: This action flies an airplane (?airplane) from one airport (?loc-from) to another airport (?loc-to).",
        "pddl_domain_processed": "(define (domain logistics-strips)\n  (:requirements :strips) \n  (:predicates \t(OBJ ?obj)\n\t       \t(TRUCK ?truck)\n               \t(LOCATION ?loc)\n\t\t(AIRPLANE ?airplane)\n                (CITY ?city)\n                (AIRPORT ?airport)\n\t\t(at ?obj ?loc)\n\t\t(in ?obj1 ?obj2)\n\t\t(in-city ?obj ?city))\n\n(:action LOAD-TRUCK\n  :parameters\n   (?obj\n    ?truck\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (TRUCK ?truck) (LOCATION ?loc)\n   (at ?truck ?loc) (at ?obj ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?truck)))\n\n(:action LOAD-AIRPLANE\n  :parameters\n   (?obj\n    ?airplane\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (AIRPLANE ?airplane) (LOCATION ?loc)\n   (at ?obj ?loc) (at ?airplane ?loc))\n  :effect\n   (and (not (at ?obj ?loc)) (in ?obj ?airplane)))\n\n(:action UNLOAD-TRUCK\n  :parameters\n   (?obj\n    ?truck\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (TRUCK ?truck) (LOCATION ?loc)\n        (at ?truck ?loc) (in ?obj ?truck))\n  :effect\n   (and (not (in ?obj ?truck)) (at ?obj ?loc)))\n\n(:action UNLOAD-AIRPLANE\n  :parameters\n   (?obj\n    ?airplane\n    ?loc)\n  :precondition\n   (and (OBJ ?obj) (AIRPLANE ?airplane) (LOCATION ?loc)\n        (in ?obj ?airplane) (at ?airplane ?loc))\n  :effect\n   (and (not (in ?obj ?airplane)) (at ?obj ?loc)))\n\n(:action DRIVE-TRUCK\n  :parameters\n   (?truck\n    ?loc-from\n    ?loc-to\n    ?city)\n  :precondition\n   (and (TRUCK ?truck) (LOCATION ?loc-from) (LOCATION ?loc-to) (CITY ?city)\n   (at ?truck ?loc-from)\n   (in-city ?loc-from ?city)\n   (in-city ?loc-to ?city))\n  :effect\n   (and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))\n\n(:action FLY-AIRPLANE\n  :parameters\n   (?airplane\n    ?loc-from\n    ?loc-to)\n  :precondition\n   (and (AIRPLANE ?airplane) (AIRPORT ?loc-from) (AIRPORT ?loc-to)\n\t(at ?airplane ?loc-from))\n  :effect\n   (and (not (at ?airplane ?loc-from)) (at ?airplane ?loc-to)))\n)"
    },
    {
        "file_name": "cavediving",
        "pddl_domain": ";; Cave Diving ADL\n;; Authors: Nathan Robinson,\n;;          Christian Muise, and\n;;          Charles Gretton\n\n(define (domain cave-diving-adl)\n  (:requirements :typing :action-costs :adl :conditional-effects)\n  (:types location diver tank quantity)\n  (:predicates\n    (at-tank ?t - tank ?l - location)\n    (in-storage ?t - tank)\n    (full ?t - tank)\n    (next-tank ?t1 - tank ?t2 - tank)\n    (at-diver ?d - diver ?l - location)\n    (available ?d - diver)\n    (at-surface ?d - diver)\n    (decompressing ?d - diver)\n    (precludes ?d1 - diver ?d2 - diver)\n    (cave-entrance ?l - location)\n    (connected ?l1 - location ?l2 - location)\n    (next-quantity ?q1 - quantity ?q2 - quantity)\n    (holding ?d - diver ?t - tank)\n    (capacity ?d - diver ?q - quantity)\n    (have-photo ?l - location)\n    (in-water )\n  )\n\n  (:functions\n    (hiring-cost ?d - diver) - number\n    (other-cost) - number\n    (total-cost) - number\n  )\n\n  (:action hire-diver\n    :parameters (?d1 - diver)\n    :precondition (and      (available ?d1)\n                       (not (in-water)) \n                  )\n    :effect (and (at-surface ?d1)\n                 (not (available ?d1))\n                 (forall (?d2 - diver)\n                     (when (precludes ?d1 ?d2) (not (available ?d2))))\n                 (in-water)\n                 (increase (total-cost) (hiring-cost ?d1))\n            )\n  )\n\n  (:action prepare-tank\n    :parameters (?d - diver ?t1 ?t2 - tank ?q1 ?q2 - quantity)\n    :precondition (and (at-surface ?d)\n                       (in-storage ?t1)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                       (next-tank ?t1 ?t2)\n                  )\n    :effect (and (not (in-storage ?t1))\n                 (not (capacity ?d ?q2))\n                      (in-storage ?t2)\n                      (full ?t1)\n                      (capacity ?d ?q1)\n                      (holding ?d ?t1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action enter-water\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-surface ?d)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-surface ?d))\n                      (at-diver ?d ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action pickup-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (at-tank ?t ?l)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                  )\n    :effect (and (not (at-tank ?t ?l))\n                 (not (capacity ?d ?q2))\n                      (holding ?d ?t)\n                      (capacity ?d ?q1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action drop-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q1)\n                  )\n    :effect (and (not (holding ?d ?t))\n                 (not (capacity ?d ?q1))\n                      (at-tank ?t ?l)\n                      (capacity ?d ?q2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action swim\n    :parameters (?d - diver ?t - tank ?l1 ?l2 - location)\n    :precondition (and (at-diver ?d ?l1)\n                       (holding ?d ?t)\n                       (full ?t)\n                       (connected ?l1 ?l2)\n                  )\n    :effect (and (not (at-diver ?d ?l1))\n                 (not (full ?t))\n                      (at-diver ?d ?l2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action photograph\n    :parameters (?d - diver ?l - location ?t - tank)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (full ?t)\n                  )\n    :effect (and (not (full ?t))\n                      (have-photo ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action decompress\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-diver ?d ?l)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-diver ?d ?l))\n                      (decompressing ?d)\n                 (not (in-water))\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n)\n",
        "batch_id": 2,
        "id": 106,
        "tokens": 6400,
        "corrected_description": "### General\nThis domain models the activities involved in cave diving, including hiring divers, preparing and managing air tanks, entering water, picking up and dropping tanks, swimming between locations, taking photographs underwater, and decompressing after a dive. It incorporates advanced planning features such as action costs and conditional effects.\n\n### Types\n- **location**: Represents different locations in the cave diving scenario.\n- **diver**: Represents the divers involved in the cave diving.\n- **tank**: Represents air tanks used by divers.\n- **quantity**: Represents different quantities of air or capacity.\n\n### Predicates\n- **(at-tank ?t - tank ?l - location)**: Indicates that tank ?t is at location ?l.\n- **(in-storage ?t - tank)**: Indicates that tank ?t is in storage.\n- **(full ?t - tank)**: Indicates that tank ?t is full.\n- **(next-tank ?t1 - tank ?t2 - tank)**: Indicates that tank ?t2 is the next tank after ?t1 in some predefined ordering.\n- **(at-diver ?d - diver ?l - location)**: Indicates that diver ?d is at location ?l.\n- **(available ?d - diver)**: Indicates that diver ?d is available for hire.\n- **(at-surface ?d - diver)**: Indicates that diver ?d is at the surface.\n- **(decompressing ?d - diver)**: Indicates that diver ?d is decompressing.\n- **(precludes ?d1 - diver ?d2 - diver)**: Indicates that hiring diver ?d1 precludes hiring diver ?d2.\n- **(cave-entrance ?l - location)**: Indicates that location ?l is a cave entrance.\n- **(connected ?l1 - location ?l2 - location)**: Indicates that location ?l1 is connected to location ?l2.\n- **(next-quantity ?q1 - quantity ?q2 - quantity)**: Indicates that quantity ?q2 is the next quantity after ?q1 in some predefined ordering.\n- **(holding ?d - diver ?t - tank)**: Indicates that diver ?d is holding tank ?t.\n- **(capacity ?d - diver ?q - quantity)**: Indicates the capacity of air that diver ?d can carry is ?q.\n- **(have-photo ?l - location)**: Indicates that a photo has been taken at location ?l.\n- **(in-water)**: Indicates that some activity is happening in the water.\n\n### Functions\n- **(hiring-cost ?d - diver)**: Represents the cost of hiring diver ?d.\n- **(other-cost)**: Represents other costs associated with actions.\n- **(total-cost)**: Represents the total cost accumulated through actions.\n\n### Actions\n- **hire-diver <?d1>**: Hires a diver (?d1) and increases the total cost by the hiring cost of the diver.  \n\n- **prepare-tank <?d> <?t1> <?t2> <?q1> <?q2>**: Prepares a tank (?t1) for a diver (?d) and increases the total cost by other cost.  \n\n- **enter-water <?d> <?l>**: Enters the water at a cave entrance (?l) and increases the total cost by other cost.  \n\n- **pickup-tank <?d> <?t> <?l> <?q1> <?q2>**: Picks up a tank (?t) at a location (?l) and increases the total cost by other cost.  \n\n- **drop-tank <?d> <?t> <?l> <?q1> <?q2>**: Drops a tank (?t) at a location (?l) and increases the total cost by other cost.  \n\n- **swim <?d> <?t> <?l1> <?l2>**: Swims from one location (?l1) to another location (?l2) while holding a tank (?t) and increases the total cost by other cost.  \n\n- **photograph <?d> <?l> <?t>**: Takes a photograph at a location (?l) while holding a tank (?t) and increases the total cost by other cost.  \n\n- **decompress <?d> <?l>**: Decompresses at a cave entrance (?l) and increases the total cost by other cost.",
        "pddl_domain_processed": "\n\n(define (domain cave-diving-adl)\n  (:requirements :typing :action-costs :adl :conditional-effects)\n  (:types location diver tank quantity)\n  (:predicates\n    (at-tank ?t - tank ?l - location)\n    (in-storage ?t - tank)\n    (full ?t - tank)\n    (next-tank ?t1 - tank ?t2 - tank)\n    (at-diver ?d - diver ?l - location)\n    (available ?d - diver)\n    (at-surface ?d - diver)\n    (decompressing ?d - diver)\n    (precludes ?d1 - diver ?d2 - diver)\n    (cave-entrance ?l - location)\n    (connected ?l1 - location ?l2 - location)\n    (next-quantity ?q1 - quantity ?q2 - quantity)\n    (holding ?d - diver ?t - tank)\n    (capacity ?d - diver ?q - quantity)\n    (have-photo ?l - location)\n    (in-water )\n  )\n\n  (:functions\n    (hiring-cost ?d - diver) - number\n    (other-cost) - number\n    (total-cost) - number\n  )\n\n  (:action hire-diver\n    :parameters (?d1 - diver)\n    :precondition (and      (available ?d1)\n                       (not (in-water)) \n                  )\n    :effect (and (at-surface ?d1)\n                 (not (available ?d1))\n                 (forall (?d2 - diver)\n                     (when (precludes ?d1 ?d2) (not (available ?d2))))\n                 (in-water)\n                 (increase (total-cost) (hiring-cost ?d1))\n            )\n  )\n\n  (:action prepare-tank\n    :parameters (?d - diver ?t1 ?t2 - tank ?q1 ?q2 - quantity)\n    :precondition (and (at-surface ?d)\n                       (in-storage ?t1)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                       (next-tank ?t1 ?t2)\n                  )\n    :effect (and (not (in-storage ?t1))\n                 (not (capacity ?d ?q2))\n                      (in-storage ?t2)\n                      (full ?t1)\n                      (capacity ?d ?q1)\n                      (holding ?d ?t1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action enter-water\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-surface ?d)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-surface ?d))\n                      (at-diver ?d ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action pickup-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (at-tank ?t ?l)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q2)\n                  )\n    :effect (and (not (at-tank ?t ?l))\n                 (not (capacity ?d ?q2))\n                      (holding ?d ?t)\n                      (capacity ?d ?q1)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action drop-tank\n    :parameters (?d - diver ?t - tank ?l - location ?q1 ?q2 - quantity)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (next-quantity ?q1 ?q2)\n                       (capacity ?d ?q1)\n                  )\n    :effect (and (not (holding ?d ?t))\n                 (not (capacity ?d ?q1))\n                      (at-tank ?t ?l)\n                      (capacity ?d ?q2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action swim\n    :parameters (?d - diver ?t - tank ?l1 ?l2 - location)\n    :precondition (and (at-diver ?d ?l1)\n                       (holding ?d ?t)\n                       (full ?t)\n                       (connected ?l1 ?l2)\n                  )\n    :effect (and (not (at-diver ?d ?l1))\n                 (not (full ?t))\n                      (at-diver ?d ?l2)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action photograph\n    :parameters (?d - diver ?l - location ?t - tank)\n    :precondition (and (at-diver ?d ?l)\n                       (holding ?d ?t)\n                       (full ?t)\n                  )\n    :effect (and (not (full ?t))\n                      (have-photo ?l)\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n  (:action decompress\n    :parameters (?d - diver ?l - location)\n    :precondition (and (at-diver ?d ?l)\n                       (cave-entrance ?l)\n                  )\n    :effect (and (not (at-diver ?d ?l))\n                      (decompressing ?d)\n                 (not (in-water))\n                 (increase (total-cost) (other-cost ))\n            )\n  )\n\n)\n"
    },
    {
        "file_name": "hiking",
        "pddl_domain": ";  (c) 2001 Copyright (c) University of Huddersfield\n;  Automatically produced from GIPO from the domain hiking\n;  All rights reserved. Use of this software is permitted for non-commercial\n;  research purposes, and it may be copied only for that use.  All copies must\n;  include this copyright message.  This software is made available AS IS, and\n;  neither the GIPO team nor the University of Huddersfield make any warranty about\n;  the software or its performance.\n\n(define (domain hiking)\n  (:requirements :strips :equality :typing :negative-preconditions)\n  (:types car tent person couple place )\n  (:predicates \n              (at_tent ?x1 - tent ?x2 - place)\n              (at_person ?x1 - person ?x2 - place)\n              (at_car ?x1 - car ?x2 - place)\n              (partners ?x1 - couple ?x2 - person ?x3 - person)\n              (up ?x1 - tent)\n              (down ?x1 - tent)\n              (walked ?x1 - couple ?x2 - place)\n              (next ?x1 - place ?x2 - place)\n)\n\n  (:action put_down\n         :parameters ( ?x1 - person ?x2 - place ?x3 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_tent ?x3 ?x2)(up ?x3))\n         :effect (and (down ?x3)(not (up ?x3))\n)\n)\n  (:action put_up\n         :parameters ( ?x1 - person ?x2 - place ?x3 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_tent ?x3 ?x2)(down ?x3))\n         :effect (and (up ?x3)(not (down ?x3))\n)\n)\n  (:action drive_passenger\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - person)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_person ?x5 ?x2)(not (= ?x1 ?x5)))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_person ?x5 ?x3)(not (at_person ?x5 ?x2))\n)\n)\n  (:action drive\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n)\n)\n  (:action drive_tent\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_tent ?x5 ?x2)(down ?x5))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_tent ?x5 ?x3)(not (at_tent ?x5 ?x2))\n)\n)\n  (:action drive_tent_passenger\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - tent ?x6 - person)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_tent ?x5 ?x2)(down ?x5)(at_person ?x6 ?x2)(not (= ?x1 ?x6)))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_tent ?x5 ?x3)(not (at_tent ?x5 ?x2))\n(at_person ?x6 ?x3)(not (at_person ?x6 ?x2))\n)\n)\n  (:action walk_together\n         :parameters ( ?x1 - tent ?x2 - place ?x3 - person ?x4 - place ?x5 - person ?x6 - couple)\n         :precondition (and \n(at_tent ?x1 ?x2)(up ?x1)(at_person ?x3 ?x4)(next ?x4 ?x2)(at_person ?x5 ?x4)(not (= ?x3 ?x5))(walked ?x6 ?x4)(partners ?x6 ?x3 ?x5))\n         :effect (and (at_person ?x3 ?x2)(not (at_person ?x3 ?x4))\n(at_person ?x5 ?x2)(not (at_person ?x5 ?x4))\n(walked ?x6 ?x2)(not (walked ?x6 ?x4))\n)\n)\n\n)\n\n",
        "batch_id": 2,
        "id": 108,
        "tokens": 6344,
        "corrected_description": "### General\nThe domain of hiking involves scenarios where individuals or couples go hiking, involving activities such as setting up tents, walking together, and driving between different places. The domain models the interactions between people, tents, cars, and places, focusing on the logistics of moving around and setting up camp.\n\n### Types\n- **car**: Represents vehicles used by hikers to move between places.\n- **tent**: Represents tents that hikers set up at places.\n- **person**: Represents individuals who are hiking.\n- **couple**: Represents pairs of individuals who are hiking together.\n- **place**: Represents locations where hiking activities occur.\n\n### Predicates\n- **(at_tent ?x1 - tent ?x2 - place)**: Indicates that tent ?x1 is at place ?x2.\n- **(at_person ?x1 - person ?x2 - place)**: Indicates that person ?x1 is at place ?x2.\n- **(at_car ?x1 - car ?x2 - place)**: Indicates that car ?x1 is at place ?x2.\n- **(partners ?x1 - couple ?x2 - person ?x3 - person)**: Indicates that person ?x2 and person ?x3 form a couple ?x1.\n- **(up ?x1 - tent)**: Indicates that tent ?x1 is set up.\n- **(down ?x1 - tent)**: Indicates that tent ?x1 is not set up.\n- **(walked ?x1 - couple ?x2 - place)**: Indicates that couple ?x1 has walked to place ?x2.\n- **(next ?x1 - place ?x2 - place)**: Indicates that place ?x1 is next to place ?x2.\n\n### Actions\n- **put_down <?x1 - person> <?x2 - place> <?x3 - tent>**: Allows a person to put down a tent at a place. The tent must be currently up.  \n\n- **put_up <?x1 - person> <?x2 - place> <?x3 - tent>**: Allows a person to set up a tent at a place. The tent must be currently down.  \n\n- **drive_passenger <?x1 - person> <?x2 - place> <?x3 - place> <?x4 - car> <?x5 - person>**: Allows a person to drive another person from one place ?x2 to another ?x3 in a car.  \n\n- **drive <?x1 - person> <?x2 - place> <?x3 - place> <?x4 - car>**: Allows a person to drive from one place ?x2 to another ?x3 in a car.  \n\n- **drive_tent <?x1 - person> <?x2 - place> <?x3 - place> <?x4 - car> <?x5 - tent>**: Allows a person to drive with a tent from one place ?x2 to another ?x3 in a car. The tent must be down.  \n\n- **drive_tent_passenger <?x1 - person> <?x2 - place> <?x3 - place> <?x4 - car> <?x5 - tent> <?x6 - person>**: Allows a person to drive with another person and a tent from one place ?x2 to another ?x3 in a car. The tent must be down.  \n\n- **walk_together <?x1 - tent> <?x2 - place> <?x3 - person> <?x4 - place> <?x5 - person> <?x6 - couple>**: Allows a couple to walk together from one place ?x4 to another ?x2, where a tent is set up. The couple must have previously walked to the starting place.",
        "pddl_domain_processed": "\n\n(define (domain hiking)\n  (:requirements :strips :equality :typing :negative-preconditions)\n  (:types car tent person couple place )\n  (:predicates \n              (at_tent ?x1 - tent ?x2 - place)\n              (at_person ?x1 - person ?x2 - place)\n              (at_car ?x1 - car ?x2 - place)\n              (partners ?x1 - couple ?x2 - person ?x3 - person)\n              (up ?x1 - tent)\n              (down ?x1 - tent)\n              (walked ?x1 - couple ?x2 - place)\n              (next ?x1 - place ?x2 - place)\n)\n\n  (:action put_down\n         :parameters ( ?x1 - person ?x2 - place ?x3 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_tent ?x3 ?x2)(up ?x3))\n         :effect (and (down ?x3)(not (up ?x3))\n)\n)\n  (:action put_up\n         :parameters ( ?x1 - person ?x2 - place ?x3 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_tent ?x3 ?x2)(down ?x3))\n         :effect (and (up ?x3)(not (down ?x3))\n)\n)\n  (:action drive_passenger\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - person)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_person ?x5 ?x2)(not (= ?x1 ?x5)))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_person ?x5 ?x3)(not (at_person ?x5 ?x2))\n)\n)\n  (:action drive\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n)\n)\n  (:action drive_tent\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - tent)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_tent ?x5 ?x2)(down ?x5))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_tent ?x5 ?x3)(not (at_tent ?x5 ?x2))\n)\n)\n  (:action drive_tent_passenger\n         :parameters ( ?x1 - person ?x2 - place ?x3 - place ?x4 - car ?x5 - tent ?x6 - person)\n         :precondition (and \n(at_person ?x1 ?x2)(at_car ?x4 ?x2)(at_tent ?x5 ?x2)(down ?x5)(at_person ?x6 ?x2)(not (= ?x1 ?x6)))\n         :effect (and (at_person ?x1 ?x3)(not (at_person ?x1 ?x2))\n(at_car ?x4 ?x3)(not (at_car ?x4 ?x2))\n(at_tent ?x5 ?x3)(not (at_tent ?x5 ?x2))\n(at_person ?x6 ?x3)(not (at_person ?x6 ?x2))\n)\n)\n  (:action walk_together\n         :parameters ( ?x1 - tent ?x2 - place ?x3 - person ?x4 - place ?x5 - person ?x6 - couple)\n         :precondition (and \n(at_tent ?x1 ?x2)(up ?x1)(at_person ?x3 ?x4)(next ?x4 ?x2)(at_person ?x5 ?x4)(not (= ?x3 ?x5))(walked ?x6 ?x4)(partners ?x6 ?x3 ?x5))\n         :effect (and (at_person ?x3 ?x2)(not (at_person ?x3 ?x4))\n(at_person ?x5 ?x2)(not (at_person ?x5 ?x4))\n(walked ?x6 ?x2)(not (walked ?x6 ?x4))\n)\n)\n\n)\n\n"
    },
    {
        "file_name": "snake",
        "pddl_domain": "; Snake is not a game where everything is known a priori. \n; Therefore we make two modifications: \n; 1. The player knows where points will spawn. \n; 2. Points can spawn inside the snake, but they can only be collected by the head of the snake.\n; 3. There is a constant number of points at a time and no two points can spawn in the same location\n; Based on the submission\n\n(define (domain snake)\n\t(:requirements :strips :negative-preconditions)\n\n\t(:constants dummyPoint)\n\n\t(:predicates \n\t\t(isAdjacent ?x ?y) ;up down left right of a field\n\t\t(tailSnake ?x) ;the last field of the snake\n\t\t(headSnake ?x) ;the first field of the snake\n                (nextSnake ?x ?y) ;pieces of the snake that are connected. from front to back\n\t\t(blocked ?x) ;a field that is occupied by the snake or by an obstacle\n\t\t(spawn ?x) ;next point that will spawn\n\t\t(nextSpawn ?x ?y) ;point y will spawn after point x\n\t\t(isPoint ?x) ;a field that has a point that can be collected by the snake\n\t)\n\n\t(:action move\n\t\t:parameters (?head ?newHead ?tail ?newTail)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n         \t\t(tailSnake ?tail)\n\t\t\t(nextSnake ?newTail ?tail)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(not (isPoint ?newHead))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (blocked ?tail))\n\t\t\t(not (tailSnake ?tail))\n\t\t\t(not (nextSnake ?newTail ?tail))\n\t\t\t(tailSnake ?newTail)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-spawn\n\t\t:parameters  (?head ?newHead ?spawnPoint ?nextSpawnPoint)\n\t\t:precondition (and\n\t\t\t      (headSnake ?head)\n\t\t\t      (isAdjacent ?head ?newHead)\n\t\t\t      (not (blocked ?newHead))\n\t\t\t      (isPoint ?newHead)\n\t\t\t      (spawn ?spawnPoint)\n\t\t\t      (nextSpawn ?spawnPoint ?nextSpawnPoint)\n\t\t\t      (not (= ?spawnPoint dummyPoint))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t(isPoint ?spawnPoint)\n\t\t\t(not (spawn ?spawnPoint))\n\t\t\t(spawn ?nextSpawnPoint)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-no-spawn\n\t\t:parameters  (?head ?newHead)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(isPoint ?newHead)\n\t\t\t(spawn dummyPoint)\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t)\n\t)\n)",
        "batch_id": 2,
        "id": 109,
        "tokens": 5864,
        "corrected_description": "### General\nThis domain models a simplified version of the classic Snake game, incorporating elements such as the snake's movement, point collection, and the spawning of points on the game field. The game is adapted to a planning environment by assuming the player knows where and in what order points will spawn. Points can spawn inside the snake but are only collectible by the snake's head. The domain ensures a constant number of points at any time and prevents points from spawning in the same location.\n\n### Predicates\n- (isAdjacent ?x ?y): Determines if two fields are adjacent (up, down, left, right) to each other.\n- (tailSnake ?x): Identifies the tail (last field) of the snake.\n- (headSnake ?x): Identifies the head (first field) of the snake.\n- (nextSnake ?x ?y): Connects pieces of the snake from front to back, indicating which piece follows which.\n- (blocked ?x): Marks a field as occupied by the snake or an obstacle, making it impassable.\n- (spawn ?x): Marks the next point that will spawn on the field.\n- (nextSpawn ?x ?y): Indicates that point y will spawn after point x, establishing an order of spawning.\n- (isPoint ?x): Marks a field as containing a point that can be collected by the snake.\n\n### Actions\n- **move <?head> <?newHead> <?tail> <?newTail>**: Allows the snake to move to a new position by updating the head and tail positions. \n\n- **move-and-eat-spawn <?head> <?newHead> <?spawnPoint> <?nextSpawnPoint>**: Allows the snake to move to a new position and eat a spawn point, while also updating the spawn points.  \n\n- **move-and-eat-no-spawn <?head> <?newHead>**: Allows the snake to move to a new position and eat a point when no new spawn points are available.",
        "pddl_domain_processed": "\n\n(define (domain snake)\n\t(:requirements :strips :negative-preconditions)\n\n\t(:constants dummyPoint)\n\n\t(:predicates \n\t\t(isAdjacent ?x ?y) \n\t\t(tailSnake ?x) \n\t\t(headSnake ?x) \n                (nextSnake ?x ?y) \n\t\t(blocked ?x) \n\t\t(spawn ?x) \n\t\t(nextSpawn ?x ?y) \n\t\t(isPoint ?x) \n\t)\n\n\t(:action move\n\t\t:parameters (?head ?newHead ?tail ?newTail)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n         \t\t(tailSnake ?tail)\n\t\t\t(nextSnake ?newTail ?tail)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(not (isPoint ?newHead))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (blocked ?tail))\n\t\t\t(not (tailSnake ?tail))\n\t\t\t(not (nextSnake ?newTail ?tail))\n\t\t\t(tailSnake ?newTail)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-spawn\n\t\t:parameters  (?head ?newHead ?spawnPoint ?nextSpawnPoint)\n\t\t:precondition (and\n\t\t\t      (headSnake ?head)\n\t\t\t      (isAdjacent ?head ?newHead)\n\t\t\t      (not (blocked ?newHead))\n\t\t\t      (isPoint ?newHead)\n\t\t\t      (spawn ?spawnPoint)\n\t\t\t      (nextSpawn ?spawnPoint ?nextSpawnPoint)\n\t\t\t      (not (= ?spawnPoint dummyPoint))\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t(isPoint ?spawnPoint)\n\t\t\t(not (spawn ?spawnPoint))\n\t\t\t(spawn ?nextSpawnPoint)\n\t\t\t)\n\t)\n\n\t(:action move-and-eat-no-spawn\n\t\t:parameters  (?head ?newHead)\n\t\t:precondition (and\n\t\t\t(headSnake ?head)\n\t\t\t(isAdjacent ?head ?newHead)\n\t\t\t(not (blocked ?newHead))\n\t\t\t(isPoint ?newHead)\n\t\t\t(spawn dummyPoint)\n\t\t)\n        \t:effect (and\n\t\t\t(blocked ?newHead)\n\t\t\t(headSnake ?newHead)\n\t\t\t(nextSnake ?newHead ?head)\n\t\t\t(not (headSnake ?head))\n\t\t\t(not (isPoint ?newHead))\n\t\t\t)\n\t)\n)"
    },
    {
        "file_name": "sokoban",
        "pddl_domain": "(define (domain typed-sokoban)\n(:requirements :typing)\n(:types LOC DIR BOX)\n(:predicates \n             (at-robot ?l - LOC)\n             (at ?o - BOX ?l - LOC)\n             (adjacent ?l1 - LOC ?l2 - LOC ?d - DIR) \n             (clear ?l - LOC)\n)\n\n\n(:action move\n:parameters (?from - LOC ?to - LOC ?dir - DIR)\n:precondition (and (clear ?to) (at-robot ?from) (adjacent ?from ?to ?dir))\n:effect (and (at-robot ?to) (not (at-robot ?from)))\n)\n             \n\n(:action push\n:parameters  (?rloc - LOC ?bloc - LOC ?floc - LOC ?dir - DIR ?b - BOX)\n:precondition (and (at-robot ?rloc) (at ?b ?bloc) (clear ?floc)\n\t           (adjacent ?rloc ?bloc ?dir) (adjacent ?bloc ?floc ?dir))\n\n:effect (and (at-robot ?bloc) (at ?b ?floc) (clear ?bloc)\n             (not (at-robot ?rloc)) (not (at ?b ?bloc)) (not (clear ?floc)))\n)\n)\n\n\n",
        "batch_id": 2,
        "id": 110,
        "tokens": 5063,
        "corrected_description": "### General\nYou are controlling a robot in a Sokoban-like environment where the goal is to move boxes to specific locations. The domain involves navigating the robot, moving boxes, and understanding the layout of the environment, including locations and directions.\n\n### Types\n- LOC: Represents locations in the environment.\n- DIR: Represents directions that can be used to navigate between locations.\n- BOX: Represents the boxes that need to be moved to solve the puzzle.\n\n### Predicates\n- (at-robot ?l - LOC): Indicates that the robot is at location ?l.\n- (at ?o - BOX ?l - LOC): Indicates that box ?o is at location ?l.\n- (adjacent ?l1 - LOC ?l2 - LOC ?d - DIR): Indicates that location ?l1 is adjacent to location ?l2 in direction ?d.\n- (clear ?l - LOC): Indicates that location ?l is clear of any boxes.\n\n### Actions\n- **move <?from> <?to> <?dir>**: Allows the robot to move from one location to another. \n  \n- **push <?rloc> <?bloc> <?floc> <?dir> <?b>**: Allows the robot to push a box from its current location to a new location.",
        "pddl_domain_processed": "(define (domain typed-sokoban)\n(:requirements :typing)\n(:types LOC DIR BOX)\n(:predicates \n             (at-robot ?l - LOC)\n             (at ?o - BOX ?l - LOC)\n             (adjacent ?l1 - LOC ?l2 - LOC ?d - DIR) \n             (clear ?l - LOC)\n)\n\n(:action move\n:parameters (?from - LOC ?to - LOC ?dir - DIR)\n:precondition (and (clear ?to) (at-robot ?from) (adjacent ?from ?to ?dir))\n:effect (and (at-robot ?to) (not (at-robot ?from)))\n)\n\n(:action push\n:parameters  (?rloc - LOC ?bloc - LOC ?floc - LOC ?dir - DIR ?b - BOX)\n:precondition (and (at-robot ?rloc) (at ?b ?bloc) (clear ?floc)\n\t           (adjacent ?rloc ?bloc ?dir) (adjacent ?bloc ?floc ?dir))\n\n:effect (and (at-robot ?bloc) (at ?b ?floc) (clear ?bloc)\n             (not (at-robot ?rloc)) (not (at ?b ?bloc)) (not (clear ?floc)))\n)\n)\n\n"
    },
    {
        "file_name": "mcdickenson_cs570_matt-dickenson-domain.pddl",
        "pddl_domain": "(define (domain family-domain)\n  (:requirements :equality)\n  (:predicates (male ?x) (female ?x) (not-yet-born ?x) (is-parent-of ?x ?y)\n  (is-child-of ?x ?y) (is-sibling-of ?x ?y) (is-uncle-or-aunt-of ?x ?y)\n  (is-nephew-or-niece-of ?x ?y)\n  (is-granduncle-or-grandaunt-of ?x ?y)\n  (is-grandnephew-or-grandniece-of ?x ?y)) \n  (:action give-birth-to-son\n   \t   :parameters (?father ?mother ?child)\n  \t   :precondition (and (male ?father)\n\t   \t\t      (female ?mother)\n\t\t\t      (not-yet-born ?child))\n\t   :effect (and (not (not-yet-born ?child))\n\t   \t   \t(male ?child)\n\t\t\t(is-parent-of ?father ?child)\n\t\t\t(is-parent-of ?mother ?child)\n\t\t\t(is-child-of ?child ?father)\n\t\t\t(is-child-of ?child ?mother)))\n  (:action give-birth-to-daughter\n           :parameters (?father ?mother ?child)\n           :precondition (and (male ?father)\n                              (female ?mother)\n                              (not-yet-born ?child))\n           :effect (and (not (not-yet-born ?child))\n                        (female ?child)\n                        (is-parent-of ?father ?child)\n                        (is-parent-of ?mother ?child)\n                        (is-child-of ?child ?father)\n                        (is-child-of ?child ?mother)))\n  (:action conclude-siblings\n  \t   :parameters (?parent ?child1 ?child2)\n\t   :precondition (and (is-parent-of ?parent ?child1)\n\t   \t\t      (is-parent-of ?parent ?child2))\n\t   :effect (and (is-sibling-of ?child1 ?child2) (is-sibling-of ?child2 ?child1)))\n  (:action conclude-uncle-aunt-nephew-niece\n  \t   :parameters (?aunt ?parent ?child)\n\t   :precondition (and (is-parent-of ?parent ?child)\n\t   \t\t      (is-sibling-of ?aunt ?parent))\n           :effect (and (is-uncle-or-aunt-of ?aunt ?child)\n\t   \t   \t(is-nephew-or-niece-of ?child ?aunt)))\n  (:action conclude-granduncle-grandaunt\n       :parameters (?granduncle ?parent ?child)\n     :precondition (and (is-parent-of ?parent ?child)\n              (is-nephew-or-niece-of ?parent ?granduncle))\n           :effect  (and(is-granduncle-or-grandaunt-of ?granduncle ?child)\n           (is-grandnephew-or-grandniece-of ?child ?granduncle))))\n",
        "batch_id": 3,
        "id": 118,
        "tokens": 5685,
        "corrected_description": "### General\nThis domain models family relationships and events such as birth and the establishment of various familial connections like parent-child, siblings, and extended family relations including uncles, aunts, and grandparents. It allows for the simulation of family trees and the dynamics within them.\n\n### Predicates\n(male ?x): Indicates that ?x is male.\n(female ?x): Indicates that ?x is female.\n(not-yet-born ?x): Indicates that ?x has not yet been born.\n(is-parent-of ?x ?y): Indicates that ?x is a parent of ?y.\n(is-child-of ?x ?y): Indicates that ?x is a child of ?y.\n(is-sibling-of ?x ?y): Indicates that ?x is a sibling of ?y.\n(is-uncle-or-aunt-of ?x ?y): Indicates that ?x is an uncle or aunt of ?y.\n(is-nephew-or-niece-of ?x ?y): Indicates that ?x is a nephew or niece of ?y.\n(is-granduncle-or-grandaunt-of ?x ?y): Indicates that ?x is a granduncle or grandaunt of ?y.\n(is-grandnephew-or-grandniece-of ?x ?y): Indicates that ?x is a grandnephew or grandniece of ?y.\n\n### Actions\n- **give-birth-to-son <?father> <?mother> <?child>**: This action models the birth of a son to a father and mother, establishing the child as male and creating parent-child relationships.  \n\n- **give-birth-to-daughter <?father> <?mother> <?child>**: This action models the birth of a daughter to a father and mother, establishing the child as female and creating parent-child relationships.  \n\n- **conclude-siblings <?parent> <?child1> <?child2>**: This action establishes two individuals as siblings if they share at least one parent.  \n\n- **conclude-uncle-aunt-nephew-niece <?aunt> <?parent> <?child>**: This action establishes the relationship between an aunt or uncle and their nephew or niece.  \n\n- **conclude-granduncle-grandaunt <?granduncle> <?parent> <?child>**: This action establishes the relationship between a granduncle or grandaunt and their grandnephew or grandniece.",
        "pddl_domain_processed": "(define (domain family-domain)\n  (:requirements :equality)\n  (:predicates (male ?x) (female ?x) (not-yet-born ?x) (is-parent-of ?x ?y)\n  (is-child-of ?x ?y) (is-sibling-of ?x ?y) (is-uncle-or-aunt-of ?x ?y)\n  (is-nephew-or-niece-of ?x ?y)\n  (is-granduncle-or-grandaunt-of ?x ?y)\n  (is-grandnephew-or-grandniece-of ?x ?y)) \n  (:action give-birth-to-son\n   \t   :parameters (?father ?mother ?child)\n  \t   :precondition (and (male ?father)\n\t   \t\t      (female ?mother)\n\t\t\t      (not-yet-born ?child))\n\t   :effect (and (not (not-yet-born ?child))\n\t   \t   \t(male ?child)\n\t\t\t(is-parent-of ?father ?child)\n\t\t\t(is-parent-of ?mother ?child)\n\t\t\t(is-child-of ?child ?father)\n\t\t\t(is-child-of ?child ?mother)))\n  (:action give-birth-to-daughter\n           :parameters (?father ?mother ?child)\n           :precondition (and (male ?father)\n                              (female ?mother)\n                              (not-yet-born ?child))\n           :effect (and (not (not-yet-born ?child))\n                        (female ?child)\n                        (is-parent-of ?father ?child)\n                        (is-parent-of ?mother ?child)\n                        (is-child-of ?child ?father)\n                        (is-child-of ?child ?mother)))\n  (:action conclude-siblings\n  \t   :parameters (?parent ?child1 ?child2)\n\t   :precondition (and (is-parent-of ?parent ?child1)\n\t   \t\t      (is-parent-of ?parent ?child2))\n\t   :effect (and (is-sibling-of ?child1 ?child2) (is-sibling-of ?child2 ?child1)))\n  (:action conclude-uncle-aunt-nephew-niece\n  \t   :parameters (?aunt ?parent ?child)\n\t   :precondition (and (is-parent-of ?parent ?child)\n\t   \t\t      (is-sibling-of ?aunt ?parent))\n           :effect (and (is-uncle-or-aunt-of ?aunt ?child)\n\t   \t   \t(is-nephew-or-niece-of ?child ?aunt)))\n  (:action conclude-granduncle-grandaunt\n       :parameters (?granduncle ?parent ?child)\n     :precondition (and (is-parent-of ?parent ?child)\n              (is-nephew-or-niece-of ?parent ?granduncle))\n           :effect  (and(is-granduncle-or-grandaunt-of ?granduncle ?child)\n           (is-grandnephew-or-grandniece-of ?child ?granduncle))))\n"
    },
    {
        "file_name": "itl-ed_llm-dp_alfworld_domain.pddl",
        "pddl_domain": "(define (domain alfred)\n    (:predicates\n        (isReceptacle ?o - object) ; true if the object is a receptacle\n        (atReceptacleLocation ?r - object) ; true if the robot is at the receptacle location\n        (inReceptacle ?o - object ?r - object) ; true if object ?o is in receptacle ?r\n        (openable ?r - object) ; true if a receptacle is openable\n        (opened ?r - object) ; true if a receptacle is opened\n        (isLight ?o - object) ; true if an object is light source\n        (examined ?o - object ?l - object) ; whether the object has been looked at with light\n        (holds ?o - object) ; object ?o is held by robot\n        (isClean ?o - object) ; true if the object has been cleaned in sink\n        (isHot ?o - object) ; true if the object has been heated up\n        (isCool ?o - object) ; true if the object has been cooled\n        (isSink ?o - object) ; true if the object is a sink\n        (isMicrowave ?o - object) ; true if the object is a microwave\n        (isFridge ?o - object) ; true if the object is a fridge\n    )\n\n    ;; Examine an object (being held) using light source at location\n    (:action examineObjectInLight\n        :parameters (?o - object ?l - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isLight ?l) ; is light source\n            (holds ?o) ; agent holds object\n            (atReceptacleLocation ?r) ; agent is at receptacle\n            (inReceptacle ?l ?r) ; light source is in receptacle\n            (or\n                (not (openable ?r)) ; receptacle is not openable\n                (opened ?r) ; object is in receptacle and receptacle is open\n            )\n        )\n        :effect (examined ?o ?l)\n    )\n\n    ;; robot goes to receptacle\n    (:action GotoReceptacle\n        :parameters (?rEnd - object)\n        :precondition (isReceptacle ?rEnd)\n        :effect (and\n            (atReceptacleLocation ?rEnd)\n            (forall\n                (?r - object)\n                (when\n                    (and\n                        (isReceptacle ?r)\n                        (not (= ?r ?rEnd))\n                    )\n                    (not (atReceptacleLocation ?r))\n                )\n            )\n        )\n    )\n\n    ; ;; robot opens receptacle\n    (:action OpenReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (not (opened ?r))\n        )\n        :effect (opened ?r)\n    )\n\n    ;; robot closes receptacle\n    (:action CloseReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n\n    ;; robot picks up  object  from a receptacle\n    (:action PickupObjectFromReceptacle\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r) ; agent is at receptacle\n            (inReceptacle ?o ?r) ; object is in/on receptacle\n            (not (isLight ?o)) ; object is not light source\n            (forall ; agent's hands are empty.\n                (?t - object)\n                (not (holds ?t))\n            )\n            (or\n                (not (openable ?r)) ; receptacle is not openable\n                (opened ?r) ; object is in receptacle and receptacle is open\n            )\n        )\n        :effect (and\n            (not (inReceptacle ?o ?r)) ; object is not in receptacle\n            (holds ?o) ; agent holds object\n        )\n    )\n\n    ;; robot puts down an object\n    (:action PutObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n            (or (not (openable ?r)) (opened ?r)) ; receptacle is opened if it is openable\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n            (not (holds ?o))\n        )\n    )\n\n    ; ;; agent cleans some object\n    (:action CleanObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isSink ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (isClean ?o)\n    )\n\n    ;; robot heats-up some object\n    (:action HeatObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isMicrowave ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isHot ?o)\n            (not (isCool ?o))\n        )\n    )\n\n    ;; robot cools some object\n    (:action CoolObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isFridge ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isCool ?o)\n            (not (isHot ?o))\n        )\n    )\n)",
        "batch_id": 3,
        "id": 119,
        "tokens": 6438,
        "corrected_description": "### General\nYou are a robot named Alfred involved in various household tasks such as cleaning, heating, cooling objects, and managing items within receptacles like sinks, microwaves, and fridges. The domain focuses on the manipulation of objects and receptacles, including opening and closing receptacles, examining objects with light, and changing the state of objects (clean, hot, cool).\n\n### Predicates\n- (isReceptacle ?o): True if the object is a receptacle.\n- (atReceptacleLocation ?r): True if the robot is at the receptacle location.\n- (inReceptacle ?o ?r): True if object ?o is in receptacle ?r.\n- (openable ?r): True if a receptacle is openable.\n- (opened ?r): True if a receptacle is opened.\n- (isLight ?o): True if an object is a light source.\n- (examined ?o ?l): True if the object has been examined with light.\n- (holds ?o): True if the robot is holding object ?o.\n- (isClean ?o): True if the object has been cleaned in a sink.\n- (isHot ?o): True if the object has been heated up.\n- (isCool ?o): True if the object has been cooled.\n- (isSink ?o): True if the object is a sink.\n- (isMicrowave ?o): True if the object is a microwave.\n- (isFridge ?o): True if the object is a fridge.\n\n### Actions\n- **examineObjectInLight <?o> <?l> <?r>**: Allows the robot to examine an object it is holding using a light source at a receptacle location. The object is considered examined after this action.  \n\n- **GotoReceptacle <?rEnd>**: Moves the robot to a specified receptacle location. This action ensures the robot is no longer at any other receptacle locations.  \n\n- **OpenReceptacle <?r>**: Opens a receptacle.  \n\n- **CloseReceptacle <?r>**: Closes an openable receptacle.  \n\n- **PickupObjectFromReceptacle <?o> <?r>**: Allows the robot to pick up an object from a receptacle which is open or not openable.  \n\n- **PutObject <?o> <?r>**: Places an object the robot is holding into a receptacle which is open or not openable.  \n\n- **CleanObject <?o> <?r>**: Cleans an object the robot is holding, provided the robot is at a sink.  \n\n- **HeatObject <?o> <?r>**: Heats an object the robot is holding, provided the robot is at a microwave.  \n\n- **CoolObject <?o> <?r>**: Cools an object the robot is holding, provided the robot is at a fridge.",
        "pddl_domain_processed": "(define (domain alfred)\n    (:predicates\n        (isReceptacle ?o - object) \n        (atReceptacleLocation ?r - object) \n        (inReceptacle ?o - object ?r - object) \n        (openable ?r - object) \n        (opened ?r - object) \n        (isLight ?o - object) \n        (examined ?o - object ?l - object) \n        (holds ?o - object) \n        (isClean ?o - object) \n        (isHot ?o - object) \n        (isCool ?o - object) \n        (isSink ?o - object) \n        (isMicrowave ?o - object) \n        (isFridge ?o - object) \n    )\n\n    (:action examineObjectInLight\n        :parameters (?o - object ?l - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isLight ?l) \n            (holds ?o) \n            (atReceptacleLocation ?r) \n            (inReceptacle ?l ?r) \n            (or\n                (not (openable ?r)) \n                (opened ?r) \n            )\n        )\n        :effect (examined ?o ?l)\n    )\n\n    (:action GotoReceptacle\n        :parameters (?rEnd - object)\n        :precondition (isReceptacle ?rEnd)\n        :effect (and\n            (atReceptacleLocation ?rEnd)\n            (forall\n                (?r - object)\n                (when\n                    (and\n                        (isReceptacle ?r)\n                        (not (= ?r ?rEnd))\n                    )\n                    (not (atReceptacleLocation ?r))\n                )\n            )\n        )\n    )\n\n    (:action OpenReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (not (opened ?r))\n        )\n        :effect (opened ?r)\n    )\n\n    (:action CloseReceptacle\n        :parameters (?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (openable ?r)\n            (atReceptacleLocation ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n\n    (:action PickupObjectFromReceptacle\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r) \n            (inReceptacle ?o ?r) \n            (not (isLight ?o)) \n            (forall \n                (?t - object)\n                (not (holds ?t))\n            )\n            (or\n                (not (openable ?r)) \n                (opened ?r) \n            )\n        )\n        :effect (and\n            (not (inReceptacle ?o ?r)) \n            (holds ?o) \n        )\n    )\n\n    (:action PutObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n            (or (not (openable ?r)) (opened ?r)) \n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n            (not (holds ?o))\n        )\n    )\n\n    (:action CleanObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isSink ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (isClean ?o)\n    )\n\n    (:action HeatObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isMicrowave ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isHot ?o)\n            (not (isCool ?o))\n        )\n    )\n\n    (:action CoolObject\n        :parameters (?o - object ?r - object)\n        :precondition (and\n            (isReceptacle ?r)\n            (isFridge ?r)\n            (atReceptacleLocation ?r)\n            (holds ?o)\n        )\n        :effect (and\n            (isCool ?o)\n            (not (isHot ?o))\n        )\n    )\n)"
    },
    {
        "file_name": "TeamSPoon_old_logicmoo_workspace_tsp-domain.pddl",
        "pddl_domain": ";;;\n;;; TSP problem in PDDL.\n;;;\n;;; From Graphplan's tsp_ops\n;;;\n;;; Note: Here we handle just the connections, not trying to \n;;; minimize any costs.\n;;;;\n(define (domain tsp)\n   (:requirements :adl)\n   (:types node)\n   (:predicates \n                 (move ?from ?to - node) \n                 (at ?pos - node)\n                 (connected ?start ?end - node)\n                 (visited ?end - node)\n                 )\n\n   (:action move\n             :parameters (?start ?end - node)\n             :precondition (and \n                             (at ?start)\n                             ;;; This is a directed graph\n                             (connected ?start ?end) \n\n                             ;;; hakank: this should probably be included\n                             (not (visited ?end)) \n\n                             ;;; For undirected graphs:\n                             ;;; (or\n                             ;;;   (connected ?start ?end)\n                             ;;;   (connected ?end ?start))\n                             )\n             :effect  (and \n                           (at ?end)\n                           (visited ?end)\n                           (not (at ?start)))\n    ) \n\n)\n\n",
        "batch_id": 3,
        "id": 120,
        "tokens": 4947,
        "corrected_description": "### General\nThis domain represents a simplified version of the Traveling Salesperson Problem (TSP) where a salesperson must visit a series of nodes (cities) starting from a specific node. The focus is on representing the connections between nodes and ensuring each node is visited once without considering the optimization of the route's cost.\n\n### Types\nnode: Represents the nodes in the graph, which can be thought of as cities in the TSP.\n\n### Predicates\n(move ?from ?to - node): This predicate is used in the action definition but does not represent a state in the domain. It might be a misunderstanding in the domain's formulation.\n(at ?pos - node): Indicates that the salesperson is currently at node ?pos.\n(connected ?start ?end - node): Indicates there is a direct connection from node ?start to node ?end.\n(visited ?end - node): Indicates that node ?end has been visited by the salesperson.\n\n### Actions\n- **move <?start> <?end>**: Allows the salesperson to move from one node to another.",
        "pddl_domain_processed": "\n\n(define (domain tsp)\n   (:requirements :adl)\n   (:types node)\n   (:predicates \n                 (move ?from ?to - node) \n                 (at ?pos - node)\n                 (connected ?start ?end - node)\n                 (visited ?end - node)\n                 )\n\n   (:action move\n             :parameters (?start ?end - node)\n             :precondition (and \n                             (at ?start)\n\n                             (connected ?start ?end) \n\n                             (not (visited ?end)) \n\n                             )\n             :effect  (and \n                           (at ?end)\n                           (visited ?end)\n                           (not (at ?start)))\n    ) \n\n)\n\n"
    },
    {
        "file_name": "irfansha_Q-Synth_global-domain.pddl",
        "pddl_domain": "; (C) CC-BY Irfansha Shaik, Jaco van de Pol, Aarhus University, 2023\n\n; Planning Domain for Optimal Quantum Layout Mapping (global version)\n; - version with ancillary bits\n\n(define (domain Quantum)\n(:requirements :typing :negative-preconditions)\n(:types pqubit lqubit depth)\n(:predicates (occupied_pqubit ?p - pqubit)\n             (occupied_lqubit ?l - lqubit)\n             (mapped ?l - lqubit ?p - pqubit)\n             (connected ?p1 ?p2 - pqubit)\n             ;; required cnot(control_gate,target_gate) is described as follows at some depth\n             (rcnot ?l1 ?l2 - lqubit ?d - depth)\n             (current_depth ?d - depth)\n             (next_depth ?d1 ?d2 - depth)\n)\n\n;; In the first step (or depth), the logical qubits to be mapped to some physical qubits\n;; We use map initial action for such mapping\n;; Since we need the initial mapping first, we use depth s0 with the very first depth\n\n(:action map_initial\n:parameters (?l - lqubit ?p - pqubit)\n:precondition (and (not (occupied_lqubit ?l)) (not (occupied_pqubit ?p)))\n:effect       (and (occupied_lqubit ?l) (occupied_pqubit ?p) (mapped ?l ?p))\n)\n\n;; In each depth, we need to satisfy some cnot operations\n;; we use swap to swap the mapped logical qubits\n\n(:action swap\n:parameters (?l1 ?l2 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l1 ?p1) (mapped ?l2 ?p2) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l1 ?p1)) (not (mapped ?l2 ?p2)) (mapped ?l1 ?p2) (mapped ?l2 ?p1))\n)\n\n;; we can swap with ancillary qubits:\n;; we update if qubits are initialized and occupied\n\n(:action swap_ancillary1\n:parameters (?l1 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l1 ?p1) (not (occupied_pqubit ?p2)) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l1 ?p1)) (mapped ?l1 ?p2) (not (occupied_pqubit ?p1)) (occupied_pqubit ?p2))\n)\n\n(:action swap_ancillary2\n:parameters (?l2 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l2 ?p2) (not (occupied_pqubit ?p1)) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l2 ?p2)) (mapped ?l2 ?p1) (not (occupied_pqubit ?p2)) (occupied_pqubit ?p1))\n)\n\n;; After (full/partial) swapping, we need to apply cnot gates\n;; only when the physical qubits to which the logical qubits are connected, we can apply the cnot gate in that time step\n\n(:action apply_cnot\n:parameters (?l1 ?l2 - lqubit ?p1 ?p2 - pqubit ?d - depth)\n:precondition (and (mapped ?l1 ?p1) (mapped ?l2 ?p2) (connected ?p1 ?p2) (rcnot ?l1 ?l2 ?d) (current_depth ?d))\n:effect       (and (not (rcnot ?l1 ?l2 ?d)))\n)\n\n;; Since unitary operators can be swapped (physically) along with qubits, we group cnots together and unitary operators together\n;; these form depths, as long as the swapping is done for cnot at each depth the correctness is preserved\n;; After each depth, we move to next depth\n\n(:action move_depth\n:parameters (?d1 ?d2 - depth) \n:precondition (and (current_depth ?d1) (next_depth ?d1 ?d2))\n:effect       (and (not (current_depth ?d1)) (current_depth ?d2))\n)\n\n)\n",
        "batch_id": 3,
        "id": 121,
        "tokens": 5970,
        "corrected_description": "### General\nThis domain is designed for planning optimal quantum layout mapping, specifically focusing on the global version with ancillary bits. It involves mapping logical qubits to physical qubits, satisfying CNOT operations, and managing the depth of operations to ensure the correct application of quantum gates.\n\n### Types\n- **pqubit**: Represents physical qubits in the quantum computer.\n- **lqubit**: Represents logical qubits that need to be mapped to physical qubits.\n- **depth**: Represents the depth of operations, indicating the sequence of operations.\n\n### Predicates\n- **(occupied_pqubit ?p - pqubit)**: Indicates that a physical qubit ?p is occupied.\n- **(occupied_lqubit ?l - lqubit)**: Indicates that a logical qubit ?l is occupied.\n- **(mapped ?l - lqubit ?p - pqubit)**: Indicates that logical qubit ?l is mapped to physical qubit ?p.\n- **(connected ?p1 ?p2 - pqubit)**: Indicates that physical qubits ?p1 and ?p2 are connected.\n- **(rcnot ?l1 ?l2 - lqubit ?d - depth)**: Indicates a required CNOT operation between logical qubits ?l1 and ?l2 at depth ?d.\n- **(current_depth ?d - depth)**: Indicates the current depth of operations.\n- **(next_depth ?d1 ?d2 - depth)**: Indicates that depth ?d2 follows depth ?d1.\n\n### Actions\n- **map_initial <?l> <?p>**: Maps a logical qubit to a physical qubit at the initial depth, ensuring that both the logical and physical qubits are not already occupied.  \n\n- **swap <?l1> <?l2> <?p1> <?p2>**: Swaps the mappings of two logical qubits that are mapped to two connected physical qubits.  \n\n- **swap_ancillary1 <?l1> <?p1> <?p2>**: Swaps a logical qubit mapped to a physical qubit with an unoccupied, connected physical qubit, updating the occupation status of the involved physical qubits.  \n\n- **swap_ancillary2 <?l2> <?p1> <?p2>**: Similar to swap_ancillary1, but for a logical qubit initially mapped to the second physical qubit.  \n\n- **apply_cnot <?l1> <?l2> <?p1> <?p2> <?d>**: Applies a CNOT gate between two logical qubits mapped to connected physical qubits at a specific depth, provided the required CNOT operation is scheduled for that depth.  \n\n- **move_depth <?d1> <?d2>**: Since unitary operators can be swapped (physically) along with qubits, we group CNOTs together and unitary operators together, forming depths. As long as the swapping is done for CNOT at each depth, the correctness is preserved. After each depth, we move to the next depth.",
        "pddl_domain_processed": "\n\n(define (domain Quantum)\n(:requirements :typing :negative-preconditions)\n(:types pqubit lqubit depth)\n(:predicates (occupied_pqubit ?p - pqubit)\n             (occupied_lqubit ?l - lqubit)\n             (mapped ?l - lqubit ?p - pqubit)\n             (connected ?p1 ?p2 - pqubit)\n\n             (rcnot ?l1 ?l2 - lqubit ?d - depth)\n             (current_depth ?d - depth)\n             (next_depth ?d1 ?d2 - depth)\n)\n\n(:action map_initial\n:parameters (?l - lqubit ?p - pqubit)\n:precondition (and (not (occupied_lqubit ?l)) (not (occupied_pqubit ?p)))\n:effect       (and (occupied_lqubit ?l) (occupied_pqubit ?p) (mapped ?l ?p))\n)\n\n(:action swap\n:parameters (?l1 ?l2 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l1 ?p1) (mapped ?l2 ?p2) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l1 ?p1)) (not (mapped ?l2 ?p2)) (mapped ?l1 ?p2) (mapped ?l2 ?p1))\n)\n\n(:action swap_ancillary1\n:parameters (?l1 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l1 ?p1) (not (occupied_pqubit ?p2)) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l1 ?p1)) (mapped ?l1 ?p2) (not (occupied_pqubit ?p1)) (occupied_pqubit ?p2))\n)\n\n(:action swap_ancillary2\n:parameters (?l2 - lqubit ?p1 ?p2 - pqubit)\n:precondition (and (mapped ?l2 ?p2) (not (occupied_pqubit ?p1)) (connected ?p1 ?p2))\n:effect       (and (not (mapped ?l2 ?p2)) (mapped ?l2 ?p1) (not (occupied_pqubit ?p2)) (occupied_pqubit ?p1))\n)\n\n(:action apply_cnot\n:parameters (?l1 ?l2 - lqubit ?p1 ?p2 - pqubit ?d - depth)\n:precondition (and (mapped ?l1 ?p1) (mapped ?l2 ?p2) (connected ?p1 ?p2) (rcnot ?l1 ?l2 ?d) (current_depth ?d))\n:effect       (and (not (rcnot ?l1 ?l2 ?d)))\n)\n\n(:action move_depth\n:parameters (?d1 ?d2 - depth) \n:precondition (and (current_depth ?d1) (next_depth ?d1 ?d2))\n:effect       (and (not (current_depth ?d1)) (current_depth ?d2))\n)\n\n)\n"
    },
    {
        "file_name": "devis12_aose_exam_puzzle-domain.pddl",
        "pddl_domain": ";; domain file: puzzle-domain.pddl\n(define (domain puzzle-domain)\n    (:requirements :strips :negative-preconditions)\n    \n    (:predicates \n        (greater ?x ?y)\n\n        (free ?r ?c)\n        (isOn ?tile ?r ?c)\n    )\n    \n    (:action moveUp\n        :parameters (?x ?r1 ?c ?r2)\n        :precondition (and (greater ?r1 ?r2) (isOn ?x ?r1 ?c) (free ?r2 ?c))\n        :effect (and (not(isOn ?x ?r1 ?c)) (not(free ?r2 ?c)) (isOn ?x ?r2 ?c) (free ?r1 ?c))\n    )\n\n    (:action moveDown\n        :parameters (?x ?r1 ?c ?r2)\n        :precondition (and (greater ?r2 ?r1) (isOn ?x ?r1 ?c) (free ?r2 ?c))\n        :effect (and (not(isOn ?x ?r1 ?c)) (not(free ?r2 ?c)) (isOn ?x ?r2 ?c) (free ?r1 ?c))\n    )\n\n    (:action moveLeft\n        :parameters (?x ?r ?c1 ?c2)\n        :precondition (and (greater ?c1 ?c2) (isOn ?x ?r ?c1) (free ?r ?c2))\n        :effect (and (not(isOn ?x ?r ?c1)) (not(free ?r ?c2)) (isOn ?x ?r ?c2) (free ?r ?c1))\n    )\n\n    (:action moveRight\n        :parameters (?x ?r ?c1 ?c2)\n        :precondition (and (greater ?c2 ?c1) (isOn ?x ?r ?c1) (free ?r ?c2))\n        :effect (and (not(isOn ?x ?r ?c1)) (not(free ?r ?c2)) (isOn ?x ?r ?c2) (free ?r ?c1))\n    )\n\n)",
        "batch_id": 3,
        "id": 129,
        "tokens": 5455,
        "corrected_description": "### General\nThis domain is designed for solving puzzles where tiles can be moved up, down, left, or right within a grid. The goal is typically to arrange the tiles in a specific configuration. The domain supports actions for moving tiles in all four directions, given that there is space (a free slot) to move the tile into.\n\n### Predicates\n- (greater ?x ?y): Determines if one value is greater than another. This is used to ensure moves are in the correct direction.\n- (free ?r ?c): Indicates that the position at row ?r and column ?c is free (no tile is present).\n- (isOn ?tile ?r ?c): Indicates that a tile is positioned at a specific row and column.\n\n### Actions\n- **moveUp <?x> <?r1> <?c> <?r2>**: Allows an object to move up from row <?r1> to row <?r2> in the same column <?c>.  \n\n- **moveDown <?x> <?r1> <?c> <?r2>**: Allows an object to move down from row <?r1> to row <?r2> in the same column <?c>.  \n\n- **moveLeft <?x> <?r> <?c1> <?c2>**: Allows an object to move left from column <?c1> to column <?c2> in the same row <?r>.  \n\n- **moveRight <?x> <?r> <?c1> <?c2>**: Allows an object to move right from column <?c1> to column <?c2> in the same row <?r>.",
        "pddl_domain_processed": "\n(define (domain puzzle-domain)\n    (:requirements :strips :negative-preconditions)\n\n    (:predicates \n        (greater ?x ?y)\n\n        (free ?r ?c)\n        (isOn ?tile ?r ?c)\n    )\n\n    (:action moveUp\n        :parameters (?x ?r1 ?c ?r2)\n        :precondition (and (greater ?r1 ?r2) (isOn ?x ?r1 ?c) (free ?r2 ?c))\n        :effect (and (not(isOn ?x ?r1 ?c)) (not(free ?r2 ?c)) (isOn ?x ?r2 ?c) (free ?r1 ?c))\n    )\n\n    (:action moveDown\n        :parameters (?x ?r1 ?c ?r2)\n        :precondition (and (greater ?r2 ?r1) (isOn ?x ?r1 ?c) (free ?r2 ?c))\n        :effect (and (not(isOn ?x ?r1 ?c)) (not(free ?r2 ?c)) (isOn ?x ?r2 ?c) (free ?r1 ?c))\n    )\n\n    (:action moveLeft\n        :parameters (?x ?r ?c1 ?c2)\n        :precondition (and (greater ?c1 ?c2) (isOn ?x ?r ?c1) (free ?r ?c2))\n        :effect (and (not(isOn ?x ?r ?c1)) (not(free ?r ?c2)) (isOn ?x ?r ?c2) (free ?r ?c1))\n    )\n\n    (:action moveRight\n        :parameters (?x ?r ?c1 ?c2)\n        :precondition (and (greater ?c2 ?c1) (isOn ?x ?r ?c1) (free ?r ?c2))\n        :effect (and (not(isOn ?x ?r ?c1)) (not(free ?r ?c2)) (isOn ?x ?r ?c2) (free ?r ?c1))\n    )\n\n)"
    },
    {
        "file_name": "PIxLLab_URSSimEnvironments_urs_domain.pddl",
        "pddl_domain": "; Action's :effect must have 'and'\n; Problem definition's :init must have 'and'\n; All :types must be in problem defintion's :objects\n(define (domain urs)\n  (:requirements :strips :typing)\n  (:types drone_id key_id loc_id)\n  (:predicates\n    (active_region ?loc_id_sw - loc_id ?loc_id_ne - loc_id)\n    (drone_above ?drone_id - drone_id ?loc_id - loc_id)\n    (drone_at ?drone_id - drone_id ?loc_id - loc_id)\n    (is_location ?loc_id - loc_id)\n    (is_occupied ?loc_id - loc_id)\n    (key_at ?key_id - key_id ?loc_id - loc_id)\n    (key_picked ?key_id - key_id)\n    (key_with ?key_id - key_id ?drone_id - drone_id)\n    (took_off ?drone_id - drone_id)\n  )\n  (:action active_region_update\n    :parameters (?loc_id_sw_old ?loc_id_ne_old ?loc_id_sw_new ?loc_id_ne_new - loc_id)\n    :precondition (active_region ?loc_id_sw_old ?loc_id_ne_old)\n    :effect (and (not (active_region ?loc_id_sw_old ?loc_id_ne_old)) (active_region ?loc_id_sw_new ?loc_id_ne_new))\n  )\n  (:action add_location\n    :parameters (?loc_id - loc_id)\n    :precondition (and (not (is_location ?loc_id)))\n    :effect (and (is_location ?loc_id) (not (is_occupied ?loc_id)))\n  )\n  (:action fly_above\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_above ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action fly_to\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_at ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action key_add\n    :parameters (?key_id - key_id ?loc_id - loc_id)\n    :precondition (not (key_at ?key_id ?loc_id))\n    :effect (and (key_at ?key_id ?loc_id) (not (key_picked ?key_id)))\n  )\n  (:action key_pick\n    :parameters (?drone_id - drone_id ?key_id - key_id ?drone_loc_id ?key_loc_id - loc_id)\n    :precondition (and (not (key_picked ?key_id)) (key_at ?key_id ?key_loc_id) (took_off ?drone_id) (or (drone_above ?drone_id ?drone_loc_id) (drone_at ?drone_id ?drone_loc_id)))\n    :effect (and\n      (not (drone_above ?drone_id ?drone_loc_id))\n      (not (drone_at ?drone_id ?drone_loc_id))\n      (drone_above ?drone_id ?key_loc_id)\n      (key_picked ?key_id)\n      (key_with ?key_id ?drone_id)\n    )\n  )\n  (:action land\n    :parameters (?drone_id - drone_id)\n    :precondition (took_off ?drone_id)\n    :effect (and (not (took_off ?drone_id)))\n  )\n  (:action take_off\n    :parameters (?drone_id - drone_id)\n    :precondition (not (took_off ?drone_id))\n    :effect (and (took_off ?drone_id))\n  )\n)\n",
        "batch_id": 3,
        "id": 130,
        "tokens": 6061,
        "corrected_description": "### General\nThis domain models an Unmanned Aerial Vehicle (UAV) Surveillance System (URS) where drones can fly over regions, pick up and drop keys at specific locations. The domain includes actions for updating active regions, adding new locations, flying drones, picking up keys, and managing the take-off and landing of drones.\n\n### Types\n- **drone_id**: Represents the identifier for drones.\n- **key_id**: Represents the identifier for keys.\n- **loc_id**: Represents the identifier for locations.\n\n### Predicates\n- **active_region (?loc_id_sw ?loc_id_ne - loc_id)**: Indicates that a region defined by the southwest and northeast location identifiers is currently active.\n- **drone_above (?drone_id - drone_id ?loc_id - loc_id)**: Indicates that a drone is flying above a specific location.\n- **drone_at (?drone_id - drone_id ?loc_id - loc_id)**: Indicates that a drone is at a specific location, implying it is on the ground.\n- **is_location (?loc_id - loc_id)**: Indicates that an identifier corresponds to a valid location.\n- **is_occupied (?loc_id - loc_id)**: Indicates that a location is currently occupied, either by a drone or a key.\n- **key_at (?key_id - key_id ?loc_id - loc_id)**: Indicates that a key is located at a specific location.\n- **key_picked (?key_id - key_id)**: Indicates that a key has been picked up by a drone and is no longer at its original location.\n- **key_with (?key_id - key_id ?drone_id - drone_id)**: Indicates that a key is with a drone, having been picked up.\n- **took_off (?drone_id - drone_id)**: Indicates that a drone has taken off and is capable of flying.\n\n### Actions\n- **active_region_update <?loc_id_sw_old> <?loc_id_ne_old> <?loc_id_sw_new> <?loc_id_ne_new>**: Updates the active region from an old set of southwest and northeast location identifiers to a new set. This action is used to change the focus area of surveillance.  \n\n- **add_location <?loc_id>**: Adds a new location to the system, marking it as unoccupied.  \n\n- **fly_above <?drone_id> <?loc_id_from> <?loc_id_to>**: Moves a drone from one location to fly above another unoccupied location and lands it. This action is used for moving drones without landing.  \n\n- **fly_to <?drone_id> <?loc_id_from> <?loc_id_to>**: Moves a drone from one location to another unoccupied location and lands it. This action is used for repositioning drones on the ground.  \n\n- **key_add <?key_id> <?loc_id>**: Adds a key to a specific location.  \n\n- **key_pick <?drone_id> <?key_id> <?drone_loc_id> <?key_loc_id>**: Picks up a key from a location using a drone.  \n\n- **land <?drone_id>**: Lands a drone, indicating it is no longer flying.  \n\n- **take_off <?drone_id>**: Takes a drone off from the ground, allowing it to fly.",
        "pddl_domain_processed": "\n\n(define (domain urs)\n  (:requirements :strips :typing)\n  (:types drone_id key_id loc_id)\n  (:predicates\n    (active_region ?loc_id_sw - loc_id ?loc_id_ne - loc_id)\n    (drone_above ?drone_id - drone_id ?loc_id - loc_id)\n    (drone_at ?drone_id - drone_id ?loc_id - loc_id)\n    (is_location ?loc_id - loc_id)\n    (is_occupied ?loc_id - loc_id)\n    (key_at ?key_id - key_id ?loc_id - loc_id)\n    (key_picked ?key_id - key_id)\n    (key_with ?key_id - key_id ?drone_id - drone_id)\n    (took_off ?drone_id - drone_id)\n  )\n  (:action active_region_update\n    :parameters (?loc_id_sw_old ?loc_id_ne_old ?loc_id_sw_new ?loc_id_ne_new - loc_id)\n    :precondition (active_region ?loc_id_sw_old ?loc_id_ne_old)\n    :effect (and (not (active_region ?loc_id_sw_old ?loc_id_ne_old)) (active_region ?loc_id_sw_new ?loc_id_ne_new))\n  )\n  (:action add_location\n    :parameters (?loc_id - loc_id)\n    :precondition (and (not (is_location ?loc_id)))\n    :effect (and (is_location ?loc_id) (not (is_occupied ?loc_id)))\n  )\n  (:action fly_above\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_above ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action fly_to\n    :parameters (?drone_id - drone_id ?loc_id_from ?loc_id_to - loc_id)\n    :precondition (and\n      (or (drone_above ?drone_id ?loc_id_from) (drone_at ?drone_id ?loc_id_from))\n      (not (is_occupied ?loc_id_to))\n      (took_off ?drone_id)\n    )\n    :effect (and\n      (not (drone_above ?drone_id ?loc_id_from))\n      (not (drone_at ?drone_id ?loc_id_from))\n      (drone_at ?drone_id ?loc_id_to)\n      (not (is_occupied ?loc_id_from))\n      (is_occupied ?loc_id_to)\n    )\n  )\n  (:action key_add\n    :parameters (?key_id - key_id ?loc_id - loc_id)\n    :precondition (not (key_at ?key_id ?loc_id))\n    :effect (and (key_at ?key_id ?loc_id) (not (key_picked ?key_id)))\n  )\n  (:action key_pick\n    :parameters (?drone_id - drone_id ?key_id - key_id ?drone_loc_id ?key_loc_id - loc_id)\n    :precondition (and (not (key_picked ?key_id)) (key_at ?key_id ?key_loc_id) (took_off ?drone_id) (or (drone_above ?drone_id ?drone_loc_id) (drone_at ?drone_id ?drone_loc_id)))\n    :effect (and\n      (not (drone_above ?drone_id ?drone_loc_id))\n      (not (drone_at ?drone_id ?drone_loc_id))\n      (drone_above ?drone_id ?key_loc_id)\n      (key_picked ?key_id)\n      (key_with ?key_id ?drone_id)\n    )\n  )\n  (:action land\n    :parameters (?drone_id - drone_id)\n    :precondition (took_off ?drone_id)\n    :effect (and (not (took_off ?drone_id)))\n  )\n  (:action take_off\n    :parameters (?drone_id - drone_id)\n    :precondition (not (took_off ?drone_id))\n    :effect (and (took_off ?drone_id))\n  )\n)\n"
    },
    {
        "file_name": "TarasRashkevych99_autonomous-software-agent_board-domain.pddl",
        "pddl_domain": ";; domain file: board-domain.pddl\n(define (domain default)\n    (:requirements :strips)\n    (:predicates\n        (tile ?t)\n        (delivery ?t)\n        (wall ?t)\n        (agent ?a)\n        (parcel ?p)\n        (me ?a)\n        (right ?t1 ?t2)\n        (left ?t1 ?t2)\n        (up ?t1 ?t2)\n        (down ?t1 ?t2)\n        (at ?agentOrParcel ?tile)\n        (carriedBy ?parcel ?agent)\n    )\n\n    (:action right\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (right ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action left\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (left ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action up\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (up ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action down\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (down ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action pickup\n        :parameters (?me ?parcel ?tile)\n        :precondition (and\n            (me ?me)\n            (parcel ?parcel)\n            (tile ?tile)\n            (at ?me ?tile)\n            (at ?parcel ?tile)\n            (not (carriedBy ?parcel ?me))\n        )\n        :effect (and\n            (not (at ?parcel ?tile))\n            (carriedBy ?parcel ?me)\n        )\n    )\n\n    (:action putdown\n        :parameters (?me ?parcel ?tile)\n        :precondition (and\n            (me ?me)\n            (parcel ?parcel)\n            (tile ?tile)\n            (at ?me ?tile)\n            (carriedBy ?parcel ?me)\n        )\n        :effect (and\n            (at ?parcel ?tile)\n            (not (carriedBy ?parcel ?me))\n        )\n    )\n)",
        "batch_id": 3,
        "id": 132,
        "tokens": 5628,
        "corrected_description": "### General\nThis domain is designed for a board game-like scenario where an agent moves around a grid, picks up parcels, and delivers them to specific locations. The domain includes actions for moving in four directions (right, left, up, down), picking up parcels, and putting them down. The environment includes tiles, walls, parcels, and delivery points.\n\n### Predicates\n(tile ?t): Indicates that ?t is a tile on the board.\n(delivery ?t): Indicates that ?t is a delivery point.\n(wall ?t): Indicates that ?t is a wall.\n(agent ?a): Indicates that ?a is an agent in the game.\n(parcel ?p): Indicates that ?p is a parcel.\n(me ?a): Indicates that ?a is the agent being controlled.\n(right ?t1 ?t2): Indicates that tile ?t2 is immediately to the right of tile ?t1.\n(left ?t1 ?t2): Indicates that tile ?t2 is immediately to the left of tile ?t1.\n(up ?t1 ?t2): Indicates that tile ?t2 is immediately above tile ?t1.\n(down ?t1 ?t2): Indicates that tile ?t2 is immediately below tile ?t1.\n(at ?agentOrParcel ?tile): Indicates that an agent or a parcel is at a specific tile.\n(carriedBy ?parcel ?agent): Indicates that a parcel is being carried by an agent.\n\n### Actions\n- **right <?me> <?from> <?to>**: This action allows the agent to move right from one tile to another.  \n\n- **left <?me> <?from> <?to>**: This action allows the agent to move left from one tile to another.  \n\n- **up <?me> <?from> <?to>**: This action allows the agent to move up from one tile to another.  \n\n- **down <?me> <?from> <?to>**: This action allows the agent to move down from one tile to another.  \n\n- **pickup <?me> <?parcel> <?tile>**: This action allows the agent to pick up a parcel from a tile.  \n\n- **putdown <?me> <?parcel> <?tile>**: This action allows the agent to put down a carried parcel onto a tile.",
        "pddl_domain_processed": "\n(define (domain default)\n    (:requirements :strips)\n    (:predicates\n        (tile ?t)\n        (delivery ?t)\n        (wall ?t)\n        (agent ?a)\n        (parcel ?p)\n        (me ?a)\n        (right ?t1 ?t2)\n        (left ?t1 ?t2)\n        (up ?t1 ?t2)\n        (down ?t1 ?t2)\n        (at ?agentOrParcel ?tile)\n        (carriedBy ?parcel ?agent)\n    )\n\n    (:action right\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (right ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action left\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (left ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action up\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (up ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action down\n        :parameters (?me ?from ?to)\n        :precondition (and\n            (me ?me)\n            (not (wall ?from))\n            (not (wall ?to))\n            (tile ?from)\n            (tile ?to)\n            (at ?me ?from)\n            (down ?from ?to)\n        )\n        :effect (and\n            (at ?me ?to)\n            (not (at ?me ?from))\n        )\n    )\n\n    (:action pickup\n        :parameters (?me ?parcel ?tile)\n        :precondition (and\n            (me ?me)\n            (parcel ?parcel)\n            (tile ?tile)\n            (at ?me ?tile)\n            (at ?parcel ?tile)\n            (not (carriedBy ?parcel ?me))\n        )\n        :effect (and\n            (not (at ?parcel ?tile))\n            (carriedBy ?parcel ?me)\n        )\n    )\n\n    (:action putdown\n        :parameters (?me ?parcel ?tile)\n        :precondition (and\n            (me ?me)\n            (parcel ?parcel)\n            (tile ?tile)\n            (at ?me ?tile)\n            (carriedBy ?parcel ?me)\n        )\n        :effect (and\n            (at ?parcel ?tile)\n            (not (carriedBy ?parcel ?me))\n        )\n    )\n)"
    },
    {
        "file_name": "DrankRock_PATIA_2023_hanoi_domain.pddl",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; hanoi towers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain HANOI)\n  (:requirements :strips :typing)\n  (:types object tower)\n  (:predicates\n\t       (clear ?x - object)\n\t       (handempty)\n\t       (holding ?x - object)\n         (smaller ?x - object ?y - object)\n         (on ?x - object ?y - object)\n         (ontower ?x - object ?y - tower)\n\t       )\n\n  (:action unstack\n\t     :parameters (?x - object ?y - object)\n\t     :precondition (and (clear ?x) (on ?x ?y) (handempty))\n\t     :effect\n\t     (and (not (on ?x ?y))\n\t\t   (not (clear ?x))\n\t\t   (not (handempty))\n\t\t   (holding ?x)\n       (clear ?y)))\n\n  (:action stack\n\t     :parameters (?x - object ?y - object)\n\t     :precondition (and (holding ?x) (clear ?y) (smaller ?x ?y))\n\t     :effect\n\t     (and (not (holding ?x))\n       (not (clear ?y))\n\t\t   (clear ?x)\n\t\t   (handempty)\n       (on ?x ?y)))\n\n  (:action put-down\n\t     :parameters (?x - object ?y - tower)\n\t     :precondition (and (holding ?x) (clear ?y))\n\t     :effect\n\t     (and (not (holding ?x))\n\t\t   (not (clear ?y))\n\t\t   (clear ?x)\n\t\t   (handempty)\n\t\t   (ontower ?x ?y)))\n\n  (:action pick-up\n\t     :parameters (?x - object ?y - tower)\n\t     :precondition (and (ontower ?x ?y) (clear ?x) (handempty))\n\t     :effect\n\t     (and (holding ?x)\n\t\t   (clear ?y)\n\t\t   (not (clear ?x))\n\t\t   (not (handempty))\n\t\t   (not (ontower ?x ?y)))))\n",
        "batch_id": 3,
        "id": 136,
        "tokens": 5407,
        "corrected_description": "### General\nThe domain models the classic problem of the Tower of Hanoi, where the goal is to move a set of disks of different sizes from one tower to another, following certain rules. The actions defined allow for moving disks between towers and handling them with a robotic arm that can hold one disk at a time.\n\n### Types\n- **object**: Represents the disks in the Tower of Hanoi problem.\n- **tower**: Represents the towers on which disks can be placed.\n\n### Predicates\n- **(clear ?x - object)**: Indicates that there is no disk on top of disk ?x, making it possible to pick up ?x.\n- **(handempty)**: Indicates that the robotic arm is not holding any disk.\n- **(holding ?x - object)**: Indicates that the robotic arm is currently holding disk ?x.\n- **(smaller ?x - object ?y - object)**: Indicates that disk ?x is smaller than disk ?y, allowing ?x to be placed on ?y.\n- **(on ?x - object ?y - object)**: Indicates that disk ?x is directly on top of disk ?y.\n- **(ontower ?x - object ?y - tower)**: Indicates that disk ?x is placed on tower ?y.\n\n### Actions\n- **unstack <?x - object> <?y - object>**: This action allows the agent to unstack object ?x from object ?y.  \n\n- **stack <?x - object> <?y - object>**: This action allows the agent to stack object ?x onto object ?y.  \n\n- **put-down <?x - object> <?y - tower>**: This action allows the agent to put down object ?x onto tower ?y.  \n\n- **pick-up <?x - object> <?y - tower>**: This action allows the agent to pick up object ?x from tower ?y.",
        "pddl_domain_processed": "\n\n(define (domain HANOI)\n  (:requirements :strips :typing)\n  (:types object tower)\n  (:predicates\n\t       (clear ?x - object)\n\t       (handempty)\n\t       (holding ?x - object)\n         (smaller ?x - object ?y - object)\n         (on ?x - object ?y - object)\n         (ontower ?x - object ?y - tower)\n\t       )\n\n  (:action unstack\n\t     :parameters (?x - object ?y - object)\n\t     :precondition (and (clear ?x) (on ?x ?y) (handempty))\n\t     :effect\n\t     (and (not (on ?x ?y))\n\t\t   (not (clear ?x))\n\t\t   (not (handempty))\n\t\t   (holding ?x)\n       (clear ?y)))\n\n  (:action stack\n\t     :parameters (?x - object ?y - object)\n\t     :precondition (and (holding ?x) (clear ?y) (smaller ?x ?y))\n\t     :effect\n\t     (and (not (holding ?x))\n       (not (clear ?y))\n\t\t   (clear ?x)\n\t\t   (handempty)\n       (on ?x ?y)))\n\n  (:action put-down\n\t     :parameters (?x - object ?y - tower)\n\t     :precondition (and (holding ?x) (clear ?y))\n\t     :effect\n\t     (and (not (holding ?x))\n\t\t   (not (clear ?y))\n\t\t   (clear ?x)\n\t\t   (handempty)\n\t\t   (ontower ?x ?y)))\n\n  (:action pick-up\n\t     :parameters (?x - object ?y - tower)\n\t     :precondition (and (ontower ?x ?y) (clear ?x) (handempty))\n\t     :effect\n\t     (and (holding ?x)\n\t\t   (clear ?y)\n\t\t   (not (clear ?x))\n\t\t   (not (handempty))\n\t\t   (not (ontower ?x ?y)))))\n"
    },
    {
        "file_name": "inverthermit_pacman_contest_pacman_domain.pddl",
        "pddl_domain": "(define (domain pacman_ai)\n   (:requirements :typing)\n   (:types node)\n   (:predicates\n            (has_food ?location -node)\n            (is_opponent_ghost ?location -node)\n            (is_opponent_pacman ?location -node)\n            (is_visited ?location)\n            (at ?location - node)\n            (connected ?n1 ?n2 - node)\n            (eat_food ?start ?end -node)\n            (move_pacman ?start ?end -node)\n            (move_ghost ?start ?end -node)\n            (eat_pacman ?start ?end -node)\n            ;; get the direction of the ghost from 5 steps away and start to avoid it! (do it in eat and move)\n\t       )\n    (:action move_pacman ;; Pacman move\n         :parameters (?start ?end -node)\n         :precondition (\n         and\n         (at ?start)\n         (not (has_food ?end))\n         (connected ?start ?end)\n         (not (is_opponent_ghost ?end))\n         )\n         :effect (and\n         (not (at ?start))\n         (at ?end)\n         (is_visited ?end)\n         )\n\n      )\n    (:action eat_food\n        :parameters (?start ?end -node)\n        :precondition (\n        and\n        (at ?start)\n        (has_food ?end)\n        (connected ?start ?end)\n        (not (is_opponent_ghost ?end))\n        )\n        :effect (and\n        (at ?end)\n        (not (at ?start))\n        (not (has_food ?end))\n        (is_visited ?end)\n        )\n\n     )\n\n)\n",
        "batch_id": 3,
        "id": 137,
        "tokens": 5275,
        "corrected_description": "### General\nThis domain is designed for a Pacman AI simulation where the goal is to navigate a Pacman through a maze, eating food while avoiding ghosts. The maze is represented as a graph of connected nodes, where each node can have food, be occupied by an opponent ghost or Pacman, or be marked as visited. The actions defined in this domain allow Pacman to move between nodes, eat food, and avoid ghosts.\n\n### Types\n- node: Represents a location in the maze.\n\n### Predicates\n- (has_food ?location - node): Indicates that there is food at the node ?location.\n- (is_opponent_ghost ?location - node): Indicates that an opponent ghost is present at the node ?location.\n- (is_opponent_pacman ?location - node): Indicates that an opponent Pacman is present at the node ?location.\n- (is_visited ?location): Indicates that the node ?location has been visited by Pacman.\n- (at ?location - node): Indicates that Pacman is currently at the node ?location.\n- (connected ?n1 ?n2 - node): Indicates that node ?n1 is directly connected to node ?n2.\n- (eat_food ?start ?end - node): Represents the action of Pacman eating food when moving from ?start to ?end.\n- (move_pacman ?start ?end - node): Represents the action of Pacman moving from ?start to ?end without eating food.\n- (move_ghost ?start ?end - node): Represents the action of a ghost moving from ?start to ?end.\n- (eat_pacman ?start ?end - node): Represents the action of a ghost eating Pacman when moving from ?start to ?end.\n\n### Actions\n- **move_pacman <?start> <?end>**: Allows Pacman to move from one node to another if the ending node does not have food, does not have an opponent ghost. \n\n- **eat_food <?start> <?end>**: Allows Pacman to eat food when moving from one node to another if the ending node has food, does not have an opponent ghost.",
        "pddl_domain_processed": "(define (domain pacman_ai)\n   (:requirements :typing)\n   (:types node)\n   (:predicates\n            (has_food ?location -node)\n            (is_opponent_ghost ?location -node)\n            (is_opponent_pacman ?location -node)\n            (is_visited ?location)\n            (at ?location - node)\n            (connected ?n1 ?n2 - node)\n            (eat_food ?start ?end -node)\n            (move_pacman ?start ?end -node)\n            (move_ghost ?start ?end -node)\n            (eat_pacman ?start ?end -node)\n\n\t       )\n    (:action move_pacman \n         :parameters (?start ?end -node)\n         :precondition (\n         and\n         (at ?start)\n         (not (has_food ?end))\n         (connected ?start ?end)\n         (not (is_opponent_ghost ?end))\n         )\n         :effect (and\n         (not (at ?start))\n         (at ?end)\n         (is_visited ?end)\n         )\n\n      )\n    (:action eat_food\n        :parameters (?start ?end -node)\n        :precondition (\n        and\n        (at ?start)\n        (has_food ?end)\n        (connected ?start ?end)\n        (not (is_opponent_ghost ?end))\n        )\n        :effect (and\n        (at ?end)\n        (not (at ?start))\n        (not (has_food ?end))\n        (is_visited ?end)\n        )\n\n     )\n\n)\n"
    },
    {
        "file_name": "DrankRock_PATIA_2023_taquin_domain.pddl",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; taquin\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain TAQUIN)\n  (:requirements :strips :typing)\n  (:types tile position)\n  (:constants free - tile)\n  (:predicates (on ?x - position ?y - tile)\n\t       (permutable ?x - position ?y - position))\n\n (:action move\n\t     :parameters (?t - tile ?from - position ?to - position)\n\t     :precondition (and (on ?from ?t) (on ?to free) (permutable ?from ?to))\n\t     :effect\n\t     (and (on ?to ?t) (on ?from free) (not (on ?from ?t)) (not (on ?to free))))\n\n  (:action noop\n\t     :parameters (?from - position ?to - position)\n\t     :precondition (and (permutable ?from ?to))\n\t     :effect\n\t     (and (permutable ?to ?from)))\n)\n",
        "batch_id": 3,
        "id": 138,
        "tokens": 5018,
        "corrected_description": "### General\nThe TAQUIN domain models a sliding puzzle game where tiles can be moved into a free space if they are adjacent to it. The goal is to arrange the tiles in a specific configuration by sliding them into the free space.\n\n### Types\n- **tile**: Represents the individual tiles that can be moved within the puzzle.\n- **position**: Represents the positions on the puzzle board where tiles can be placed.\n\n### Predicates\n- **(on ?x - position ?y - tile)**: Indicates that tile ?y is on position ?x.\n- **(permutable ?x - position ?y - position)**: Indicates that position ?x is adjacent to position ?y, allowing a tile to be moved between these positions.\n\n### Actions\n- **move <?t> <?from> <?to>**: This action allows moving a tile ?t from one position ?from to another position ?to.  \n\n- **noop <?from> <?to>**: This action allows maintaining the permutability between two positions ?from and ?to.",
        "pddl_domain_processed": "\n\n(define (domain TAQUIN)\n  (:requirements :strips :typing)\n  (:types tile position)\n  (:constants free - tile)\n  (:predicates (on ?x - position ?y - tile)\n\t       (permutable ?x - position ?y - position))\n\n (:action move\n\t     :parameters (?t - tile ?from - position ?to - position)\n\t     :precondition (and (on ?from ?t) (on ?to free) (permutable ?from ?to))\n\t     :effect\n\t     (and (on ?to ?t) (on ?from free) (not (on ?from ?t)) (not (on ?to free))))\n\n  (:action noop\n\t     :parameters (?from - position ?to - position)\n\t     :precondition (and (permutable ?from ?to))\n\t     :effect\n\t     (and (permutable ?to ?from)))\n)\n"
    },
    {
        "file_name": "karimib_web-based-autonomous-systems_t3-domain.pddl",
        "pddl_domain": "(define (domain t3-domain)\n    (:requirements :typing)\n    (:types space - object\n\t\troom storage - space)\n    (:predicates  (prepared ?r - room)\n\t\t(haveHoover)\n        (at ?s - space)\n\t\t(clean ?r - room)\n    )\n    \n\t(:action move\n        :parameters (?x - space ?y - space)\n        :precondition  (at ?x)\n        :effect (and (at ?y) \n\t\t\t(not (at ?x))\n\t\t)\n    )\n\n\t(:action getHoover\n        :parameters (?s - storage)\n        :precondition  (at ?s)\n        :effect (haveHoover)\n    )\n\n    (:action cleanRoom\n\t    :parameters (?r - room)\n\t    :precondition (and (at ?r)\n\t\t\t(haveHoover)\n\t\t)\n\t    :effect (clean ?r)\n    )\n)",
        "batch_id": 3,
        "id": 141,
        "tokens": 4931,
        "corrected_description": "### General\nThis domain is designed for a cleaning robot operating in a space consisting of rooms and storage areas. The robot can move between these spaces, acquire a hoover from storage, and clean rooms.\n\n### Types\n- **space**: The base type for all spaces within the domain.\n- **room**: A subtype of space, representing rooms that can be cleaned.\n- **storage**: A subtype of space, representing areas where cleaning equipment like hoovers are stored.\n\n### Predicates\n- **(prepared ?r - room)**: Indicates that room ?r is prepared for cleaning.\n- **(haveHoover)**: Indicates that the robot currently has a hoover.\n- **(at ?s - space)**: Indicates that the robot is currently at space ?s.\n- **(clean ?r - room)**: Indicates that room ?r has been cleaned.\n\n### Actions\n- **move <?x> <?y>**: Allows the robot to move from one space to another. , and \n  \n- **getHoover <?s>**: Allows the robot to acquire a hoover when in a storage space. , \n  \n- **cleanRoom <?r>**: Allows the robot to clean a room.",
        "pddl_domain_processed": "(define (domain t3-domain)\n    (:requirements :typing)\n    (:types space - object\n\t\troom storage - space)\n    (:predicates  (prepared ?r - room)\n\t\t(haveHoover)\n        (at ?s - space)\n\t\t(clean ?r - room)\n    )\n\n\t(:action move\n        :parameters (?x - space ?y - space)\n        :precondition  (at ?x)\n        :effect (and (at ?y) \n\t\t\t(not (at ?x))\n\t\t)\n    )\n\n\t(:action getHoover\n        :parameters (?s - storage)\n        :precondition  (at ?s)\n        :effect (haveHoover)\n    )\n\n    (:action cleanRoom\n\t    :parameters (?r - room)\n\t    :precondition (and (at ?r)\n\t\t\t(haveHoover)\n\t\t)\n\t    :effect (clean ?r)\n    )\n)"
    },
    {
        "file_name": "KMarino_RIPFall2014P1_sokoban-domain.pddl",
        "pddl_domain": "(define (domain sokoban-domain)\n\t(:requirements :equality)\n\t(:predicates (bot ?x) (cell ?x) (box ?x) (empty ?x) (left-right ?x ?y) (onTop ?x ?y) (at ?x ?y))\n\t(:action move-bot-up\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (onTop ?to ?from)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-down\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (onTop ?from ?to)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-left\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (left-right ?to ?from)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-right\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (left-right ?from ?to)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-box-up\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (onTop ?boxFrom ?botIniPos)\n\t\t\t\t    (onTop ?boxTo ?boxFrom)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-down\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (onTop ?botIniPos ?boxFrom)\n\t\t\t\t    (onTop ?boxFrom ?boxTo)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-right\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (left-right ?botIniPos ?boxFrom)\n\t\t\t\t    (left-right ?boxFrom ?boxTo)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-left\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (left-right ?boxFrom ?botIniPos)\n\t\t\t\t    (left-right ?boxTo ?boxFrom)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t\n)\n",
        "batch_id": 3,
        "id": 143,
        "tokens": 6261,
        "corrected_description": "### General\nThe Sokoban domain involves a robot (bot) navigating through a grid of cells, moving boxes to specific locations. The goal is often to get all boxes to designated storage locations. The domain includes actions for moving the bot and the boxes in four directions: up, down, left, and right.\n\n### Predicates\n- (bot ?x): Indicates that ?x is a bot.\n- (cell ?x): Indicates that ?x is a cell in the grid.\n- (box ?x): Indicates that ?x is a box.\n- (empty ?x): Indicates that cell ?x is empty.\n- (left-right ?x ?y): Indicates that cell ?x is directly to the left of cell ?y.\n- (onTop ?x ?y): Indicates that cell ?x is directly above cell ?y.\n- (at ?x ?y): Indicates that object ?x (a bot or a box) is at cell ?y.\n\n### Actions\n- move-bot-up <?bot> <?from> <?to>: This action allows the robot to move upward.  \n\n- move-bot-down <?bot> <?from> <?to>: This action allows the robot to move downward.  \n\n- move-bot-left <?bot> <?from> <?to>: This action allows the robot to move left.  \n\n- move-bot-right <?bot> <?from> <?to>: This action allows the robot to move right.  \n\n- move-box-up <?bot> <?box> <?botIniPos> <?boxFrom> <?boxTo>: This action allows the robot to push a box upward.  \n\n- move-box-down <?bot> <?box> <?botIniPos> <?boxFrom> <?boxTo>: This action allows the robot to push a box downward.  \n\n- move-box-right <?bot> <?box> <?botIniPos> <?boxFrom> <?boxTo>: This action allows the robot to push a box to the right.  \n\n- move-box-left <?bot> <?box> <?botIniPos> <?boxFrom> <?boxTo>: This action allows the robot to push a box to the left.",
        "pddl_domain_processed": "(define (domain sokoban-domain)\n\t(:requirements :equality)\n\t(:predicates (bot ?x) (cell ?x) (box ?x) (empty ?x) (left-right ?x ?y) (onTop ?x ?y) (at ?x ?y))\n\t(:action move-bot-up\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (onTop ?to ?from)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-down\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (onTop ?from ?to)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-left\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (left-right ?to ?from)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-bot-right\n\t\t :parameters (?bot ?from ?to)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (cell ?from)\n\t\t\t\t    (cell ?to)\n\t\t \t       \t    (at ?bot ?from)\n\t\t\t\t    (left-right ?from ?to)\n\t\t\t\t    (empty ?to))\n\t\t :effect (and (at ?bot ?to)\n\t\t \t      (not (at ?bot ?from))\n\t\t\t      (empty ?from)\n\t\t\t      (not (empty ?to))\n\t\t\t )\n\t)\n\t(:action move-box-up\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (onTop ?boxFrom ?botIniPos)\n\t\t\t\t    (onTop ?boxTo ?boxFrom)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-down\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (onTop ?botIniPos ?boxFrom)\n\t\t\t\t    (onTop ?boxFrom ?boxTo)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-right\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (left-right ?botIniPos ?boxFrom)\n\t\t\t\t    (left-right ?boxFrom ?boxTo)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\t(:action move-box-left\n\t\t :parameters (?bot ?box ?botIniPos ?boxFrom ?boxTo)\n\t\t :precondition (and (bot ?bot)\n\t\t \t       \t    (box ?box)\n\t\t \t       \t    (cell ?botIniPos)\n\t\t\t\t    (cell ?boxFrom)\n\t\t\t\t    (cell ?boxTo)\n\t\t \t       \t    (at ?bot ?botIniPos)\n\t\t \t       \t    (at ?box ?boxFrom)\n\t\t\t\t    (empty ?boxTo)\n\t\t\t\t    (left-right ?boxFrom ?botIniPos)\n\t\t\t\t    (left-right ?boxTo ?boxFrom)\n\t\t \t       )\n\t         :effect (and (at ?box ?boxTo)\n\t\t \t      (not (at ?box ?boxFrom))\n\t\t\t      (at ?bot ?boxFrom)\n\t\t\t      (not (at ?bot ?botIniPos))\n\t\t\t      (empty ?botIniPos)\n\t\t\t      (empty ?boxFrom)\n\t\t\t      (not (empty ?boxTo)) \n\t\t\t )\n\t)\n\n)\n"
    },
    {
        "file_name": "MDB22_Pacman_ghost-domain.pddl",
        "pddl_domain": "(define (domain ghost)\n  (:requirements :typing :conditional-effects)\n  (:types pos)\t\t\t\t;; x-y positions are treated as a single variable\n  (:predicates  (At ?p - pos) \t\t;; Position of Ghost\n                (PacmanAt ?p - pos)\t;; Position of Pacman\n                (Adjacent ?pos1 ?pos2 - pos)\t;; Whether two positions are connected\n                (Scared)\t\t;; Whether Ghost is scared of Pacman\n  )\n  ;; Ghost is only able to move to the next position when its current position\n  ;; is posCurr, and its next position is connected to its current position\n  ;; When Ghost moves, its position changes, and if he is not scared, eats a Pacman\n  (:action move\n        :parameters (?posCurr ?posNext - pos)\n        :precondition (and (At ?posCurr)\n                           (Adjacent ?posCurr ?posNext)\n                       )\n        :effect   (and (At ?posNext)\n                       (not  (At ?posCurr) )\n                       (when (not (Scared)) (not  (PacmanAt ?posNext) ))\n                   )\n   )\n)",
        "batch_id": 3,
        "id": 144,
        "tokens": 4964,
        "corrected_description": "### General\nThis domain models a simplified version of the classic Pacman game, focusing on the movement of a ghost within a grid. The ghost can move between adjacent positions and has the ability to \"eat\" Pacman under certain conditions, specifically when it is not scared. The domain incorporates the concept of adjacency between positions, the current position of the ghost and Pacman, and whether the ghost is scared.\n\n### Types\n- **pos**: Represents the positions in the grid, treating x-y positions as a single variable.\n\n### Predicates\n- **(At ?p - pos)**: Indicates the current position of the Ghost.\n- **(PacmanAt ?p - pos)**: Indicates the current position of Pacman.\n- **(Adjacent ?pos1 ?pos2 - pos)**: Determines whether two positions are directly connected or adjacent to each other.\n- **(Scared)**: Indicates whether the Ghost is scared of Pacman.\n\n### Actions\n- **move <?posCurr> <?posNext>**: Allows the Ghost to move from its current position to an adjacent position.",
        "pddl_domain_processed": "(define (domain ghost)\n  (:requirements :typing :conditional-effects)\n  (:types pos)\t\t\t\t\n  (:predicates  (At ?p - pos) \t\t\n                (PacmanAt ?p - pos)\t\n                (Adjacent ?pos1 ?pos2 - pos)\t\n                (Scared)\t\t\n  )\n\n  (:action move\n        :parameters (?posCurr ?posNext - pos)\n        :precondition (and (At ?posCurr)\n                           (Adjacent ?posCurr ?posNext)\n                       )\n        :effect   (and (At ?posNext)\n                       (not  (At ?posCurr) )\n                       (when (not (Scared)) (not  (PacmanAt ?posNext) ))\n                   )\n   )\n)"
    },
    {
        "file_name": "AryanSarswat_CS4246_cargodomain.pddl",
        "pddl_domain": "(define (domain cargo_world ) \n(:requirements :strips :typing) \n(:types cargo\nplane\nairport\n) \n(:predicates (cargo_at ?C - cargo ?A - airport) \n(plane_at ?P - plane ?A - airport) \n(in ?C - cargo ?P - plane) \n) \n(:action LOAD\n:parameters ( ?C - cargo ?P - plane ?A - airport) \n:precondition (and (cargo_at ?C ?A) (plane_at ?P ?A))\n:effect (and (not (cargo_at ?C ?A)) (in ?C ?P))\n) \n(:action UNLOAD\n:parameters ( ?C - cargo ?P - plane ?A - airport) \n:precondition (and (in ?C ?P) (plane_at ?P ?A))\n:effect (and (cargo_at ?C ?A) (not (in ?C ?P)))\n) \n(:action FLY\n:parameters ( ?P - plane ?from - airport ?to - airport) \n:precondition (plane_at ?P ?from)\n:effect (and (not (plane_at ?P ?from)) (plane_at ?P ?to))\n) \n) \n",
        "batch_id": 3,
        "id": 145,
        "tokens": 5019,
        "corrected_description": "### General\nThis domain represents a simplified cargo transportation world where planes can load cargo at airports, fly between airports, and unload cargo. The goal is to manage the logistics of moving cargo items from their starting locations to their destinations using planes.\n\n### Types\n- **cargo**: Represents the cargo items that need to be transported.\n- **plane**: Represents the planes used for transporting cargo.\n- **airport**: Represents the airports where planes can load, unload, and fly to and from.\n\n### Predicates\n- **(cargo_at ?C - cargo ?A - airport)**: Indicates that cargo ?C is located at airport ?A.\n- **(plane_at ?P - plane ?A - airport)**: Indicates that plane ?P is located at airport ?A.\n- **(in ?C - cargo ?P - plane)**: Indicates that cargo ?C is inside plane ?P.\n\n### Actions\n- **LOAD <?C> <?P> <?A>**: Allows loading cargo onto a plane at an airport.  \n\n- **UNLOAD <?C> <?P> <?A>**: Allows unloading cargo from a plane at an airport.  \n\n- **FLY <?P> <?from> <?to>**: Allows a plane to fly from one airport to another.",
        "pddl_domain_processed": "(define (domain cargo_world ) \n(:requirements :strips :typing) \n(:types cargo\nplane\nairport\n) \n(:predicates (cargo_at ?C - cargo ?A - airport) \n(plane_at ?P - plane ?A - airport) \n(in ?C - cargo ?P - plane) \n) \n(:action LOAD\n:parameters ( ?C - cargo ?P - plane ?A - airport) \n:precondition (and (cargo_at ?C ?A) (plane_at ?P ?A))\n:effect (and (not (cargo_at ?C ?A)) (in ?C ?P))\n) \n(:action UNLOAD\n:parameters ( ?C - cargo ?P - plane ?A - airport) \n:precondition (and (in ?C ?P) (plane_at ?P ?A))\n:effect (and (cargo_at ?C ?A) (not (in ?C ?P)))\n) \n(:action FLY\n:parameters ( ?P - plane ?from - airport ?to - airport) \n:precondition (plane_at ?P ?from)\n:effect (and (not (plane_at ?P ?from)) (plane_at ?P ?to))\n) \n) \n"
    },
    {
        "file_name": "hyperc-ai_metaplanner_maze1_domain.pddl",
        "pddl_domain": "(define (domain maze1)\n    (:requirements :strips :typing :equality :negative-preconditions :disjunctive-preconditions)\n    (:types agent node - object)\n    (:predicates \n        (is-at ?v1 - agent ?v2 - node)\n        (node-connected ?n1 - node ?n2 - node)\n    )\n\n    (:action move-to-next-node-first-2\n        :parameters (?agent - agent ?node-1 - node ?node-2 - node)\n        :precondition (and\n            (is-at ?agent ?node-1)\n            (node-connected ?node-1 ?node-2)\n        )\n        :effect (and\n            (is-at ?agent ?node-2)\n            (not (is-at ?agent ?node-1))\n        )\n    )\n\n    (:action move-to-next-node-first\n        :parameters (?agent - agent ?node-1 - node ?node-2 - node)\n        :precondition (and\n            (is-at ?agent ?node-1)\n            (node-connected ?node-1 ?node-2)\n        )\n        :effect (and\n            (is-at ?agent ?node-2)\n            (not (is-at ?agent ?node-1))\n        )\n    )\n\n)\n",
        "batch_id": 3,
        "id": 147,
        "tokens": 4965,
        "corrected_description": "### General\nThis domain represents a simple maze navigation problem where an agent can move between connected nodes. The goal is to navigate the maze by moving from node to node based on the connections between them.\n\n### Types\n- agent: Represents entities capable of moving through the maze.\n- node: Represents locations within the maze.\n\n### Predicates\n- (is-at ?v1 - agent ?v2 - node): Indicates that agent ?v1 is currently at node ?v2.\n- (node-connected ?n1 - node ?n2 - node): Indicates that there is a direct connection from node ?n1 to node ?n2, allowing an agent to move between them.\n\n### Actions\n- move-to-next-node-first-2 <?agent> <?node-1> <?node-2>: Allows an agent to move from one node to another if the two nodes are connected.  \n\n- move-to-next-node-first <?agent> <?node-1> <?node-2>: Similar to move-to-next-node-first-2, this action allows an agent to move from one node to another based on the connection between the nodes.",
        "pddl_domain_processed": "(define (domain maze1)\n    (:requirements :strips :typing :equality :negative-preconditions :disjunctive-preconditions)\n    (:types agent node - object)\n    (:predicates \n        (is-at ?v1 - agent ?v2 - node)\n        (node-connected ?n1 - node ?n2 - node)\n    )\n\n    (:action move-to-next-node-first-2\n        :parameters (?agent - agent ?node-1 - node ?node-2 - node)\n        :precondition (and\n            (is-at ?agent ?node-1)\n            (node-connected ?node-1 ?node-2)\n        )\n        :effect (and\n            (is-at ?agent ?node-2)\n            (not (is-at ?agent ?node-1))\n        )\n    )\n\n    (:action move-to-next-node-first\n        :parameters (?agent - agent ?node-1 - node ?node-2 - node)\n        :precondition (and\n            (is-at ?agent ?node-1)\n            (node-connected ?node-1 ?node-2)\n        )\n        :effect (and\n            (is-at ?agent ?node-2)\n            (not (is-at ?agent ?node-1))\n        )\n    )\n\n)\n"
    },
    {
        "file_name": "ivalab_affordanceNet_Context_#domain.pddl#",
        "pddl_domain": "(define (domain handy)\n    (:predicates (GRASPABLE ?x)\n                 (carry ?x ?y)\n\t\t (free ?x)\n                 (CONTAINABLE ?x)\n\t\t (contains ?x ?y))\n\t\t\n\n    (:action pickup :parameters(?x ?y)\n        :precondition (and (GRASPABLE ?x)\n\t                   (free ?y))\n\t\t\t   \n        :effect       (and (carry ?y ?x)\n\t                   (not (free ?y))\n\t                   (not (GRASPABLE ?x))))\n\n    (:action dropoff :parameters (?x ?y ?z)\n        :precondition (and (carry ?y ?x)\n\t                   (CONTAINABLE ?z))\n\t\t\t   \n\t:effect       (and (contains ?z ?x)\n                           (GRASPABLE ?x)\n\t                   (free ?y)\n\t\t\t   (not (carry ?y ?x))))\n\n)\n\t                   \n",
        "batch_id": 3,
        "id": 148,
        "tokens": 5054,
        "corrected_description": "### General\nThe domain \"handy\" involves interactions with objects that can be grasped or contained. It focuses on the actions of picking up objects that can be grasped and dropping them off into containers. The agents in this domain have the capability to carry objects and place them into containers that can hold them.\n\n### Predicates\n- (GRASPABLE ?x): Indicates that object ?x can be grasped.\n- (carry ?x ?y): Indicates that agent ?x is carrying object ?y.\n- (free ?x): Indicates that agent ?x is not currently carrying any object.\n- (CONTAINABLE ?x): Indicates that object ?x can contain other objects.\n- (contains ?x ?y): Indicates that container ?x contains object ?y.\n\n### Actions\n- pickup <?x> <?y>: This action allows an agent ?y to pick up an object ?x that can be grasped.  \n\n- dropoff <?x> <?y> <?z>: This action allows an agent ?y to drop off an object ?x it is carrying into a container ?z that can contain objects.",
        "pddl_domain_processed": "(define (domain handy)\n    (:predicates (GRASPABLE ?x)\n                 (carry ?x ?y)\n\t\t (free ?x)\n                 (CONTAINABLE ?x)\n\t\t (contains ?x ?y))\n\n    (:action pickup :parameters(?x ?y)\n        :precondition (and (GRASPABLE ?x)\n\t                   (free ?y))\n\n        :effect       (and (carry ?y ?x)\n\t                   (not (free ?y))\n\t                   (not (GRASPABLE ?x))))\n\n    (:action dropoff :parameters (?x ?y ?z)\n        :precondition (and (carry ?y ?x)\n\t                   (CONTAINABLE ?z))\n\n\t:effect       (and (contains ?z ?x)\n                           (GRASPABLE ?x)\n\t                   (free ?y)\n\t\t\t   (not (carry ?y ?x))))\n\n)\n\n"
    },
    {
        "file_name": "aash29_GLMap_logisticsDomain.pddl",
        "pddl_domain": "\n(define (domain logistics_PDDL)\n(:requirements :adl)\n(:types\n    food - object\n    door - object\n    area - object\n    key-type - object)\n\n(:predicates \n\t(npc-at ?area)\n\t(npc-close-to ?point)\n    (npc-holding ?o)\n\t(npc-not-close-to-point)\n\n\t(point-of-interest ?point ?area)\n\n\t(item ?item)\n\n\t(key ?item ?waypoint)\n\n\t(connected ?area1 ?area2 ?waypoint)\n\t\t\n\t(waypoint ?waypoint)\n\t(open ?waypoint)\n\t(closed ?waypoint)\n)\n\n(:action move-to-point\n:parameters (?area ?point)\n:precondition (and\n\t\t(npc-at ?area)\n\t\t(point-of-interest ?point ?area)\n\t\t(npc-not-close-to-point)\n\t\t)\n:effect (and\n\t\t(npc-close-to ?point)\n\t\t(not (npc-not-close-to-point))\n\t)\n)\n\n\n(:action move-to-area\n:parameters (?fromarea ?toarea ?waypoint)\n:precondition (and \n\t\t(connected ?fromarea ?toarea ?waypoint)\n               \t(npc-at ?fromarea)\n\t\t(waypoint ?waypoint)\n\t\t(open ?waypoint)\n\t\t(npc-close-to ?waypoint)\n\t\t)\n:effect (and \n\t\t(npc-at ?toarea)\n\t\t(npc-not-close-to-point)\n             \t(not (npc-at ?fromarea))\n\t\t(not (npc-close-to ?waypoint))\n\t)\n)\n\n\n(:action move-to-point-from-point\n:parameters (?area ?point ?previouspoint)\n:precondition (and\n\t\t(npc-at ?area)\n\t\t(point-of-interest ?point ?area)\n\t\t(point-of-interest ?previouspoint ?area)\n\t\t(npc-close-to ?previouspoint)\n\t\t)\n:effect (and\n\t\t(npc-close-to ?point)\n\t\t(not (npc-close-to ?previouspoint))\n\t\t(not (npc-not-close-to-point))\n\t)\n)\n\n(:action make-accessible\n:parameters (?area1 ?area2 ?waypoint ?item)\n:precondition (and\n\t\t(npc-holding ?item)\n\t\t(key ?item ?waypoint)\n\t\t(npc-at ?area1)\n\t\t(connected ?area1 ?area2 ?waypoint)\n\t\t(waypoint ?waypoint)\n\t\t(closed ?waypoint)\n\t\t(npc-close-to ?waypoint)\n\t\t)\n:effect (and\n\t\t(not (closed ?waypoint))\n\t\t(open ?waypoint)\n\t\t(not (npc-holding ?item))\n\t)\n)\n\n\n(:action place-in-inventory\n:parameters (?area ?item)\n:precondition (and \n\t\t(npc-at ?area)\n               \t(point-of-interest ?item ?area)\n\t\t(npc-close-to ?item)\n\t\t(item ?item)\n\t\t)\n:effect (and \n\t\t(not (point-of-interest ?item ?area))\n             \t(npc-holding ?item)\n\t\t(not (npc-close-to ?item))\n\t\t(npc-not-close-to-point)\n\t)\n)\n\n)\n",
        "batch_id": 3,
        "id": 149,
        "tokens": 5767,
        "corrected_description": "### General\nThis domain models a logistics scenario involving an NPC (non-player character) that can move between areas, interact with points of interest, and manipulate items including keys to open waypoints between areas. The goal is to navigate the NPC through various areas, collecting items and making areas accessible by opening closed waypoints.\n\n### Types\n- **food**: A subtype of object, representing food items.\n- **door**: A subtype of object, representing doors or gateways.\n- **area**: A base type for locations in the domain.\n- **key-type**: A subtype of object, representing keys that can open doors or gateways.\n\n### Predicates\n- **(npc-at ?area)**: Indicates the NPC is currently at a specific area.\n- **(npc-close-to ?point)**: Indicates the NPC is close to a specific point of interest.\n- **(npc-holding ?o)**: Indicates the NPC is holding an object ?o.\n- **(npc-not-close-to-point)**: Indicates the NPC is not close to any point of interest.\n- **(point-of-interest ?point ?area)**: Indicates ?point is a point of interest within ?area.\n- **(item ?item)**: Indicates ?item is an item that can be interacted with.\n- **(key ?item ?waypoint)**: Indicates ?item is a key that can open ?waypoint.\n- **(connected ?area1 ?area2 ?waypoint)**: Indicates ?area1 and ?area2 are connected through ?waypoint.\n- **(waypoint ?waypoint)**: Indicates ?waypoint is a waypoint between areas.\n- **(open ?waypoint)**: Indicates ?waypoint is open.\n- **(closed ?waypoint)**: Indicates ?waypoint is closed.\n\n### Actions\n- **move-to-point <?area> <?point>**: Moves the NPC to a point (?point) of interest within the current area (?area).  \n  \n- **move-to-area <?fromarea> <?toarea> <?waypoint>**: This action moves the NPC from one area (?fromarea) to another (?toarea) through an open waypoint (?waypoint).  \n  \n- **move-to-point-from-point <?area> <?point> <?previouspoint>**: This action moves the NPC from one point (?previouspoint) of interest to another (?point) within the same area (?area).  \n  \n- **make-accessible <?area1> <?area2> <?waypoint> <?item>**: This action opens a closed waypoint (?waypoint) from (?area1) to (?area2) using a key (?item).  \n  \n- **place-in-inventory <?area> <?item>**: This action places an item (?item) into the NPC's inventory at area (?area).",
        "pddl_domain_processed": "\n(define (domain logistics_PDDL)\n(:requirements :adl)\n(:types\n    food - object\n    door - object\n    area - object\n    key-type - object)\n\n(:predicates \n\t(npc-at ?area)\n\t(npc-close-to ?point)\n    (npc-holding ?o)\n\t(npc-not-close-to-point)\n\n\t(point-of-interest ?point ?area)\n\n\t(item ?item)\n\n\t(key ?item ?waypoint)\n\n\t(connected ?area1 ?area2 ?waypoint)\n\n\t(waypoint ?waypoint)\n\t(open ?waypoint)\n\t(closed ?waypoint)\n)\n\n(:action move-to-point\n:parameters (?area ?point)\n:precondition (and\n\t\t(npc-at ?area)\n\t\t(point-of-interest ?point ?area)\n\t\t(npc-not-close-to-point)\n\t\t)\n:effect (and\n\t\t(npc-close-to ?point)\n\t\t(not (npc-not-close-to-point))\n\t)\n)\n\n(:action move-to-area\n:parameters (?fromarea ?toarea ?waypoint)\n:precondition (and \n\t\t(connected ?fromarea ?toarea ?waypoint)\n               \t(npc-at ?fromarea)\n\t\t(waypoint ?waypoint)\n\t\t(open ?waypoint)\n\t\t(npc-close-to ?waypoint)\n\t\t)\n:effect (and \n\t\t(npc-at ?toarea)\n\t\t(npc-not-close-to-point)\n             \t(not (npc-at ?fromarea))\n\t\t(not (npc-close-to ?waypoint))\n\t)\n)\n\n(:action move-to-point-from-point\n:parameters (?area ?point ?previouspoint)\n:precondition (and\n\t\t(npc-at ?area)\n\t\t(point-of-interest ?point ?area)\n\t\t(point-of-interest ?previouspoint ?area)\n\t\t(npc-close-to ?previouspoint)\n\t\t)\n:effect (and\n\t\t(npc-close-to ?point)\n\t\t(not (npc-close-to ?previouspoint))\n\t\t(not (npc-not-close-to-point))\n\t)\n)\n\n(:action make-accessible\n:parameters (?area1 ?area2 ?waypoint ?item)\n:precondition (and\n\t\t(npc-holding ?item)\n\t\t(key ?item ?waypoint)\n\t\t(npc-at ?area1)\n\t\t(connected ?area1 ?area2 ?waypoint)\n\t\t(waypoint ?waypoint)\n\t\t(closed ?waypoint)\n\t\t(npc-close-to ?waypoint)\n\t\t)\n:effect (and\n\t\t(not (closed ?waypoint))\n\t\t(open ?waypoint)\n\t\t(not (npc-holding ?item))\n\t)\n)\n\n(:action place-in-inventory\n:parameters (?area ?item)\n:precondition (and \n\t\t(npc-at ?area)\n               \t(point-of-interest ?item ?area)\n\t\t(npc-close-to ?item)\n\t\t(item ?item)\n\t\t)\n:effect (and \n\t\t(not (point-of-interest ?item ?area))\n             \t(npc-holding ?item)\n\t\t(not (npc-close-to ?item))\n\t\t(npc-not-close-to-point)\n\t)\n)\n\n)\n"
    },
    {
        "file_name": "davislf2_AI_Pacman_pacmanDomain.pddl",
        "pddl_domain": "(define (domain pacman)\n    (:requirements :typing)\n    (:types position)\n\n    ;; The predicates represent a set of connected grid locations that can be\n    ;; moved between and visited, in addition to facts that keep track of\n    ;; the food located in the grid, and carried by Pacman.\n    (:predicates\n        (move ?from ?to - position)\n        (at ?pos - position)\n        (visited ?pos - position)\n        (connected ?from ?to - position)\n        (eat ?pos - position)\n        (hasFood ?pos - position)\n        (carryingFood)\n    )\n\n    ;; A Pacman is able to move to a connected position.\n    (:action move\n        :parameters\n            (?from ?to - position)\n        :precondition\n            (and\n                (at ?from)\n                (connected ?from ?to)\n            )\n        :effect\n            (and\n                (at ?to)\n                (not (at ?from))\n                (visited ?to)\n            )\n    )\n\n    ;; While eating occurs instantaneously in the main game, we can separate\n    ;; this into a second action for planning purposes as a simplification.\n    (:action eat\n        :parameters\n            (?pos - position)\n        :precondition\n            (and\n                (at ?pos)\n                (hasFood ?pos)\n            )\n        :effect\n            (and\n                (carryingFood)\n                (not (hasFood ?pos))\n            )\n    )\n)\n",
        "batch_id": 3,
        "id": 151,
        "tokens": 5171,
        "corrected_description": "### General\nThis domain models the classic Pacman game, focusing on movement and eating actions within a grid of positions. Pacman can move between connected positions, eat food at certain positions, and track visited positions. The goal is to plan Pacman's movements and eating actions to collect all food while efficiently navigating the grid.\n\n### Types\n- **position**: Represents the grid locations within the Pacman game world.\n\n### Predicates\n- **(move ?from ?to - position)**: Represents the potential movement action from one position to another, given they are connected.\n- **(at ?pos - position)**: Indicates that Pacman is currently at a specific position.\n- **(visited ?pos - position)**: Marks a position as visited by Pacman.\n- **(connected ?from ?to - position)**: Indicates that two positions are directly connected and Pacman can move between them.\n- **(eat ?pos - position)**: Represents the action of eating food located at a specific position.\n- **(hasFood ?pos - position)**: Indicates that there is food at a specific position.\n- **(carryingFood)**: Indicates that Pacman is currently carrying food after eating it.\n\n### Actions\n- **move <?from> <?to>**: Allows Pacman to move from one position to another if they are connected, and this action updates Pacman's current position and marks the new position as visited.  \n\n- **eat <?pos>**: Allows Pacman to eat food at the current position and this action is only possible if there is food at Pacman's current position.",
        "pddl_domain_processed": "(define (domain pacman)\n    (:requirements :typing)\n    (:types position)\n\n    (:predicates\n        (move ?from ?to - position)\n        (at ?pos - position)\n        (visited ?pos - position)\n        (connected ?from ?to - position)\n        (eat ?pos - position)\n        (hasFood ?pos - position)\n        (carryingFood)\n    )\n\n    (:action move\n        :parameters\n            (?from ?to - position)\n        :precondition\n            (and\n                (at ?from)\n                (connected ?from ?to)\n            )\n        :effect\n            (and\n                (at ?to)\n                (not (at ?from))\n                (visited ?to)\n            )\n    )\n\n    (:action eat\n        :parameters\n            (?pos - position)\n        :precondition\n            (and\n                (at ?pos)\n                (hasFood ?pos)\n            )\n        :effect\n            (and\n                (carryingFood)\n                (not (hasFood ?pos))\n            )\n    )\n)\n"
    },
    {
        "file_name": "samuelmurray_foodora-routing-problem_foodora_domain.pddl",
        "pddl_domain": "(define (domain foodora_domain)\n  (:requirements :strips :typing :adl)\n  \n  (:types node restaurant customer biker)\n  \n  (:predicates (edge ?node ?node)\n               (at-r ?restaurant ?node)\n\t\t\t   (at-c ?customer ?node)\n\t\t\t   (at-b ?biker ?node)\n\t\t\t   (rGotFoodFor ?restaurant ?customer)\n\t\t\t   (bGotFoodFor ?biker ?customer)\n\t\t\t   (notHaveFood ?biker)\n\t\t\t   (gotFood ?customer))\n\t\t\t   \n\n  (:action move\n    :parameters (?b - biker ?from - node ?to - node)\n    :precondition (and (at-b ?b ?from) (edge ?from ?to))\n    :effect (and (not (at-b ?b ?from)) (at-b ?b ?to))\n   )\n\n  (:action pickUpFood\n    :parameters (?b - biker ?r - restaurant ?c - customer ?n - node)\n    :precondition (and (at-b ?b ?n) (at-r ?r ?n) (notHaveFood ?b) (rGotFoodFor ?r ?c))\n    :effect (and (not (notHaveFood ?b)) (bGotFoodFor ?b ?c) (not (rGotFoodFor ?r ?c)))\n   )  \n   \n  (:action deliverFood\n    :parameters (?b - biker ?c - customer ?n - node)\n    :precondition (and (at-b ?b ?n) (at-c ?c ?n) (bGotFoodFor ?b ?c))\n    :effect (and (notHaveFood ?b) (not (bGotFoodFor ?b ?c)) (gotFood ?c))\n   )\n   \n \n )",
        "batch_id": 3,
        "id": 153,
        "tokens": 5297,
        "corrected_description": "### General\nThis domain models a food delivery service, where bikers pick up food from restaurants and deliver it to customers. The domain includes entities such as nodes (representing locations), restaurants, customers, and bikers. The goal is to ensure that all customers receive their food.\n\n### Types\n- **node**: Represents locations in the delivery network.\n- **restaurant**: Entities that prepare food for customers.\n- **customer**: Entities that order food and await delivery.\n- **biker**: Delivery personnel who pick up food from restaurants and deliver it to customers.\n\n### Predicates\n- **(edge ?node1 ?node2)**: Indicates there is a direct path between node1 and node2.\n- **(at-r ?restaurant ?node)**: Indicates a restaurant is located at a node.\n- **(at-c ?customer ?node)**: Indicates a customer is located at a node.\n- **(at-b ?biker ?node)**: Indicates a biker is located at a node.\n- **(rGotFoodFor ?restaurant ?customer)**: Indicates a restaurant has prepared food for a specific customer.\n- **(bGotFoodFor ?biker ?customer)**: Indicates a biker has picked up food for a specific customer.\n- **(notHaveFood ?biker)**: Indicates a biker does not currently have any food to deliver.\n- **(gotFood ?customer)**: Indicates a customer has received their food.\n\n### Actions\n- **move <?b> <?from> <?to>**: Allows a biker to move from one node to another.  \n  \n- **pickUpFood <?b> <?r> <?c> <?n>**: Allows a biker to pick up food for a customer from a restaurant.  \n  \n- **deliverFood <?b> <?c> <?n>**: Allows a biker to deliver food to a customer.",
        "pddl_domain_processed": "(define (domain foodora_domain)\n  (:requirements :strips :typing :adl)\n\n  (:types node restaurant customer biker)\n\n  (:predicates (edge ?node ?node)\n               (at-r ?restaurant ?node)\n\t\t\t   (at-c ?customer ?node)\n\t\t\t   (at-b ?biker ?node)\n\t\t\t   (rGotFoodFor ?restaurant ?customer)\n\t\t\t   (bGotFoodFor ?biker ?customer)\n\t\t\t   (notHaveFood ?biker)\n\t\t\t   (gotFood ?customer))\n\n  (:action move\n    :parameters (?b - biker ?from - node ?to - node)\n    :precondition (and (at-b ?b ?from) (edge ?from ?to))\n    :effect (and (not (at-b ?b ?from)) (at-b ?b ?to))\n   )\n\n  (:action pickUpFood\n    :parameters (?b - biker ?r - restaurant ?c - customer ?n - node)\n    :precondition (and (at-b ?b ?n) (at-r ?r ?n) (notHaveFood ?b) (rGotFoodFor ?r ?c))\n    :effect (and (not (notHaveFood ?b)) (bGotFoodFor ?b ?c) (not (rGotFoodFor ?r ?c)))\n   )  \n\n  (:action deliverFood\n    :parameters (?b - biker ?c - customer ?n - node)\n    :precondition (and (at-b ?b ?n) (at-c ?c ?n) (bGotFoodFor ?b ?c))\n    :effect (and (notHaveFood ?b) (not (bGotFoodFor ?b ?c)) (gotFood ?c))\n   )\n\n )"
    },
    {
        "file_name": "BryanPanda_EECS_348_Intro_to_AI_student_domain.pddl",
        "pddl_domain": "(define (domain nosliw)\n  (:requirements :strips :typing)\n  (:types item agent location - object\n          town mountain cave - location\n          hero sorceress wizard dragon - agent\n          diamond pen sword - item)\n  (:predicates (at ?object - object ?location - location) \n               (path-from-to ?location1 - location ?location2 - location)\n               (different ?item1 - item ?item2 - item)\n               (possesses ?agent - agent ?item - item)\n               (strong ?hero - hero)\n               (asleep ?dragon - dragon)\n               (safe ?town - town)\n               (dead ?dragon - dragon)\n               )\n\n  (:action move\n      :parameters (?hero - hero ?location1 ?location2 - location)\n      :precondition (and (at ?hero ?location1)\n                         (path-from-to ?location1 ?location2)\n                         )\n      :effect (and (at ?hero ?location2)\n                   (not (at ?hero ?location1))\n                   ))\n\n  (:action trade\n     :parameters (?hero - hero ?agent - agent ?location - location ?item1 ?item2 - item)\n     :precondition (and (at ?hero ?location)\n                        (at ?agent ?location)\n                        (possesses ?hero ?item1)\n                        (possesses ?agent ?item2)\n                        )\n     :effect (and (possesses ?hero ?item2)\n                  (possesses ?agent ?item1)\n                  (not (possesses ?hero ?item1))\n                  (not (possesses ?agent ?item2))\n                  ))\n\n  (:action pickup\n     :parameters (?hero - hero ?location - location ?item - item)\n     :precondition (and (at ?hero ?location)\n                        (at ?item ?location)\n                        )\n     :effect (and (not (at ?item ?location))\n                  (possesses ?hero ?item)\n                  ))\n\n  (:action drop\n     :parameters (?hero - hero ?location - location ?item - item)\n     :precondition (and (at ?hero ?location)                        \n                        (possesses ?hero ?item)\n                        )\n     :effect (and (not (possesses ?hero ?item))\n                  (at ?item ?location)\n                  ))\n\n  (:action magic\n     :parameters (?hero - hero ?agent - agent ?location - location ?diamond1 ?diamond2 ?diamond3 - diamond)\n     :precondition (and (at ?hero ?location)\n                        (at ?agent ?location)\n                        (possesses ?hero ?diamond1)\n                        (possesses ?hero ?diamond2)\n                        (possesses ?hero ?diamond3)\n                        (different ?diamond1 ?diamond2)\n                        (different ?diamond2 ?diamond3)\n                        (different ?diamond1 ?diamond3)\n                        )\n     :effect (and (strong ?hero)\n                  (not (possesses ?hero ?diamond1))\n                  (not (possesses ?hero ?diamond2))\n                  (not (possesses ?hero ?diamond3))\n                  ))\n\n  (:action song\n     :parameters (?hero - hero ?town - town ?quill - pen ?dragon - dragon)\n     :precondition (and (possesses ?hero ?quill)\n                        )\n     :effect (and (asleep ?dragon)\n                  (safe ?town)\n                  ))\n\n  (:action slaying\n     :parameters (?hero - hero ?dragon - dragon ?cave - cave ?sword - sword ?town - town)\n     :precondition (and (at ?hero ?cave)\n                        (strong ?hero)\n                        (possesses ?hero ?sword)\n                        )\n     :effect (and (dead ?dragon)\n                  (safe ?town)\n                  ))\n\n)\n",
        "batch_id": 3,
        "id": 155,
        "tokens": 5774,
        "corrected_description": "### General\nThe domain \"nosliw\" involves a fantasy setting where heroes, sorceresses, wizards, and dragons interact with various items like diamonds, pens, and swords across different locations such as towns, mountains, and caves. The primary goal is to navigate these interactions to achieve specific objectives like making a town safe or defeating a dragon.\n\n### Types\n- **item**: Objects that can be possessed or used by agents.\n- **diamond**: Precious items used in magic.\n- **pen**: Writing instruments used in singing actions.\n- **sword**: Weapons used for slaying dragons.\n- **agent**: Characters that can perform actions in the domain.\n- **hero**: Brave agents who undertake various tasks and adventures.\n- **sorceress**: Magical agents who can possess items.\n- **wizard**: Wise agents with magical abilities.\n- **dragon**: Powerful creatures that can be put to sleep or slain.\n- **location**: Places where actions occur.\n- **town**: Safe places that can be protected.\n- **mountain**: High locations that might contain paths.\n- **cave**: Dark places where dragons can be found.\n\n### Predicates\n- **(at ?object - object ?location - location)**: Indicates that an object or agent is at a specific location.\n- **(path-from-to ?location1 - location ?location2 - location)**: Represents a path between two locations.\n- **(different ?item1 - item ?item2 - item)**: Asserts that two items are different.\n- **(possesses ?agent - agent ?item - item)**: Indicates that an agent possesses an item.\n- **(strong ?hero - hero)**: Indicates that a hero is strong.\n- **(asleep ?dragon - dragon)**: Indicates that a dragon is asleep.\n- **(safe ?town - town)**: Indicates that a town is safe.\n- **(dead ?dragon - dragon)**: Indicates that a dragon is dead.\n\n### Actions\n- **move <?hero> <?location1> <?location2>**: Allows a hero to move from one location to another if there is a path between them.  \n- **trade <?hero> <?agent> <?location> <?item1> <?item2>**: Allows a hero to trade an item with another agent at the same location.  \n- **pickup <?hero> <?location> <?item>**: Allows a hero to pick up an item at their current location.  \n- **drop <?hero> <?location> <?item>**: Allows a hero to drop an item at their current location.  \n- **magic <?hero> <?agent> <?location> <?diamond1> <?diamond2> <?diamond3>**: A hero can use three different diamonds to become strong when at the same location as another agent.  \n- **song <?hero> <?town> <?quill> <?dragon>**: A hero can use a quill to sing a song that puts a dragon to sleep and makes a town safe.  \n- **slaying <?hero> <?dragon> <?cave> <?sword> <?town>**: A strong hero with a sword can slay a dragon in a cave, making a nearby town safe.",
        "pddl_domain_processed": "(define (domain nosliw)\n  (:requirements :strips :typing)\n  (:types item agent location - object\n          town mountain cave - location\n          hero sorceress wizard dragon - agent\n          diamond pen sword - item)\n  (:predicates (at ?object - object ?location - location) \n               (path-from-to ?location1 - location ?location2 - location)\n               (different ?item1 - item ?item2 - item)\n               (possesses ?agent - agent ?item - item)\n               (strong ?hero - hero)\n               (asleep ?dragon - dragon)\n               (safe ?town - town)\n               (dead ?dragon - dragon)\n               )\n\n  (:action move\n      :parameters (?hero - hero ?location1 ?location2 - location)\n      :precondition (and (at ?hero ?location1)\n                         (path-from-to ?location1 ?location2)\n                         )\n      :effect (and (at ?hero ?location2)\n                   (not (at ?hero ?location1))\n                   ))\n\n  (:action trade\n     :parameters (?hero - hero ?agent - agent ?location - location ?item1 ?item2 - item)\n     :precondition (and (at ?hero ?location)\n                        (at ?agent ?location)\n                        (possesses ?hero ?item1)\n                        (possesses ?agent ?item2)\n                        )\n     :effect (and (possesses ?hero ?item2)\n                  (possesses ?agent ?item1)\n                  (not (possesses ?hero ?item1))\n                  (not (possesses ?agent ?item2))\n                  ))\n\n  (:action pickup\n     :parameters (?hero - hero ?location - location ?item - item)\n     :precondition (and (at ?hero ?location)\n                        (at ?item ?location)\n                        )\n     :effect (and (not (at ?item ?location))\n                  (possesses ?hero ?item)\n                  ))\n\n  (:action drop\n     :parameters (?hero - hero ?location - location ?item - item)\n     :precondition (and (at ?hero ?location)                        \n                        (possesses ?hero ?item)\n                        )\n     :effect (and (not (possesses ?hero ?item))\n                  (at ?item ?location)\n                  ))\n\n  (:action magic\n     :parameters (?hero - hero ?agent - agent ?location - location ?diamond1 ?diamond2 ?diamond3 - diamond)\n     :precondition (and (at ?hero ?location)\n                        (at ?agent ?location)\n                        (possesses ?hero ?diamond1)\n                        (possesses ?hero ?diamond2)\n                        (possesses ?hero ?diamond3)\n                        (different ?diamond1 ?diamond2)\n                        (different ?diamond2 ?diamond3)\n                        (different ?diamond1 ?diamond3)\n                        )\n     :effect (and (strong ?hero)\n                  (not (possesses ?hero ?diamond1))\n                  (not (possesses ?hero ?diamond2))\n                  (not (possesses ?hero ?diamond3))\n                  ))\n\n  (:action song\n     :parameters (?hero - hero ?town - town ?quill - pen ?dragon - dragon)\n     :precondition (and (possesses ?hero ?quill)\n                        )\n     :effect (and (asleep ?dragon)\n                  (safe ?town)\n                  ))\n\n  (:action slaying\n     :parameters (?hero - hero ?dragon - dragon ?cave - cave ?sword - sword ?town - town)\n     :precondition (and (at ?hero ?cave)\n                        (strong ?hero)\n                        (possesses ?hero ?sword)\n                        )\n     :effect (and (dead ?dragon)\n                  (safe ?town)\n                  ))\n\n)\n"
    },
    {
        "file_name": "diplay_Project_dt_domain.pddl",
        "pddl_domain": "(define (domain tutor-ies-designtime)\n(:requirements :typing :adl :action-costs)\n(:types \n    developed-component - object\n    development-step - developed-component\n    ontology skills-extractor - developed-component\n    )\n\n(:constants \n psycho-config-step group-config-step timetables-development-step competences-development-step onthology-development-step training-impact-development-step - development-step\n)\n\n(:predicates \n    (finished ?s - developed-component)\n    (finished-in-current-session ?s - developed-component)\n    (follows ?s1 - development-step ?s2 - development-step)\n    (completed)\n)\n\n(:functions\n    (total-cost) - number\n)\n\n(:action execute-development-step\n    :parameters (?step - development-step)\n    :precondition (and (not (finished ?step))\n               (forall (?pstep - development-step)\n                   (imply (follows ?step ?pstep)\n                      (and (not (finished-in-current-session ?pstep)) (finished ?pstep)))))\n    :effect (and (finished ?step) (finished-in-current-session ?step) (increase (total-cost) 1))\n)\n\n(:action execute-development-step-future\n    :parameters (?step - development-step)\n    :precondition (and (not (finished ?step))\n               (forall (?pstep - development-step)\n                   (imply (follows ?step ?pstep)\n                      (finished ?pstep))))\n    :effect (and (finished ?step) (finished-in-current-session ?step) (increase (total-cost) 2))\n)\n\n(:action int-finalize-development\n    :parameters ()\n    :precondition (forall (?comp - developed-component) (finished ?comp))\n    :effect (completed)\n)\n\n)\n\n",
        "batch_id": 3,
        "id": 158,
        "tokens": 5342,
        "corrected_description": "### General\nThis domain is designed for managing the development process of educational components, including ontologies and skills extractors. It involves executing development steps with associated costs and ensuring that certain prerequisites are met before a development step can be completed.\n\n### Types\n- **object**: The base type for all entities in this domain.\n- **developed-component**: Represents components that are being developed. This includes both the final components and the steps involved in their development.\n- **development-step**: A subtype of developed-component, representing individual steps in the development process.\n- **ontology, skills-extractor**: Subtypes of developed-component, representing specific types of components that can be developed.\n\n### Constants\n- **psycho-config-step**: Represents a development step in the psychological configuration process.\n- **group-config-step**: Represents a development step in the group configuration process.\n- **timetables-development-step**: Represents a development step in the timetables development process.\n- **competences-development-step**: Represents a development step in the competences development process.\n- **onthology-development-step**: Represents a development step in the ontology development process.\n- **training-impact-development-step**: Represents a development step in the training impact development process.\n\n### Predicates\n- **(finished ?s - developed-component)**: Indicates that a developed component or development step ?s has been completed.\n- **(finished-in-current-session ?s - developed-component)**: Indicates that a developed component or development step ?s has been completed in the current session.\n- **(follows ?s1 - development-step ?s2 - development-step)**: Establishes a prerequisite relationship where ?s1 can only be started after ?s2 is completed.\n- **(completed)**: Indicates that the entire development process has been completed.\n\n### Functions\n- **(total-cost) - number**: Represents the total cost accumulated from executing development steps.\n\n### Actions\n- **execute-development-step <?step>**: Executes a development step if it has not been finished and all prerequisite steps have been completed but not in the current session. This action increases the total cost by 1.  \n\n- **execute-development-step-future <?step>**: Similar to execute-development-step, but used for steps that can be executed based on the completion of all prerequisite steps, regardless of the session. This action increases the total cost by 2.  \n\n- **int-finalize-development**: Finalizes the development process if all components have been finished.",
        "pddl_domain_processed": "(define (domain tutor-ies-designtime)\n(:requirements :typing :adl :action-costs)\n(:types \n    developed-component - object\n    development-step - developed-component\n    ontology skills-extractor - developed-component\n    )\n\n(:constants \n psycho-config-step group-config-step timetables-development-step competences-development-step onthology-development-step training-impact-development-step - development-step\n)\n\n(:predicates \n    (finished ?s - developed-component)\n    (finished-in-current-session ?s - developed-component)\n    (follows ?s1 - development-step ?s2 - development-step)\n    (completed)\n)\n\n(:functions\n    (total-cost) - number\n)\n\n(:action execute-development-step\n    :parameters (?step - development-step)\n    :precondition (and (not (finished ?step))\n               (forall (?pstep - development-step)\n                   (imply (follows ?step ?pstep)\n                      (and (not (finished-in-current-session ?pstep)) (finished ?pstep)))))\n    :effect (and (finished ?step) (finished-in-current-session ?step) (increase (total-cost) 1))\n)\n\n(:action execute-development-step-future\n    :parameters (?step - development-step)\n    :precondition (and (not (finished ?step))\n               (forall (?pstep - development-step)\n                   (imply (follows ?step ?pstep)\n                      (finished ?pstep))))\n    :effect (and (finished ?step) (finished-in-current-session ?step) (increase (total-cost) 2))\n)\n\n(:action int-finalize-development\n    :parameters ()\n    :precondition (forall (?comp - developed-component) (finished ?comp))\n    :effect (completed)\n)\n\n)\n\n"
    },
    {
        "file_name": "jamesxwang_Melbourne-CS-Subjects_2-ops-domain.pddl",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; 2 Op-blocks world\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain BLOCKS)\n  (:requirements :strips)\n  (:predicates (on ?x ?y)\n\t       (ontable ?x)\n\t       (clear ?x)\n\t       )\n\n  (:action move-to-block\n\t     :parameters (?x ?to)\n\t     :precondition (and (clear ?x) (ontable ?x) (clear ?to))\n\t     :effect\n\t     (and \n\t\t      (on ?x ?to)\n\t          (not (ontable ?x))\n\t\t      (not (clear ?to))\n\t\t      \n\t\t )\n  )\n\n (:action move-to-table\n\t     :parameters (?x ?from)\n\t     :precondition (and (clear ?x) (on ?x ?from) )\n\t     :effect\n\t     (and (not (on ?x ?from))\n\t\t      (clear ?from)\n\t\t      (ontable ?x)\n\t\t )\n  )\n)",
        "batch_id": 3,
        "id": 165,
        "tokens": 4882,
        "corrected_description": "### General\nThis domain represents a simplified blocks world where blocks can be moved either on top of other blocks or back to the table. The goal is to rearrange the blocks as required, ensuring that specific blocks are stacked on others or placed on the table.\n\n### Predicates\n- **(on ?x ?y)**: Indicates that block ?x is directly on top of block ?y.\n- **(ontable ?x)**: Indicates that block ?x is directly on the table.\n- **(clear ?x)**: Indicates that the top of block ?x is clear, with no other blocks on it.\n\n### Actions\n- **move-to-block <?x> <?to>**: Allows moving a block ?x on top of another block ?to.  \n\n- **move-to-table <?x> <?from>**: Allows moving a block ?x from on top of another block ?from back to the table.",
        "pddl_domain_processed": "\n\n(define (domain BLOCKS)\n  (:requirements :strips)\n  (:predicates (on ?x ?y)\n\t       (ontable ?x)\n\t       (clear ?x)\n\t       )\n\n  (:action move-to-block\n\t     :parameters (?x ?to)\n\t     :precondition (and (clear ?x) (ontable ?x) (clear ?to))\n\t     :effect\n\t     (and \n\t\t      (on ?x ?to)\n\t          (not (ontable ?x))\n\t\t      (not (clear ?to))\n\n\t\t )\n  )\n\n (:action move-to-table\n\t     :parameters (?x ?from)\n\t     :precondition (and (clear ?x) (on ?x ?from) )\n\t     :effect\n\t     (and (not (on ?x ?from))\n\t\t      (clear ?from)\n\t\t      (ontable ?x)\n\t\t )\n  )\n)"
    },
    {
        "file_name": "Kooroshoo_Solving-the-n-puzzle-board-game_Domain.pddl",
        "pddl_domain": "(define (domain n-puzzle)\n  (:requirements :strips)\n  (:predicates\n    (tile ?x)\n    (position ?x)\n    (at ?t ?x)\n    (blank ?x)\n    (valid-up ?p1 ?p2)\n    (valid-down ?p1 ?p2)\n    (valid-left ?p1 ?p2)\n    (valid-right ?p1 ?p2))\n\n  (:action move-up\n    :parameters (?t ?p1 ?p2)\n    :precondition (and \n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-up ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-down\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-down ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-left\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-left ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-right\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-right ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1))))",
        "batch_id": 3,
        "id": 166,
        "tokens": 5471,
        "corrected_description": "### General\nThis domain is designed for solving the n-puzzle problem, where the goal is to rearrange tiles on a board to achieve a specific configuration. The puzzle consists of tiles numbered from 1 to n-1 and a blank space that allows the tiles to be moved. The actions defined allow the tiles to be moved up, down, left, or right, simulating the sliding of tiles on the puzzle board.\n\n### Predicates\n- **(tile ?x)**: Indicates that ?x is a tile in the puzzle.\n- **(position ?x)**: Indicates that ?x is a position on the puzzle board.\n- **(at ?t ?x):** Indicates that tile ?t is at position ?x.\n- **(blank ?x)**: Indicates that position ?x is the blank space on the puzzle board.\n- **(valid-up ?p1 ?p2)**: Indicates that it is valid to move a tile from position ?p1 to position ?p2 by moving it up.\n- **(valid-down ?p1 ?p2)**: Indicates that it is valid to move a tile from position ?p1 to position ?p2 by moving it down.\n- **(valid-left ?p1 ?p2)**: Indicates that it is valid to move a tile from position ?p1 to position ?p2 by moving it left.\n- **(valid-right ?p1 ?p2)**: Indicates that it is valid to move a tile from position ?p1 to position ?p2 by moving it right.\n\n### Actions\n- **move-up <?t> <?p1> <?p2>**: Allows a tile to be moved up into the blank space.  \n\n- **move-down <?t> <?p1> <?p2>**: Allows a tile to be moved down into the blank space.  \n\n- **move-left <?t> <?p1> <?p2>**: Allows a tile to be moved left into the blank space.  \n\n- **move-right <?t> <?p1> <?p2>**: Allows a tile to be moved right into the blank space.",
        "pddl_domain_processed": "(define (domain n-puzzle)\n  (:requirements :strips)\n  (:predicates\n    (tile ?x)\n    (position ?x)\n    (at ?t ?x)\n    (blank ?x)\n    (valid-up ?p1 ?p2)\n    (valid-down ?p1 ?p2)\n    (valid-left ?p1 ?p2)\n    (valid-right ?p1 ?p2))\n\n  (:action move-up\n    :parameters (?t ?p1 ?p2)\n    :precondition (and \n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-up ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-down\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-down ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-left\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-left ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1)))\n\n  (:action move-right\n    :parameters (?t ?p1 ?p2)\n    :precondition (and\n      (tile ?t)\n      (position ?p1)\n      (position ?p2)\n      (at ?t ?p1)\n      (blank ?p2)\n      (valid-right ?p1 ?p2))\n    :effect (and\n      (not (at ?t ?p1))\n      (not (blank ?p2))\n      (at ?t ?p2)\n      (blank ?p1))))"
    },
    {
        "file_name": "martilad_MI-UMI2018_monkeyDomain.pddl",
        "pddl_domain": "(define (domain monkey)\n   (:requirements :adl)\n   (:constants monkey box bananas)\n   (:predicates  (goto ?x ?y) \n                 (climp ?x)\n                 (push-box ?x ?y)\n                 (grab-bananas ?y)\n                 (on-floor)\n                 (at ?x ?y)\n                 (hasbananas)\n                 (onbox ?x))\n\n   (:action goto\n             :parameters (?x ?y)\n             :precondition (and (on-floor)\n                                (at monkey ?y))\n             :effect  (and (at monkey ?x)\n                           (not (at monkey ?y)))) \n\n   (:action climp\n             :parameters (?x)\n             :precondition (and (at box ?x)\n                             (at monkey ?x)\n                             (on-floor))\n             :effect  (and (onbox ?x)\n                           (not (on-floor)))) \n\n   (:action push-box\n             :parameters (?x ?y)\n             :precondition (and (at box ?y)\n                                (at monkey ?y)\n                                (on-floor))\n             :effect  (and (at monkey ?x)\n                           (at box ?x)\n                           (not (at monkey ?y))\n                           (not (at box ?y)))) \n\n   (:action grab-bananas\n             :parameters (?y)\n             :precondition (and (at bananas ?y)\n                                (onbox ?y))\n             :effect  (and (hasbananas))) \n)\n",
        "batch_id": 3,
        "id": 167,
        "tokens": 5290,
        "corrected_description": "### General\nThis domain models a scenario where a monkey can move around, climb on a box, push the box, and grab bananas. The goal is typically to figure out how the monkey can get the bananas by utilizing the box.\n\n### Predicates\n- **(goto ?x ?y)**: Represents the action of going from location ?y to location ?x.\n- **(climp ?x)**: Indicates that the monkey is climbing at location ?x.\n- **(push-box ?x ?y)**: Represents the action of pushing the box from location ?y to location ?x.\n- **(grab-bananas ?y)**: Indicates the action of grabbing bananas at location ?y.\n- **(on-floor)**: Indicates that the monkey is on the floor.\n- **(at ?x ?y)**: Indicates that object ?x is at location ?y.\n- **(hasbananas)**: Indicates that the monkey has bananas.\n- **(onbox ?x)**: Indicates that the monkey is on the box at location ?x.\n\n### Actions\n- **goto <?x> <?y>**: Allows the monkey to go from one location to another.  \n\n- **climp <?x>**: Allows the monkey to climb on the box.  \n\n- **push-box <?x> <?y>**: Allows the monkey to push the box from one location to another.  \n\n- **grab-bananas <?y>**: Allows the monkey to grab the bananas.",
        "pddl_domain_processed": "(define (domain monkey)\n   (:requirements :adl)\n   (:constants monkey box bananas)\n   (:predicates  (goto ?x ?y) \n                 (climp ?x)\n                 (push-box ?x ?y)\n                 (grab-bananas ?y)\n                 (on-floor)\n                 (at ?x ?y)\n                 (hasbananas)\n                 (onbox ?x))\n\n   (:action goto\n             :parameters (?x ?y)\n             :precondition (and (on-floor)\n                                (at monkey ?y))\n             :effect  (and (at monkey ?x)\n                           (not (at monkey ?y)))) \n\n   (:action climp\n             :parameters (?x)\n             :precondition (and (at box ?x)\n                             (at monkey ?x)\n                             (on-floor))\n             :effect  (and (onbox ?x)\n                           (not (on-floor)))) \n\n   (:action push-box\n             :parameters (?x ?y)\n             :precondition (and (at box ?y)\n                                (at monkey ?y)\n                                (on-floor))\n             :effect  (and (at monkey ?x)\n                           (at box ?x)\n                           (not (at monkey ?y))\n                           (not (at box ?y)))) \n\n   (:action grab-bananas\n             :parameters (?y)\n             :precondition (and (at bananas ?y)\n                                (onbox ?y))\n             :effect  (and (hasbananas))) \n)\n"
    },
    {
        "file_name": "hwhang0917_AI-fall2019_robotdomain.pddl",
        "pddl_domain": "(define (domain robotDomain)\n\n(:requirements :strips :equality :negative-preconditions)\n\n(:predicates \n            ; General predicate\n            (isRoom ?x) ; x is a room\n            (isObject ?x) ;x is an object\n            (isRobot ?x) ;x is a robot\n\n            ; Robot related\n            (clear ?x) ;x robot is free to hold an object\n            (holding ?x) ;robot is holding object x\n            (bot-at ?x) ;robot is at room x\n\n            ; Object location\n            (obj-at ?x ?y) ;object x is at room y\n\n            ; Room accessibility / conditon\n            (can-go ?x ?y) ;can move from room x to room y\n            (has-obj ?x) ;room X has an object\n)\n\n(:action move-without-object\n    :parameters (?start ?dest ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?start) (isRoom ?dest) (isRobot ?robot)\n                \n                ; robot spec\n                (bot-at ?start) ; robot is in start room\n                (clear ?robot) ; robot is free\n\n                ; Room accessibility\n                (not (= ?start ?dest)) ;  room start != room dest\n                (can-go ?start ?dest) ; can go from start to dest\n    )\n    :effect (and    \n                ; Move robot from start room to dest room\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action move-with-object\n    :parameters (?start ?dest ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?start) (isRoom ?dest) (isObject ?object) (isRobot ?robot)\n                \n                ; Object location\n                (not (obj-at ?object ?start)) (not (obj-at ?object ?dest)) ; There are no objects in either room start or end\n                (holding ?object)\n                (not (has-obj ?dest))\n\n                ; robot spec\n                (bot-at ?start) ; robot is in start room\n                (not (clear ?robot)) ; robot is not free\n\n                ; Room accessibility\n                (not (= ?start ?dest)) ;  room start != room dest\n                (can-go ?start ?dest) ; can go from start to dest\n\n    )\n    :effect (and \n                ; Move robot from start room to dest room\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action pickup\n    :parameters (?room ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                ; Object location\n                (obj-at ?object ?room) ; object is at the room\n                (has-obj ?room) ; room has an object\n\n                ; robot spec\n                (bot-at ?room) ; robot is in the room\n                (clear ?robot) ; robot is free \n                (not (holding ?object)) ; robot is NOT holding an object\n    )\n    :effect (and \n                ; Pick up object\n                (not (obj-at ?object ?room)) ; remove object from room\n                (not (has-obj ?room)) ; room no longer has object\n                (not (clear ?robot)) ; robot is no longer free\n                (holding ?object) ; robot is holding the object\n    )\n)\n\n(:action release\n    :parameters (?room ?object ?robot)\n    :precondition (and \n                ; Check variables\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                ; Object location\n                (not (obj-at ?object ?room)) ; object is NOT at the room\n                (not (has-obj ?room)) ; room does not have object\n\n                ; robot spec\n                (bot-at ?room) ; robot is in the room\n                (not (clear ?robot)) ; robot is NOT free \n                (holding ?object) ; robot is holding an object\n    )\n    :effect (and \n                ; Release object\n                (obj-at ?object ?room) ; put object in room\n                (has-obj ?room) ; room now have an object\n                (clear ?robot) ; robot is free\n                (not (holding ?object)) ; robot is no longer holding the object\n    )\n)\n\n\n)",
        "batch_id": 3,
        "id": 168,
        "tokens": 5915,
        "corrected_description": "### General\nThis domain describes a robotic agent capable of moving between rooms, picking up objects, and releasing them. The robot can navigate a space with multiple rooms, each potentially containing objects. The robot's tasks involve object manipulation and transportation, requiring careful planning to ensure it picks up and releases objects appropriately while navigating the interconnected rooms.\n\n### Predicates\n- **(isRoom ?x)**: Checks if ?x is a room.\n- **(isObject ?x)**: Checks if ?x is an object.\n- **(isRobot ?x)**: Checks if ?x is a robot.\n- **(clear ?x)**: Indicates that the robot is free to hold an object.\n- **(holding ?x)**: Indicates that the robot is holding object ?x.\n- **(bot-at ?x)**: Indicates that the robot is at room ?x.\n- **(obj-at ?x ?y)**: Indicates that object ?x is at room ?y.\n- **(can-go ?x ?y)**: Indicates that it is possible to move from room ?x to room ?y.\n- **(has-obj ?x)**: Indicates that room ?x contains an object.\n\n### Actions\n- **move-without-object <?start> <?dest> <?robot>**: Allows the robot to move from one room to another without carrying an object.  \n\n- **move-with-object <?start> <?dest> <?object> <?robot>**: Allows the robot to move from one room to another while carrying an object.  \n\n- **pickup <?room> <?object> <?robot>**: Allows the robot to pick up an object from a room.  \n\n- **release <?room> <?object> <?robot>**: Allows the robot to release an object into a room.",
        "pddl_domain_processed": "(define (domain robotDomain)\n\n(:requirements :strips :equality :negative-preconditions)\n\n(:predicates \n\n            (isRoom ?x) \n            (isObject ?x) \n            (isRobot ?x) \n\n            (clear ?x) \n            (holding ?x) \n            (bot-at ?x) \n\n            (obj-at ?x ?y) \n\n            (can-go ?x ?y) \n            (has-obj ?x) \n)\n\n(:action move-without-object\n    :parameters (?start ?dest ?robot)\n    :precondition (and \n\n                (isRoom ?start) (isRoom ?dest) (isRobot ?robot)\n\n                (bot-at ?start) \n                (clear ?robot) \n\n                (not (= ?start ?dest)) \n                (can-go ?start ?dest) \n    )\n    :effect (and    \n\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action move-with-object\n    :parameters (?start ?dest ?object ?robot)\n    :precondition (and \n\n                (isRoom ?start) (isRoom ?dest) (isObject ?object) (isRobot ?robot)\n\n                (not (obj-at ?object ?start)) (not (obj-at ?object ?dest)) \n                (holding ?object)\n                (not (has-obj ?dest))\n\n                (bot-at ?start) \n                (not (clear ?robot)) \n\n                (not (= ?start ?dest)) \n                (can-go ?start ?dest) \n\n    )\n    :effect (and \n\n                (bot-at ?dest)\n                (not (bot-at ?start))\n    )\n)\n\n(:action pickup\n    :parameters (?room ?object ?robot)\n    :precondition (and \n\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                (obj-at ?object ?room) \n                (has-obj ?room) \n\n                (bot-at ?room) \n                (clear ?robot) \n                (not (holding ?object)) \n    )\n    :effect (and \n\n                (not (obj-at ?object ?room)) \n                (not (has-obj ?room)) \n                (not (clear ?robot)) \n                (holding ?object) \n    )\n)\n\n(:action release\n    :parameters (?room ?object ?robot)\n    :precondition (and \n\n                (isRoom ?room) (isObject ?object) (isRobot ?robot)\n\n                (not (obj-at ?object ?room)) \n                (not (has-obj ?room)) \n\n                (bot-at ?room) \n                (not (clear ?robot)) \n                (holding ?object) \n    )\n    :effect (and \n\n                (obj-at ?object ?room) \n                (has-obj ?room) \n                (clear ?robot) \n                (not (holding ?object)) \n    )\n)\n\n)"
    },
    {
        "file_name": "tmigimatsu_logic-opt_hanoi_domain.pddl",
        "pddl_domain": "(define (domain hanoi)\n\t(:requirements :strips :typing :equality :negative-preconditions :conditional-effects)\n\t(:types\n\t\tphysobj - object\n\t\tmovable - physobj\n\t)\n\t(:constants\n\t\tplatform_left - physobj\n\t\tplatform_middle - physobj\n\t\tplatform_right - physobj\n\t)\n\t(:predicates\n\t\t(inhand ?a - movable)\n\t\t(on ?a - movable ?b - physobj)\n\t\t(smaller ?a - physobj ?b - physobj)\n\t)\n\t(:action pick\n\t\t:parameters (?a - movable)\n\t\t:precondition (forall\n\t\t\t(?b - movable)\n\t\t\t(and\n\t\t\t\t(not (inhand ?b))\n\t\t\t\t(not (on ?b ?a))\n\t\t\t)\n\t\t)\n\t\t:effect (and\n\t\t\t(inhand ?a)\n\t\t\t(forall (?b - physobj) (not (on ?a ?b)))\n\t\t)\n\t)\n\t(:action place\n\t\t:parameters (?a - movable ?b - physobj)\n\t\t:precondition (and\n\t\t\t(inhand ?a)\n\t\t\t(smaller ?a ?b)\n\t\t\t(forall (?c - movable) (not (on ?c ?b)))\n\t\t)\n\t\t:effect (and\n\t\t\t(not (inhand ?a))\n\t\t\t(on ?a ?b)\n\t\t)\n\t)\n)\n",
        "batch_id": 3,
        "id": 170,
        "tokens": 5246,
        "corrected_description": "### General\nThis domain models the classic Tower of Hanoi puzzle, where the objective is to move a set of disks of different sizes from one platform to another, following certain rules. The puzzle includes three platforms and a set of movable disks. The primary rule is that only one disk can be moved at a time, and it can only be placed on top of a larger disk or on an empty platform.\n\n### Types\n- **physobj**: The base type for all physical objects in the domain.\n- **movable**: A subtype of **physobj**, representing objects that can be moved (i.e., the disks in the Tower of Hanoi puzzle).\n\n### Constants\n- **platform_left**: Represents the left platform in the Tower of Hanoi puzzle, which is a physical object.\n- **platform_middle**: Represents the middle platform in the Tower of Hanoi puzzle, which is a physical object.\n- **platform_right**: Represents the right platform in the Tower of Hanoi puzzle, which is a physical object.\n\n### Predicates\n- **(inhand ?a - movable)**: Indicates that disk ?a is currently being held and not on any platform or disk.\n- **(on ?a - movable ?b - physobj)**: Indicates that disk ?a is on top of object ?b, where ?b can be either a platform or another disk.\n- **(smaller ?a ?b - physobj)**: Indicates that object ?a is smaller than object ?b. This predicate is used to enforce the rule that a disk can only be placed on top of a larger disk or on an empty platform.\n\n### Actions\n- **pick <?a>**: Allows picking up a disk ?a.  \n\n\n- **place <?a> <?b>**: Allows placing a disk ?a on top of object ?b.",
        "pddl_domain_processed": "(define (domain hanoi)\n\t(:requirements :strips :typing :equality :negative-preconditions :conditional-effects)\n\t(:types\n\t\tphysobj - object\n\t\tmovable - physobj\n\t)\n\t(:constants\n\t\tplatform_left - physobj\n\t\tplatform_middle - physobj\n\t\tplatform_right - physobj\n\t)\n\t(:predicates\n\t\t(inhand ?a - movable)\n\t\t(on ?a - movable ?b - physobj)\n\t\t(smaller ?a - physobj ?b - physobj)\n\t)\n\t(:action pick\n\t\t:parameters (?a - movable)\n\t\t:precondition (forall\n\t\t\t(?b - movable)\n\t\t\t(and\n\t\t\t\t(not (inhand ?b))\n\t\t\t\t(not (on ?b ?a))\n\t\t\t)\n\t\t)\n\t\t:effect (and\n\t\t\t(inhand ?a)\n\t\t\t(forall (?b - physobj) (not (on ?a ?b)))\n\t\t)\n\t)\n\t(:action place\n\t\t:parameters (?a - movable ?b - physobj)\n\t\t:precondition (and\n\t\t\t(inhand ?a)\n\t\t\t(smaller ?a ?b)\n\t\t\t(forall (?c - movable) (not (on ?c ?b)))\n\t\t)\n\t\t:effect (and\n\t\t\t(not (inhand ?a))\n\t\t\t(on ?a ?b)\n\t\t)\n\t)\n)\n"
    },
    {
        "file_name": "HeavenMin_DeepPac_ghostDomain.pddl",
        "pddl_domain": "(define (domain ghostDomain)\n  (:requirements :strips :typing :conditional-effects)\n  (:types position)\n  (:predicates  (location ?curPos - position)\n                (adjacent ?curPos ?nextPos - position)\n                (scareExist)\n                (pacmanLoc ?curPos - position)\n\n  )\n  (:action moveWhenScareNotExist\n        :parameters (?curPos ?nextPos - position)\n        :precondition (and (not (scareExist))\n                           (location ?curPos)\n                           (adjacent ?curPos ?nextPos)\n                           \n                       )\n        :effect   (and (not (location ?curPos))\n                       (location ?nextPos)\n                       (when (pacmanLoc ?nextPos)\n                             (not (pacmanLoc ?nextPos)))\n                  )\n  )\n\n  (:action moveWhenScare\n        :parameters (?curPos ?nextPos ?pacmanPos - position)\n        :precondition (and (scareExist)\n                           (location ?curPos)\n                           (pacmanLoc ?pacmanPos)\n                           (adjacent ?curPos ?nextPos)\n                           (not (adjacent ?nextPos ?pacmanPos))\n                           (not (pacmanLoc ?nextPos))\n\n                           \n                       )\n        :effect   (and (not (scareExist))\n                       (location ?nextPos)\n                       (not (location ?curPos))                     \n                   )\n  )\n\n  \n)",
        "batch_id": 3,
        "id": 172,
        "tokens": 5253,
        "corrected_description": "### General\nThis domain models the behavior of ghosts in a simplified version of the Pac-Man game. Ghosts can move between different positions on the map. Their movement is influenced by the presence of Pac-Man and whether a scare state exists. Ghosts aim to avoid Pac-Man's location when scared.\n\n### Types\n- **position**: Represents the various locations or positions that ghosts and Pac-Man can occupy on the game map.\n\n### Predicates\n- **(location ?curPos - position)**: Indicates that a ghost is currently at position ?curPos.\n- **(adjacent ?curPos ?nextPos - position)**: Indicates that position ?curPos is adjacent to position ?nextPos, allowing movement between these positions.\n- **(scareExist)**: Indicates that a scare state exists, affecting ghost behavior.\n- **(pacmanLoc ?curPos - position)**: Indicates that Pac-Man is currently at position ?curPos.\n\n### Actions\n- **moveWhenScareNotExist <?curPos> <?nextPos>**: Allows a ghost to move from its current position to an adjacent position when there is no scare state.  \n\n- **moveWhenScare <?curPos> <?nextPos> <?pacmanPos>**: Allows a ghost to move from its current position to an adjacent position when a scare state exists, avoiding positions adjacent to Pac-Man.   \n\nThis domain captures the basic logic for ghost movement in response to the game's dynamics, specifically focusing on how ghosts react to the presence of Pac-Man and the scare state.",
        "pddl_domain_processed": "(define (domain ghostDomain)\n  (:requirements :strips :typing :conditional-effects)\n  (:types position)\n  (:predicates  (location ?curPos - position)\n                (adjacent ?curPos ?nextPos - position)\n                (scareExist)\n                (pacmanLoc ?curPos - position)\n\n  )\n  (:action moveWhenScareNotExist\n        :parameters (?curPos ?nextPos - position)\n        :precondition (and (not (scareExist))\n                           (location ?curPos)\n                           (adjacent ?curPos ?nextPos)\n\n                       )\n        :effect   (and (not (location ?curPos))\n                       (location ?nextPos)\n                       (when (pacmanLoc ?nextPos)\n                             (not (pacmanLoc ?nextPos)))\n                  )\n  )\n\n  (:action moveWhenScare\n        :parameters (?curPos ?nextPos ?pacmanPos - position)\n        :precondition (and (scareExist)\n                           (location ?curPos)\n                           (pacmanLoc ?pacmanPos)\n                           (adjacent ?curPos ?nextPos)\n                           (not (adjacent ?nextPos ?pacmanPos))\n                           (not (pacmanLoc ?nextPos))\n\n                       )\n        :effect   (and (not (scareExist))\n                       (location ?nextPos)\n                       (not (location ?curPos))                     \n                   )\n  )\n\n)"
    },
    {
        "file_name": "adubredu_digit_ws_domain.pddl",
        "pddl_domain": "(define (domain GROCERY)\n    (:requirements :strips :typing :adl)\n    (:types item)\n    (:predicates (on ?x - item ?y - item)\n                 (inbox ?x - item)\n                 (inclutter ?x - item)\n                 (beside ?x - item ?y - item)\n                 (handempty)\n                 (holding ?x - item)\n                 (topfree ?x - item)\n                 (boxfull)\n                 )\n                 \n    \n    (:action pick-from-clutter\n            :parameters (?x - item)\n            :precondition (and (topfree ?x) (handempty) (inclutter ?x))\n            :effect\n            (and (holding ?x)\n                (not (handempty))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x)))\n    )\n    \n    (:action pick-from-box\n            :parameters (?x - item)\n            :precondition (and (topfree ?x) (handempty) (inbox ?x))\n            :effect\n            (and (holding ?x)\n                (not (boxfull))\n                (not (handempty))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x)))\n    )\n    \n    (:action pick-from\n            :parameters (?x - item ?y - item)\n            :precondition (and (on ?x ?y) (topfree ?x) (handempty))\n            :effect\n            (and (holding ?x)\n                (not (handempty))\n                (not (on ?x ?y))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x))\n                (topfree ?y))\n    )\n    \n    (:action put-in-clutter\n            :parameters (?x - item)\n            :precondition (holding ?x)\n            :effect\n            (and (not (holding ?x))\n                (handempty)\n                (inclutter ?x)\n                (topfree ?x))\n    )\n    \n    (:action put-in-box\n            :parameters (?x - item)\n            :precondition  (and (holding ?x) (not (boxfull)))\n            :effect\n            (and (not (holding ?x))\n                (handempty)\n                (inbox ?x)\n                (topfree ?x))\n    )\n    \n    (:action put-on \n            :parameters (?x - item ?y - item)\n            :precondition (and (holding ?x) (topfree ?y) )\n            :effect\n            (and (not (holding ?x))\n                (on ?x ?y)\n                (handempty)\n                (topfree ?x)\n                (not (topfree ?y)))\n    )\n)",
        "batch_id": 3,
        "id": 174,
        "tokens": 5697,
        "corrected_description": "### General\nThis domain is designed for simulating a grocery organizing scenario. It involves various items that can be in different states: in a box, in clutter, or stacked on top of each other. The robot can pick items from these locations or put them into a box, clutter, or on top of another item. The goal is to organize items according to specific criteria, such as putting all items in a box or arranging them in a certain order.\n\n### Types\n- **item**: Represents the grocery items that need to be organized.\n\n### Predicates\n- **(on ?x - item ?y - item)**: Indicates that item ?x is on top of item ?y.\n- **(inbox ?x - item)**: Indicates that item ?x is inside a box.\n- **(inclutter ?x - item)**: Indicates that item ?x is in a cluttered area.\n- **(beside ?x - item ?y - item)**: Indicates that item ?x is beside item ?y.\n- **(handempty)**: Indicates that the robot's hand is empty.\n- **(holding ?x - item)**: Indicates that the robot's hand is holding item ?x.\n- **(topfree ?x - item)**: Indicates that the top of item ?x is free, meaning no other item is on top of it.\n- **(boxfull)**: Indicates that the box is full and cannot hold any more items.\n\n### Actions\n- **pick-from-clutter <?x>**: Allows the robot to pick an item from the clutter.  \n  \n- **pick-from-box <?x>**: Allows the robot to pick an item from the box.  \n  \n- **pick-from <?x> <?y>**: Allows the robot to pick an item ?x from on top of another item ?y.  \n  \n- **put-in-clutter <?x>**: Allows the robot to put an item into the clutter.  \n  \n- **put-in-box <?x>**: Allows the robot to put an item into the box.  \n  \n- **put-on <?x> <?y>**: Allows the robot to put an item ?x on top of another item ?y.",
        "pddl_domain_processed": "(define (domain GROCERY)\n    (:requirements :strips :typing :adl)\n    (:types item)\n    (:predicates (on ?x - item ?y - item)\n                 (inbox ?x - item)\n                 (inclutter ?x - item)\n                 (beside ?x - item ?y - item)\n                 (handempty)\n                 (holding ?x - item)\n                 (topfree ?x - item)\n                 (boxfull)\n                 )\n\n    (:action pick-from-clutter\n            :parameters (?x - item)\n            :precondition (and (topfree ?x) (handempty) (inclutter ?x))\n            :effect\n            (and (holding ?x)\n                (not (handempty))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x)))\n    )\n\n    (:action pick-from-box\n            :parameters (?x - item)\n            :precondition (and (topfree ?x) (handempty) (inbox ?x))\n            :effect\n            (and (holding ?x)\n                (not (boxfull))\n                (not (handempty))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x)))\n    )\n\n    (:action pick-from\n            :parameters (?x - item ?y - item)\n            :precondition (and (on ?x ?y) (topfree ?x) (handempty))\n            :effect\n            (and (holding ?x)\n                (not (handempty))\n                (not (on ?x ?y))\n                (not (inbox ?x))\n                (not (inclutter ?x))\n                (not (topfree ?x))\n                (topfree ?y))\n    )\n\n    (:action put-in-clutter\n            :parameters (?x - item)\n            :precondition (holding ?x)\n            :effect\n            (and (not (holding ?x))\n                (handempty)\n                (inclutter ?x)\n                (topfree ?x))\n    )\n\n    (:action put-in-box\n            :parameters (?x - item)\n            :precondition  (and (holding ?x) (not (boxfull)))\n            :effect\n            (and (not (holding ?x))\n                (handempty)\n                (inbox ?x)\n                (topfree ?x))\n    )\n\n    (:action put-on \n            :parameters (?x - item ?y - item)\n            :precondition (and (holding ?x) (topfree ?y) )\n            :effect\n            (and (not (holding ?x))\n                (on ?x ?y)\n                (handempty)\n                (topfree ?x)\n                (not (topfree ?y)))\n    )\n)"
    },
    {
        "file_name": "planimation_documentation_edgy_domain.pddl",
        "pddl_domain": "; Title: FlowFree Domain for Edgy Strategy (made compatible with Fast Downward planners)\n; Author: Aditi Basu (University of Melbourne)\n\n(define (domain FlowFree)\n    (:requirements :strips :typing :action-costs :conditional-effects)\n\n    (:types\n        dot node\n    )\n\n    (:predicates\n        ; pre-strategy domain predicates\n        (head ?n - node ?d - dot)\n        (selected ?d - dot)\n        (finished ?d - dot)\n        (adjacent ?n - node ?n - node)\n        (filled ?n - node ?d - dot)\n\n        ; Planimation predicates\n        (position ?n - node)\n        \n        ; Edgy strategy predicates\n        (nextToEdge ?n - node)               ; is a node next to an edge?\n        (currentPath ?n - node)        ; is a node part of the current path being formed?\n\n        ; Fast-Downward predicates\n        (pipe ?n - node)                  ; does a node contain a pipe?\n\n    )\n\n    ; cost function\n    (:functions\n        (total-cost) - number\n    )\n\n    ; move selection from d1 to d2 based on cost\n    (:action select-colour\n        :parameters     (?d1 - dot\n                         ?d2 - dot)\n\n        :precondition   (and \n                            (selected ?d1)\n                            (not (selected ?d2))\n                            (not (finished ?d2))\n                        )\n\n        :effect         (and \n                            (selected ?d2)\n                            (not (selected ?d1))\n                            (finished ?d1)              \n\t\t\t\t            \n                            (increase (total-cost) 1)\n                        )\n    )\n    \n    ; move from n1 to n2 where n2 is NOT nextToEdge\n    (:action move\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (not (nextToEdge ?n2))\n                        )\n                        \n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n                             \n                            ; increment cost as ?n2 is not nextToEdge\n                            (increase (total-cost) 1)\n                        )\n    )\n    \n     ; move from n1 to n2 where n2 is nextToEdge\n    (:action moveNextToEdge\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (nextToEdge ?n2)\n                        )\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n                            \n                            ; no cost increase as ?n2 is nextToEdge\n                            (increase (total-cost) 0)\n                        )\n    )\n\n    ; finish a path by connecting to second dot \n    (:action finishPath\n        :parameters     (?n1 - node\n                         ?n2 - node\n                         ?d - dot)\n\n        :precondition   (and\n                            (filled ?n2 ?d) \n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                        ) \n\n        :effect         (and \n                            (head ?n2 ?d)\n                            \n                            ; convert nodes adjacent to currentPath nodes to nextToEdge\n                            (forall (?cp - node ?n - node) \n                                (when \n                                    (and (currentPath ?cp) (adjacent ?cp ?n))\n                                    (nextToEdge ?n)    \n                                )\n                            )\n\n                            ; reset all currentPath predicates to false \n                            (forall (?x - node)\n                                (when \n                                    (currentPath ?x) \n                                    (not (currentPath ?x))\n                                )\n                            )\n\n                            ; no cost increase as all dots will need to execute this action regardless of initial state\n                            (increase (total-cost) 0)\n                        )\n    )\n)\n",
        "batch_id": 3,
        "id": 175,
        "tokens": 6025,
        "corrected_description": "### General\nThis domain is designed for the FlowFree game, where the objective is to connect pairs of dots of the same color with a path that fills the entire board. The domain includes actions for selecting colors, moving between nodes, and finishing paths. It incorporates strategies for efficient path completion, including a focus on moving next to edges and completing paths efficiently. The domain supports action costs and conditional effects to model the complexity of the game's strategy.\n\n### Types\n- **dot**: Represents the colored dots that need to be connected.\n- **node**: Represents the cells or positions on the game board.\n\n### Predicates\n- **(head ?n - node ?d - dot)**: Indicates that node ?n is the current endpoint of the path for dot ?d.\n- **(selected ?d - dot)**: Indicates that dot ?d has been selected for path extension.\n- **(finished ?d - dot)**: Indicates that a complete path has been formed for dot ?d.\n- **(adjacent ?n1 - node ?n2 - node)**: Indicates that node ?n1 is adjacent to node ?n2.\n- **(filled ?n - node ?d - dot)**: Indicates that node ?n has been filled with the path for dot ?d.\n- **(position ?n - node)**: Used for visualizing the position of a node.\n- **(nextToEdge ?n - node)**: Indicates that node ?n is adjacent to the edge of the board.\n- **(currentPath ?n - node)**: Indicates that node ?n is part of the current path being formed.\n- **(pipe ?n - node)**: Indicates that node ?n contains a part of the path (like a pipe).\n\n### Functions\n- **total-cost**: Represents the total cost accumulated during the plan, which is a numerical value.\n\n### Actions\n- **select-colour <?d1> <?d2>**: Selects a new dot ?d2 to continue the path from dot ?d1, marking ?d1 as finished and incrementing the total cost by 1.  \n  \n- **move <?n1> <?n2> <?d>**: Moves the path from node ?n1 to an adjacent node ?n2 that is not next to an edge, for the selected dot ?d. This action increases the total cost by 1.  \n  \n- **moveNextToEdge <?n1> <?n2> <?d>**: Moves the path from node ?n1 to an adjacent node ?n2 that is next to an edge, for the selected dot ?d. This action does not increase the total cost.  \n  \n- **finishPath <?n1> <?n2> <?d>**: Completes the path for dot ?d by connecting node ?n1 to the second dot located at node ?n2. This action converts nodes adjacent to the current path into edge nodes and resets the current path markers without increasing the total cost.",
        "pddl_domain_processed": "\n\n(define (domain FlowFree)\n    (:requirements :strips :typing :action-costs :conditional-effects)\n\n    (:types\n        dot node\n    )\n\n    (:predicates\n\n        (head ?n - node ?d - dot)\n        (selected ?d - dot)\n        (finished ?d - dot)\n        (adjacent ?n - node ?n - node)\n        (filled ?n - node ?d - dot)\n\n        (position ?n - node)\n\n        (nextToEdge ?n - node)               \n        (currentPath ?n - node)        \n\n        (pipe ?n - node)                  \n\n    )\n\n    (:functions\n        (total-cost) - number\n    )\n\n    (:action select-colour\n        :parameters     (?d1 - dot\n                         ?d2 - dot)\n\n        :precondition   (and \n                            (selected ?d1)\n                            (not (selected ?d2))\n                            (not (finished ?d2))\n                        )\n\n        :effect         (and \n                            (selected ?d2)\n                            (not (selected ?d1))\n                            (finished ?d1)              \n\n                            (increase (total-cost) 1)\n                        )\n    )\n\n    (:action move\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (not (nextToEdge ?n2))\n                        )\n\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n\n                            (increase (total-cost) 1)\n                        )\n    )\n\n    (:action moveNextToEdge\n        :parameters     (?n1 - node \n                         ?n2 - node \n                         ?d - dot)\n\n        :precondition   (and \n                            (not (pipe ?n2))\n                            (not (filled ?n2 ?d))\n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                            (nextToEdge ?n2)\n                        )\n        :effect         (and \n                            (head ?n2 ?d)\n                            (pipe ?n2)\n                            (currentPath ?n2)\n\n                            (increase (total-cost) 0)\n                        )\n    )\n\n    (:action finishPath\n        :parameters     (?n1 - node\n                         ?n2 - node\n                         ?d - dot)\n\n        :precondition   (and\n                            (filled ?n2 ?d) \n                            (selected ?d)\n                            (head ?n1 ?d)\n                            (not (head ?n2 ?d))\n                            (adjacent ?n1 ?n2)\n                        ) \n\n        :effect         (and \n                            (head ?n2 ?d)\n\n                            (forall (?cp - node ?n - node) \n                                (when \n                                    (and (currentPath ?cp) (adjacent ?cp ?n))\n                                    (nextToEdge ?n)    \n                                )\n                            )\n\n                            (forall (?x - node)\n                                (when \n                                    (currentPath ?x) \n                                    (not (currentPath ?x))\n                                )\n                            )\n\n                            (increase (total-cost) 0)\n                        )\n    )\n)\n"
    },
    {
        "file_name": "James-Oswald_Flow-Free-PDDL_flowdomain.pddl",
        "pddl_domain": "(define (domain flow_free)\n\n(:requirements :strips :typing)\n\n(:types\n    color\n    location\n)\n\n(:predicates\n    \n    (offboard)\n    \n    (empty ?l - location)\n    (not-empty ?l - location)\n    \n    (color-at ?l - location ?c - color )\n    \n    (adjacent ?l1 - location ?l2 - location)\n    \n    (flow-end ?l - location ?c - color)\n    \n    (flow-at ?l1 - location ?c - color)\n    \n    (flow-complete ?c - color)\n\n)\n\n\n(:action move\n    :parameters (?l1  ?l2 - location ?c - color)\n    :precondition (and (flow-at ?l1 ?c) (empty ?l2) (adjacent ?l1 ?l2)) \n    :effect (and (not (flow-at ?l1 ?c)) (not (empty ?l2)) (flow-at ?l2 ?c) (not-empty ?l2) (color-at ?l2 ?c))\n)\n\n\n(:action start\n    :parameters (?l - location ?c - color)\n    :precondition (and (offboard) (empty ?l) (flow-end ?l ?c) (not (flow-complete ?c))) \n    :effect (and (not (offboard)) (not (empty ?l)) (not-empty ?l) (flow-at ?l ?c) (color-at ?l ?c))\n)\n\n\n(:action finish\n    :parameters (?l1  ?l2 - location ?c - color)\n    :precondition (and (flow-at ?l1 ?c) (empty ?l2) (flow-end ?l2 ?c) (adjacent ?l1 ?l2)) \n    :effect (and (not (flow-at ?l1 ?c)) (not (empty ?l2)) (not-empty ?l2) (offboard) (color-at ?l2 ?c) (flow-complete ?c))\n)\n\n)\n",
        "batch_id": 3,
        "id": 176,
        "tokens": 5631,
        "corrected_description": "### General\nThis domain is designed for the puzzle game Flow Free, where the objective is to connect pairs of dots of the same color on a grid, without crossing flows of different colors. The player draws \"flows\" from one dot to another of the same color, filling all the spaces on the board.\n\n### Types\n- **color**: Represents the different colors of flows that need to be connected.\n- **location**: Represents the cells on the game board.\n\n### Predicates\n- **(offboard)**: Indicates that the player's current action is not on the board, allowing a new flow to be started.\n- **(empty ?l - location)**: Indicates that location ?l is empty and can be filled with a color.\n- **(not-empty ?l - location)**: Indicates that location ?l is not empty.\n- **(color-at ?l - location ?c - color)**: Indicates that location ?l has color ?c.\n- **(adjacent ?l1 - location ?l2 - location)**: Indicates that location ?l1 is adjacent to location ?l2, allowing a flow to move between them.\n- **(flow-end ?l - location ?c - color)**: Indicates that location ?l is an endpoint for a flow of color ?c.\n- **(flow-at ?l1 - location ?c - color)**: Indicates that the player is currently drawing a flow of color ?c at location ?l1.\n- **(flow-complete ?c - color)**: Indicates that the flow for color ?c is completed.\n\n### Actions\n- **move <?l1> <?l2> <?c>**: Allows the player to extend a flow of color ?c from location ?l1 to an empty, adjacent location ?l2.  \n\n- **start <?l> <?c>**: Begins a flow of color ?c from an endpoint that is empty.  \n\n- **finish <?l1> <?l2> <?c>**: Completes a flow of color ?c by connecting it to its matching endpoint.",
        "pddl_domain_processed": "(define (domain flow_free)\n\n(:requirements :strips :typing)\n\n(:types\n    color\n    location\n)\n\n(:predicates\n\n    (offboard)\n\n    (empty ?l - location)\n    (not-empty ?l - location)\n\n    (color-at ?l - location ?c - color )\n\n    (adjacent ?l1 - location ?l2 - location)\n\n    (flow-end ?l - location ?c - color)\n\n    (flow-at ?l1 - location ?c - color)\n\n    (flow-complete ?c - color)\n\n)\n\n(:action move\n    :parameters (?l1  ?l2 - location ?c - color)\n    :precondition (and (flow-at ?l1 ?c) (empty ?l2) (adjacent ?l1 ?l2)) \n    :effect (and (not (flow-at ?l1 ?c)) (not (empty ?l2)) (flow-at ?l2 ?c) (not-empty ?l2) (color-at ?l2 ?c))\n)\n\n(:action start\n    :parameters (?l - location ?c - color)\n    :precondition (and (offboard) (empty ?l) (flow-end ?l ?c) (not (flow-complete ?c))) \n    :effect (and (not (offboard)) (not (empty ?l)) (not-empty ?l) (flow-at ?l ?c) (color-at ?l ?c))\n)\n\n(:action finish\n    :parameters (?l1  ?l2 - location ?c - color)\n    :precondition (and (flow-at ?l1 ?c) (empty ?l2) (flow-end ?l2 ?c) (adjacent ?l1 ?l2)) \n    :effect (and (not (flow-at ?l1 ?c)) (not (empty ?l2)) (not-empty ?l2) (offboard) (color-at ?l2 ?c) (flow-complete ?c))\n)\n\n)\n"
    },
    {
        "file_name": "RIP2014_HW1_Team1_sokoban-domain.pddl",
        "pddl_domain": "; This program has been derived and modified from the tool-kit at: \n; https:code.google.com/p/rip-planning-group/source/browse/trunk/project1/sokoban-domain.pddl?r=222 \n; See LICENSE file at http://opensource.org/licenses/BSD-3-Clause for the New BSD license\n\n(define (domain sokoban)\n\n(:requirements :strips)\n\n(:predicates \n\t\t\n\t\t;Accessible location in Workspace\n\t\t(navigable ?l)\n\t\t\n\t\t;Direction of Movement\n\t\t(direction ?d)\n\t\t\n\t\t;Current location of the Block\n\t\t(block-at ?b ?l)\n\t\t\n\t\t;Current location of the Robot\n\t\t(robot-at ?l)\n\t\t\n\t\t;Selected Block\n\t\t(block ?b)\n\t\t\n\t\t;Location l1 and l2 are next to each other along the direction of Movement\n\t\t(adjacent ?l1 ?l2 ?d) \n\t\t\n\t\t;Empty location in workspace\n\t\t(empty ?l)\n\t)\n\n(:action move\n\t\n\t;Define Move Action\n\t;Requires from location, to location and direction of move\n\t;Requires from and to locations to be within workspace\n\t\n\t:parameters (?from ?to ?dirMove)\n\t\n\t:precondition (and\n\t\t\n\t\t(navigable ?from) \n\t\t(navigable ?to) \n\t\t(direction ?dirMove) \n\t\t\n\t\t;Current location of the Robot as from location\n\t\t(robot-at ?from) \n\t\t\n\t\t;Requires from and to locations to be next to each other along the direction of Movement\n\t\t(adjacent ?from ?to ?dirMove)\n\t\t\n\t\t;Requires to locations to be empty location in workspace \n\t\t(empty ?to)\n\t\t\n\t\t)\n\t\n\t:effect (and \n\t\t\n\t\t;Sets from locations to be empty location in workspace\n\t\t(empty ?from)\n\t\t\n\t\t;Sets Current location of the Robot as the to location in workspace\n\t\t(robot-at ?to) \n\t\t\n\t\t;Updates to locations as not null, and sets from location as not the current location of the Robot in workspace\n\t\t(not (empty ?to))\n\t\t(not (robot-at ?from))\n\t\t)\n\t)\n\n(:action push\n\t\n\t;Defines parameters for push operation that include robot location, selected block and its location\n\t;empty location to which the block has to be moved and the direction of the push operation\n\t\n\t:parameters (?robotLoc ?blockLoc ?freeLoc ?dirPush ?activeBlock)\n\t\n\t:precondition (and \n\t\t\n\t\t;Requires robot location, selected block location and the empty location to be open in the workspace\n\t\t(navigable ?robotLoc) \n\t\t(navigable ?blockLoc) \n\t\t(navigable ?freeLoc) \n\t\t\n\t\t;Initializing input variables\n\t\t(direction ?dirPush) \n\t\t(block ?activeBlock) \n\t\t(robot-at ?robotLoc) \n\t\t\n\t\t;Initializing resultant variables\n\t\t(block-at ?activeBlock ?blockLoc) \n\t\t(adjacent ?robotLoc ?blockLoc ?dirPush) \n\t\t(adjacent ?blockLoc ?freeLoc ?dirPush) \n\t\t(empty ?freeLoc)\n\t\t)\n\t\n\t:effect (and \n\t\t\t\n\t\t;Sets robots new current location as the selected blocks old location\n\t\t(robot-at ?blockLoc)\n\t\t\n\t\t;Sets selected blocks new current location as the old null location \n\t\t(block-at ?activeBlock ?freeLoc) \n\t\t\n\t\t;Sets robots old location as null location\n\t\t(empty ?robotLoc) \n\t\t\n\t\t;Updates the different locations as per effect of the move\n\t\t(not (robot-at ?robotLoc)) \n\t\t(not (block-at ?activeBlock ?blockLoc)) \n\t\t(not (empty ?freeLoc))\n\t\t)\n\t)\n\n)\n",
        "batch_id": 3,
        "id": 182,
        "tokens": 5557,
        "corrected_description": "### General\nThe Sokoban domain involves a robot navigating a workspace, moving blocks from one location to another. The goal is to arrange the blocks in a specific configuration. The domain includes actions for moving the robot and pushing blocks to adjacent locations.\n\n### Predicates\n- **(navigable ?l)**: Indicates that location ?l is accessible or navigable in the workspace.\n\n- **(direction ?d)**: Represents the direction of movement.\n\n- **(block-at ?b ?l)**: Indicates that block ?b is currently at location ?l.\n\n- **(robot-at ?l)**: Indicates the current location of the robot in the workspace.\n\n- **(block ?b)**: Identifies an object as a block.\n\n- **(adjacent ?l1 ?l2 ?d)**: Specifies that location l1 and l2 are next to each other along the direction of movement ?d.\n\n- **(empty ?l)**: Indicates that location ?l in the workspace is empty.\n\n### Actions\n- **move <?from> <?to> <?dirMove>**: Allows the robot to move from one location to another.  \n\n- **push <?robotLoc> <?blockLoc> <?freeLoc> <?dirPush> <?activeBlock>**: Allows the robot to push a block from its current location to an adjacent empty location in the specified direction.",
        "pddl_domain_processed": "\n\n(define (domain sokoban)\n\n(:requirements :strips)\n\n(:predicates \n\n\t\t(navigable ?l)\n\n\t\t(direction ?d)\n\n\t\t(block-at ?b ?l)\n\n\t\t(robot-at ?l)\n\n\t\t(block ?b)\n\n\t\t(adjacent ?l1 ?l2 ?d) \n\n\t\t(empty ?l)\n\t)\n\n(:action move\n\n\t:parameters (?from ?to ?dirMove)\n\n\t:precondition (and\n\n\t\t(navigable ?from) \n\t\t(navigable ?to) \n\t\t(direction ?dirMove) \n\n\t\t(robot-at ?from) \n\n\t\t(adjacent ?from ?to ?dirMove)\n\n\t\t(empty ?to)\n\n\t\t)\n\n\t:effect (and \n\n\t\t(empty ?from)\n\n\t\t(robot-at ?to) \n\n\t\t(not (empty ?to))\n\t\t(not (robot-at ?from))\n\t\t)\n\t)\n\n(:action push\n\n\t:parameters (?robotLoc ?blockLoc ?freeLoc ?dirPush ?activeBlock)\n\n\t:precondition (and \n\n\t\t(navigable ?robotLoc) \n\t\t(navigable ?blockLoc) \n\t\t(navigable ?freeLoc) \n\n\t\t(direction ?dirPush) \n\t\t(block ?activeBlock) \n\t\t(robot-at ?robotLoc) \n\n\t\t(block-at ?activeBlock ?blockLoc) \n\t\t(adjacent ?robotLoc ?blockLoc ?dirPush) \n\t\t(adjacent ?blockLoc ?freeLoc ?dirPush) \n\t\t(empty ?freeLoc)\n\t\t)\n\n\t:effect (and \n\n\t\t(robot-at ?blockLoc)\n\n\t\t(block-at ?activeBlock ?freeLoc) \n\n\t\t(empty ?robotLoc) \n\n\t\t(not (robot-at ?robotLoc)) \n\t\t(not (block-at ?activeBlock ?blockLoc)) \n\t\t(not (empty ?freeLoc))\n\t\t)\n\t)\n\n)\n"
    },
    {
        "file_name": "martilad_MI-UMI2018_sokobanDomain.pddl",
        "pddl_domain": "(define (domain sokoban)\n  (:requirements :equality)\n  (:predicates (has_player ?x)\n               (has_box ?x)\n               (n1 ?x ?y)\n               (n2 ?x ?y))\n  (:action move-player\n           :parameters (?x ?y)\n           :precondition (and (n1 ?x ?y)\n                              (not (has_box ?y))\n                              (has_player ?x))\n           :effect\t\t (and (has_player ?y)\n                              (not (has_player ?x))))\n  (:action push-box\n\t\t   :parameters (?x ?y ?z)\n\t\t   :precondition (and   (has_player ?x)\n                                (has_box ?y)\n                                (not (has_box ?z))\n                                (n1 ?x ?y)\n                                (n1 ?y ?z)\n                                (n2 ?x ?z))\n\t       :effect (and (has_box ?z)\n\t\t\t\t\t\t(not(has_box ?y))\n\t\t\t\t\t\t(has_player ?y)\n\t\t\t\t\t\t(not(has_player ?x))))\n  )",
        "batch_id": 3,
        "id": 184,
        "tokens": 5022,
        "corrected_description": "### General\nThe Sokoban domain involves a player moving around a grid to push boxes into designated locations. The player can move freely through empty spaces and can push a single box at a time into an adjacent space, provided the space beyond the box is also free. The goal typically involves getting all boxes to specific locations.\n\n### Predicates\n- **(has_player ?x)**: Indicates that the player is at location ?x.\n- **(has_box ?x)**: Indicates that there is a box at location ?x.\n- **(n1 ?x ?y)**: Indicates that location ?y is directly adjacent to location ?x in one direction (e.g., north).\n- **(n2 ?x ?y)**: Indicates that location ?y is directly adjacent to location ?x in another direction (e.g., east).\n\n### Actions\n- **move-player <?x> <?y>**: Allows the player to move from location ?x to location ?y.  \n\n- **push-box <?x> <?y> <?z>**: Allows the player to push a box from location ?y to location ?z.",
        "pddl_domain_processed": "(define (domain sokoban)\n  (:requirements :equality)\n  (:predicates (has_player ?x)\n               (has_box ?x)\n               (n1 ?x ?y)\n               (n2 ?x ?y))\n  (:action move-player\n           :parameters (?x ?y)\n           :precondition (and (n1 ?x ?y)\n                              (not (has_box ?y))\n                              (has_player ?x))\n           :effect\t\t (and (has_player ?y)\n                              (not (has_player ?x))))\n  (:action push-box\n\t\t   :parameters (?x ?y ?z)\n\t\t   :precondition (and   (has_player ?x)\n                                (has_box ?y)\n                                (not (has_box ?z))\n                                (n1 ?x ?y)\n                                (n1 ?y ?z)\n                                (n2 ?x ?z))\n\t       :effect (and (has_box ?z)\n\t\t\t\t\t\t(not(has_box ?y))\n\t\t\t\t\t\t(has_player ?y)\n\t\t\t\t\t\t(not(has_player ?x))))\n  )"
    },
    {
        "file_name": "fawcettc_planning-instances_ipc-old-pathways-p02-domain.pddl",
        "pddl_domain": "; IPC5 Domain: Pathways Propositional\n; Authors: Yannis Dimopoulos, Alfonso Gerevini and Alessandro Saetti\n(define (domain Pathways-Propositional)\n(:requirements :typing :adl)\n(:types level molecule - object\n        simple complex - molecule)\n(:constants c-Myc-Max cycDp1 p107-E2F4-DP12p1 p107-E2F4-DP12p1-gE2  - complex)\n(:predicates\n         (association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (synthesis-reaction ?x1 ?x2 - molecule)\n             (possible ?x - molecule)\n         (available ?x - molecule)\n             (chosen ?s - simple)\n         (next ?l1 ?l2 - level)\n         (num-subs ?l - level)\n         (goal1)\n         (goal2))\n(:action choose\n :parameters (?x - simple ?l1 ?l2 - level)\n :precondition (and (possible ?x) (not (chosen ?x))\n            (num-subs ?l2) (next ?l1 ?l2))\n :effect (and (chosen ?x) (not (num-subs ?l2)) (num-subs ?l1)))\n(:action initialize\n  :parameters (?x - simple)\n  :precondition (and (chosen ?x))\n  :effect (and (available ?x)))\n(:action associate\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (association-reaction ?x1  ?x2  ?x3)\n            (available ?x1) (available ?x2))\n :effect (and  (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action associate-with-catalyze\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (catalyzed-association-reaction ?x1 ?x2 ?x3)\n            (available ?x1) (available ?x2))\n :effect (and (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action synthesize\n :parameters (?x1 ?x2 - molecule)\n :precondition (and (synthesis-reaction ?x1 ?x2) (available ?x1))\n :effect (and (available ?x2)))\n",
        "batch_id": 3,
        "id": 187,
        "tokens": 5976,
        "corrected_description": "### General\nThis domain, named Pathways-Propositional, is designed for modeling biochemical pathways, focusing on the interactions between molecules. It involves various types of reactions, including association, catalysis, and synthesis, to simulate the complex interactions within a cellular environment. The goal is to achieve specific molecular configurations that represent biological goals.\n\n### Types\n- **object**: The base type for all entities in the domain.\n- **level**: A type representing different levels or stages in the pathway.\n- **molecule**: Represents all molecules involved in the pathways.\n  - **simple**: A subtype of molecule, representing simple molecules.\n  - **complex**: A subtype of molecule, representing complex molecules formed from reactions between simpler molecules.\n\n### Constants\n- **c-Myc-Max, cycDp1, p107-E2F4-DP12p1, p107-E2F4-DP12p1-gE2**: are predefined complex molecules used in the domain.\n\n### Predicates\n- **(association-reaction ?x1 ?x2 - molecule ?x3 - complex)**: Indicates that molecules ?x1 and ?x2 can associate to form complex ?x3.\n- **(catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)**: Indicates that molecules ?x1 and ?x2 can associate to form complex ?x3 in a reaction catalyzed by another molecule.\n- **(synthesis-reaction ?x1 ?x2 - molecule)**: Indicates that molecule ?x1 can synthesize molecule ?x2.\n- **(possible ?x - molecule)**: Indicates that molecule ?x can potentially participate in a reaction.\n- **(available ?x - molecule)**: Indicates that molecule ?x is currently available for reactions.\n- **(chosen ?s - simple)**: Indicates that simple molecule ?s has been chosen for a reaction.\n- **(next ?l1 ?l2 - level)**: Indicates that level ?l2 follows level ?l1 in the pathway.\n- **(num-subs ?l - level)**: Indicates the number of substrates at level ?l.\n- **(goal1)** and **(goal2)**: Indicate specific goal states to be achieved in the pathway.\n\n### Actions\n- **choose<?x><?l1><?l2>**: Selects a simple molecule for participation in the pathway, moving to the next level.   - **initialize<?x>**: Makes a chosen simple molecule available for reactions.  \n\n- **associate<?x1><?x2><?x3>**: Associates two molecules to form a complex.   \n\n- **associate-with-catalyze<?x1><?x2><?x3>**: Similar to associate, but one of the molecules acts as a catalyst.  \n\n- **synthesize<?x1><?x2>**: Synthesizes a new molecule from an available one.",
        "pddl_domain_processed": "\n\n(define (domain Pathways-Propositional)\n(:requirements :typing :adl)\n(:types level molecule - object\n        simple complex - molecule)\n(:constants c-Myc-Max cycDp1 p107-E2F4-DP12p1 p107-E2F4-DP12p1-gE2  - complex)\n(:predicates\n         (association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (catalyzed-association-reaction ?x1 ?x2 - molecule ?x3 - complex)\n         (synthesis-reaction ?x1 ?x2 - molecule)\n             (possible ?x - molecule)\n         (available ?x - molecule)\n             (chosen ?s - simple)\n         (next ?l1 ?l2 - level)\n         (num-subs ?l - level)\n         (goal1)\n         (goal2))\n(:action choose\n :parameters (?x - simple ?l1 ?l2 - level)\n :precondition (and (possible ?x) (not (chosen ?x))\n            (num-subs ?l2) (next ?l1 ?l2))\n :effect (and (chosen ?x) (not (num-subs ?l2)) (num-subs ?l1)))\n(:action initialize\n  :parameters (?x - simple)\n  :precondition (and (chosen ?x))\n  :effect (and (available ?x)))\n(:action associate\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (association-reaction ?x1  ?x2  ?x3)\n            (available ?x1) (available ?x2))\n :effect (and  (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action associate-with-catalyze\n :parameters (?x1 ?x2 - molecule ?x3 - complex)\n :precondition (and (catalyzed-association-reaction ?x1 ?x2 ?x3)\n            (available ?x1) (available ?x2))\n :effect (and (not (available ?x1)) (not (available ?x2)) (available ?x3)))\n(:action synthesize\n :parameters (?x1 ?x2 - molecule)\n :precondition (and (synthesis-reaction ?x1 ?x2) (available ?x1))\n :effect (and (available ?x2)))\n"
    },
    {
        "file_name": "PlanTool_plantool_sgplan_domain.pddl",
        "pddl_domain": ";; The sliding-tile puzzle (i.e. the eight/fifteen/twentyfour puzzle).\n;; Tile positions are encoded by the predicate (at <tile> <x> <y>), i.e.\n;; using one object for horizontal position and one for vertical (there's\n;; a separate predicate for the position of the blank). The predicates\n;; \"inc\" and \"dec\" encode addition/subtraction of positions.\n\n;; The instance files come in two flavors: The vanilla one uses the same\n;; objects for both x and y coordinates, while the other (files that have\n;; an \"x\" at the end of their name) uses different objects for x and y\n;; coordinates; this is because some planners seem to require different\n;; objects for each parameter of an operator.\n\n(define (domain strips-sliding-tile)\n  (:requirements :strips)\n  (:predicates\n   (tile ?x) (position ?x)\n   (at ?t ?x ?y) (blank ?x ?y)\n   (inc ?p ?pp) (dec ?p ?pp))\n\n  (:action move-up\n    :parameters (?t ?px ?py ?by)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?by)\n\t\t   (dec ?by ?py) (blank ?px ?by) (at ?t ?px ?py))\n    :effect (and (not (blank ?px ?by)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?px ?by)))\n\n  (:action move-down\n    :parameters (?t ?px ?py ?by)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?by)\n\t\t   (inc ?by ?py) (blank ?px ?by) (at ?t ?px ?py))\n    :effect (and (not (blank ?px ?by)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?px ?by)))\n\n  (:action move-left\n    :parameters (?t ?px ?py ?bx)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?bx)\n\t\t   (dec ?bx ?px) (blank ?bx ?py) (at ?t ?px ?py))\n    :effect (and (not (blank ?bx ?py)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?bx ?py)))\n\n  (:action move-right\n    :parameters (?t ?px ?py ?bx)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?bx)\n\t\t   (inc ?bx ?px) (blank ?bx ?py) (at ?t ?px ?py))\n    :effect (and (not (blank ?bx ?py)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?bx ?py)))\n  )",
        "batch_id": 3,
        "id": 188,
        "tokens": 5577,
        "corrected_description": "### General\nThis domain models the classic sliding-tile puzzle, which can be the 8, 15, or 24 puzzle. The puzzle consists of a grid of tiles with one tile missing, allowing the adjacent tiles to slide into the blank space. The goal is to rearrange the tiles into a specific configuration.\n\n### Predicates\n- **(tile ?x)**: Indicates that ?x is a tile in the puzzle.\n- **(position ?x)**: Indicates that ?x is a position on the puzzle board.\n- **(at ?t ?x ?y)**: Indicates that tile ?t is at position (?x, ?y) on the board.\n- **(blank ?x ?y)**: Indicates that the position (?x, ?y) on the board is blank (i.e., the missing tile's position).\n- **(inc ?p ?pp)**: Indicates that position ?pp is immediately after position ?p in a sequence, representing an increment.\n- **(dec ?p ?pp)**: Indicates that position ?pp is immediately before position ?p in a sequence, representing a decrement.\n\n### Actions\n- **move-up <?t> <?px> <?py> <?by>**: Allows a tile to move up into the blank space.  \n\n- **move-down <?t> <?px> <?py> <?by>**: Allows a tile to move down into the blank space.  \n\n- **move-left <?t> <?px> <?py> <?bx>**: Allows a tile to move left into the blank space.  \n\n- **move-right <?t> <?px> <?py> <?bx>**: Allows a tile to move right into the blank space.",
        "pddl_domain_processed": "\n\n(define (domain strips-sliding-tile)\n  (:requirements :strips)\n  (:predicates\n   (tile ?x) (position ?x)\n   (at ?t ?x ?y) (blank ?x ?y)\n   (inc ?p ?pp) (dec ?p ?pp))\n\n  (:action move-up\n    :parameters (?t ?px ?py ?by)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?by)\n\t\t   (dec ?by ?py) (blank ?px ?by) (at ?t ?px ?py))\n    :effect (and (not (blank ?px ?by)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?px ?by)))\n\n  (:action move-down\n    :parameters (?t ?px ?py ?by)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?by)\n\t\t   (inc ?by ?py) (blank ?px ?by) (at ?t ?px ?py))\n    :effect (and (not (blank ?px ?by)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?px ?by)))\n\n  (:action move-left\n    :parameters (?t ?px ?py ?bx)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?bx)\n\t\t   (dec ?bx ?px) (blank ?bx ?py) (at ?t ?px ?py))\n    :effect (and (not (blank ?bx ?py)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?bx ?py)))\n\n  (:action move-right\n    :parameters (?t ?px ?py ?bx)\n    :precondition (and\n\t\t   (tile ?t) (position ?px) (position ?py) (position ?bx)\n\t\t   (inc ?bx ?px) (blank ?bx ?py) (at ?t ?px ?py))\n    :effect (and (not (blank ?bx ?py)) (not (at ?t ?px ?py))\n\t\t (blank ?px ?py) (at ?t ?bx ?py)))\n  )"
    },
    {
        "file_name": "tvaquero_itsimple_domain.pddl~",
        "pddl_domain": "(define (domain Blocks_Domain_v1_0)\n  (:requirements :typing :negative-preconditions)\n  (:types\n    Hand - object\n    Block - object\n    Table - object\n  )\n  (:predicates\n    (on ?blo - Block ?blo1 - Block)\n    (holding ?han - Hand ?blo - Block)\n    (ontable ?blo - Block ?tab - Table)\n    (handempty ?han - Hand)\n    (clear ?blo - Block)\n  )\n  (:action pickUp\n   :parameters (?hand - Hand ?x - Block ?table - Table)\n   :precondition \n     (and\n       (ontable ?x ?table)\n       (clear ?x)\n       (handempty ?hand)\n     )\n   :effect\n     (and\n       (not (clear ?x))\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n       (not (ontable ?x ?table))\n     )\n  )\n\n  (:action putDown\n   :parameters (?hand - Hand ?x - Block ?table - Table)\n   :precondition \n     (and\n       (not (clear ?x))\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n     )\n   :effect\n     (and\n       (ontable ?x ?table)\n       (clear ?x)\n       (handempty ?hand)\n       (not (holding ?hand ?x))\n     )\n  )\n\n  (:action stack\n   :parameters (?hand - Hand ?x - Block ?y - Block ?table - Table)\n   :precondition \n     (and\n       (not (clear ?x))\n       (clear ?y)\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n     )\n   :effect\n     (and\n       (on ?x ?y)\n       (not (clear ?y))\n       (clear ?x)\n       (handempty ?hand)\n       (not (holding ?hand ?x))\n     )\n  )\n\n  (:action unstack\n   :parameters (?hand - Hand ?x - Block ?y - Block ?table - Table)\n   :precondition \n     (and\n       (on ?x ?y)\n       (clear ?x)\n       (handempty ?hand)\n     )\n   :effect\n     (and\n       (not (clear ?x))\n       (clear ?y)\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n       (not (on ?x ?y))\n     )\n  )\n\n)\n",
        "batch_id": 3,
        "id": 193,
        "tokens": 5521,
        "corrected_description": "### General\nThis domain, named Blocks_Domain_v1_0, models a simplified world where a robotic hand manipulates blocks. The blocks can be stacked on each other or placed on a table. The domain supports actions for picking up blocks from the table, putting down blocks on the table, stacking blocks on top of each other, and unstacking them. This domain is designed to test planning algorithms in a structured environment with clear, manipulable objects.\n\n### Types\n- **Hand**: Represents the robotic hand that performs actions on blocks.\n- **Block**: Represents the individual blocks that can be manipulated, stacked, or moved.\n- **Table**: Represents the table on which blocks can be placed.\n\n### Predicates\n- **(on ?blo - Block ?blo1 - Block)**: Indicates that block ?blo is directly on top of block ?blo1.\n- **(holding ?han - Hand ?blo - Block)**: Indicates that the hand ?han is currently holding block ?blo.\n- **(ontable ?blo - Block ?tab - Table)**: Indicates that block ?blo is on the table ?tab.\n- **(handempty ?han - Hand)**: Indicates that the hand ?han is not holding any block.\n- **(clear ?blo - Block)**: Indicates that there is no block on top of block ?blo, making it accessible for actions.\n\n### Actions\n- **pickUp <?hand> <?x> <?table>**: Allows the hand to pick up a block from the table.   \n\n- **putDown <?hand> <?x> <?table>**: Allows the hand to put down a block on the table.   \n  \n- **stack <?hand> <?x> <?y> <?table>**: Allows the hand to stack a block on top of another block.  \n  \n- **unstack <?hand> <?x> <?y> <?table>**: Allows the hand to unstack a block from on top of another block.",
        "pddl_domain_processed": "(define (domain Blocks_Domain_v1_0)\n  (:requirements :typing :negative-preconditions)\n  (:types\n    Hand - object\n    Block - object\n    Table - object\n  )\n  (:predicates\n    (on ?blo - Block ?blo1 - Block)\n    (holding ?han - Hand ?blo - Block)\n    (ontable ?blo - Block ?tab - Table)\n    (handempty ?han - Hand)\n    (clear ?blo - Block)\n  )\n  (:action pickUp\n   :parameters (?hand - Hand ?x - Block ?table - Table)\n   :precondition \n     (and\n       (ontable ?x ?table)\n       (clear ?x)\n       (handempty ?hand)\n     )\n   :effect\n     (and\n       (not (clear ?x))\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n       (not (ontable ?x ?table))\n     )\n  )\n\n  (:action putDown\n   :parameters (?hand - Hand ?x - Block ?table - Table)\n   :precondition \n     (and\n       (not (clear ?x))\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n     )\n   :effect\n     (and\n       (ontable ?x ?table)\n       (clear ?x)\n       (handempty ?hand)\n       (not (holding ?hand ?x))\n     )\n  )\n\n  (:action stack\n   :parameters (?hand - Hand ?x - Block ?y - Block ?table - Table)\n   :precondition \n     (and\n       (not (clear ?x))\n       (clear ?y)\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n     )\n   :effect\n     (and\n       (on ?x ?y)\n       (not (clear ?y))\n       (clear ?x)\n       (handempty ?hand)\n       (not (holding ?hand ?x))\n     )\n  )\n\n  (:action unstack\n   :parameters (?hand - Hand ?x - Block ?y - Block ?table - Table)\n   :precondition \n     (and\n       (on ?x ?y)\n       (clear ?x)\n       (handempty ?hand)\n     )\n   :effect\n     (and\n       (not (clear ?x))\n       (clear ?y)\n       (holding ?hand ?x)\n       (not (handempty ?hand))\n       (not (on ?x ?y))\n     )\n  )\n\n)\n"
    },
    {
        "file_name": "Annedrew_PDDL-demo_helloworld.domain.pddl",
        "pddl_domain": "(define (domain hello)\n\n(:requirements :strips :typing :negative-preconditions)\n\n(:types thing)\n\n(:predicates\n    (can_hear ?t - thing) \n    (said_hello_to ?t - thing) \n)\n\n(:action say-hello\n    :parameters (?t - thing)\n    :precondition (and\n        (not (said_hello_to ?t))\n        (can_hear ?t)\n    )\n    :effect (and\n        (said_hello_to ?t)\n    )\n)\n)\n",
        "batch_id": 3,
        "id": 199,
        "tokens": 4669,
        "corrected_description": "### General\nThis domain models a simple interaction scenario where an agent can say hello to various entities, referred to as \"things\". The primary action available is to say hello to a thing, provided it has not already been greeted and it can hear the agent.\n\n### Types\n- **thing**: Represents entities that can be interacted with in this domain.\n\n### Predicates\n- **(can_hear ?t - thing)**: Indicates that the thing ?t is capable of hearing.\n- **(said_hello_to ?t - thing)**: Indicates that the thing ?t has been greeted by the agent.\n\n### Actions\n- **say-hello <?t>**: Allows the agent to greet a thing.",
        "pddl_domain_processed": "(define (domain hello)\n\n(:requirements :strips :typing :negative-preconditions)\n\n(:types thing)\n\n(:predicates\n    (can_hear ?t - thing) \n    (said_hello_to ?t - thing) \n)\n\n(:action say-hello\n    :parameters (?t - thing)\n    :precondition (and\n        (not (said_hello_to ?t))\n        (can_hear ?t)\n    )\n    :effect (and\n        (said_hello_to ?t)\n    )\n)\n)\n"
    },
    {
        "file_name": "Planning4Storytelling_icaps-tutorial-2024_wilf_journey_domain.pddl",
        "pddl_domain": ";This is a story about a wolf cub named Wilf who gets lost\n;in the Tundra during a blizzard, but then finds his way back to his family, with the\n;help of his animal friends.\n;\n;Original story book written by Rachel Bright and illustrated by Jim Field\n;Scholastic Press 2020\n;\n;Wilf can be guided from one location to another if\n;Wilf is at location1, and location1 and location2 are connected,\n;and there is a friend at location1 who is capable of guiding Wilf to location2.\n;Wilf is safely at home when he reaches the Den\n\n(define (domain wilf_journey1)\n\n    (:requirements\n        :equality\n        :typing\n        \n    )\n\n\n    (:types friend location wilf\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n    \t(hasFriend ?l1 - location ?f - friend)\n        (isConnected ?l1 - location ?l2 - location)\n        (at ?l1 - location ?w1 - wilf)\n        (canGuide ?l1 - location ?l2 - location ?f - friend)\n        (canCarry ?l1 - location ?l2 - location ?f - friend)\n\n    )\n\n    (:functions\n\n    )\n\n    (:action guide\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canGuide ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n    (:action carry\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canCarry ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n)",
        "batch_id": 3,
        "id": 200,
        "tokens": 5371,
        "corrected_description": "### General\nThis domain models the journey of a wolf cub named Wilf who gets lost in the Tundra during a blizzard but finds his way back to his family with the help of his animal friends. The domain captures the actions that Wilf's friends can take to guide or carry him from one location to another, ensuring he safely returns home.\n\n### Types\n- **friend**: Represents the animal friends capable of assisting Wilf.\n- **location**: Represents different locations in the Tundra.\n- **wilf**: Represents the wolf cub, Wilf.\n\n### Predicates\n- **(hasFriend ?l1 - location ?f - friend)**: Indicates that a friend ?f is present at location ?l1.\n- **(isConnected ?l1 - location ?l2 - location)**: Indicates that location ?l1 is directly connected to location ?l2.\n- **(at ?l1 - location ?w1 - wilf)**: Indicates that Wilf is at location ?l1.\n- **(canGuide ?l1 - location ?l2 - location ?f - friend)**: Indicates that a friend ?f at location ?l1 can guide Wilf to location ?l2.\n- **(canCarry ?l1 - location ?l2 - location ?f - friend)**: Indicates that a friend ?f at location ?l1 can carry Wilf to location ?l2.\n\n### Actions\n- **guide <?f> <?w> <?l1> <?l2>**: Allows a friend to guide Wilf from one location to another.  \n- **carry <?f> <?w> <?l1> <?l2>**: Similar to the guide action, this allows a friend to carry Wilf from one location to another under the same conditions.",
        "pddl_domain_processed": "\n\n(define (domain wilf_journey1)\n\n    (:requirements\n        :equality\n        :typing\n\n    )\n\n    (:types friend location wilf\n    )\n\n    (:constants\n\n    )\n\n    (:predicates\n    \t(hasFriend ?l1 - location ?f - friend)\n        (isConnected ?l1 - location ?l2 - location)\n        (at ?l1 - location ?w1 - wilf)\n        (canGuide ?l1 - location ?l2 - location ?f - friend)\n        (canCarry ?l1 - location ?l2 - location ?f - friend)\n\n    )\n\n    (:functions\n\n    )\n\n    (:action guide\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canGuide ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n    (:action carry\n        :parameters (?f - friend ?w - wilf ?l1 - location ?l2 - location)\n        :precondition (and (isConnected ?l1 ?l2) (at ?l1 ?w) (hasFriend ?l1 ?f) (canCarry ?l1 ?l2 ?f)\n         )\n        :effect (and (at ?l2 ?w )\n         (not (at ?l1 ?w )) (not (hasFriend ?l1 ?f)))\n    )\n\n)"
    },
    {
        "file_name": "DamianValle_KTH-Artificial-Intelligence_vaccine-domain.pddl",
        "pddl_domain": ";; Domain definition\n(define (domain vaccine-domain)\n    (:requirements :disjunctive-preconditions :negative-preconditions)\n\n  ;; Predicates: Properties of vaccines that we are interested in (boolean)\n  (:predicates\n    (WAREHOUSE ?x) ; True if x is a WAREHOUSE\n    (CITY ?x) ; True if x is a city\n    (HOSPITAL ?x) ; True if x is an hospital\n    (VACCINE ?x) ; True if x is a vaccine\n    (VEHICLE ?x) ; True if x is a method of transportation\n    (FREEZER ?x) ; True if x is a freezing unit\n    (LONG-RANGE-VEHICLE ?x) ; True if x is a long-range vehicle\n    (SHORT-RANGE-VEHICLE ?x) ; True if x is a short-range vehicle\n    (is-temperature-sensible ?x) ; True if x is sensible to temperature changes\n    (vehicle-has-freezer ?x) ; True if vehicle x has a freezing unit\n    (connected ?x ?y) ; True if x is connected with y (warehouse, city or hospital)\n    (is-object-at ?x ?y) ; True if object x (vaccine or freeezer) is at warehouse/city y\n    (is-vehicle-at ?x ?y) ; True if vehicle x is at warehouse/city y\n    (is-vaccine-in-vehicle ?x ?y) ; True if vaccine x is in vehicle y\n  )\n\n  ;; Actions: Ways of changing the state of the world\n  \n  ; Vaccine x is loaded into vehicle y if both are in the same city/warehouse/hospital z and \n  ; if x is not temperature-sensible or the vehicle already has a freezing unit.\n  ; As a result, vaccine x is in vehicle y and not at z anymore.\n  ; Parameters\n  ; - x: vaccine\n  ; - y: vehicle\n  ; - z: city or warehouse or hopsital\n  (:action load-vaccine\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (VACCINE ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-object-at ?x ?z) \n        (is-vehicle-at ?y ?z)\n        (or (not (is-temperature-sensible ?x)) (vehicle-has-freezer ?y))\n    )\n    :effect (and \n        (is-vaccine-in-vehicle ?x ?y)\n        (not (is-object-at ?x ?z))\n    )\n  )\n  \n  ; Vaccine x is unloaded from vehicle y in city/warehouse z if the vaccine x is in the \n  ; vehicle y and the vehicle y is at z.\n  ; As a result, vaccine x is not in vehicle y anymore and the vaccine x is at z\n  ; Parameters\n  ; - x: vaccine\n  ; - y: vehicle\n  ; - z: city or warehouse or hospital\n  (:action unload-vaccine\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (VACCINE ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-vaccine-in-vehicle ?x ?y) \n        (is-vehicle-at ?y ?z)\n    )\n    :effect (and \n        (not (is-vaccine-in-vehicle ?x ?y))\n        (is-object-at ?x ?z)\n    )\n  )\n\n  ; Freezer x is loaded into vehicle y if both are in the same city/warehouse/hospital z\n  ; As a result, freezer x is in vehicle y and not at z anymore.\n  ; Parameters\n  ; - x: freezing unit\n  ; - y: vehicle\n  ; - z: city or warehouse or hospital\n  (:action load-freezer\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (FREEZER ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-object-at ?x ?z) \n        (is-vehicle-at ?y ?z)\n    )\n    :effect (and \n        (vehicle-has-freezer ?y)\n        (not (is-object-at ?x ?z))\n    )\n  )\n\n  ; Long-distance travel, i.e. between cities or warehouse x and y by a \n  ; long-range vehicle z if x and y are connected.\n  ; As a result, vehicle z is at y.\n  ; Parameters\n  ; - x: city/warehouse from\n  ; - y: city/warehouse to\n  ; - z: long-range-vehicle\n  (:action travel-long\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (or (CITY ?x) (WAREHOUSE ?x))\n        (or (CITY ?y) (WAREHOUSE ?y))\n        (LONG-RANGE-VEHICLE ?z)\n        (connected ?x ?y) \n        (is-vehicle-at ?z ?x)\n        (vehicle-has-freezer ?z)\n    )\n    :effect (and \n        (is-vehicle-at ?z ?y)\n        (not (is-vehicle-at ?z ?x))\n    )\n  )\n\n  ; Short-distance travel, inside cities, by a \n  ; short-range vehicle z if x and y are connected.\n  ; As a result, vehicle z is at y.\n  ; Parameters\n  ; - x: city or hospital from\n  ; - y: hospital or city to\n  ; - z: short-range-vehicle\n  (:action travel-short\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (or (CITY ?x) (HOSPITAL ?x))\n        (or (CITY ?y) (HOSPITAL ?y))\n        (SHORT-RANGE-VEHICLE ?z)\n        (connected ?x ?y) \n        (is-vehicle-at ?z ?x)\n    )\n    :effect (and \n        (is-vehicle-at ?z ?y)\n        (not (is-vehicle-at ?z ?x))\n    )\n  )\n  \n  \n)",
        "batch_id": 3,
        "id": 202,
        "tokens": 6449,
        "corrected_description": "### General\nThis domain models a scenario involving the distribution of vaccines from warehouses to cities and hospitals. It includes various entities such as warehouses, cities, hospitals, vaccines, vehicles, and freezers. The domain supports actions for loading and unloading vaccines and freezers into vehicles, as well as traveling between locations. The goal is to efficiently distribute vaccines, taking into account the temperature sensitivity of some vaccines and the need for proper storage during transportation.\n\n### Predicates\n- `(WAREHOUSE ?x)`: True if ?x is a warehouse.\n- `(CITY ?x)`: True if ?x is a city.\n- `(HOSPITAL ?x)`: True if ?x is a hospital.\n- `(VACCINE ?x)`: True if ?x is a vaccine.\n- `(VEHICLE ?x)`: True if ?x is a vehicle.\n- `(FREEZER ?x)`: True if ?x is a freezer.\n- `(LONG-RANGE-VEHICLE ?x)`: True if ?x is a long-range vehicle.\n- `(SHORT-RANGE-VEHICLE ?x)`: True if ?x is a short-range vehicle.\n- `(is-temperature-sensible ?x)`: True if ?x is sensitive to temperature changes.\n- `(vehicle-has-freezer ?x)`: True if vehicle ?x has a freezer.\n- `(connected ?x ?y)`: True if ?x is connected with ?y (can be warehouse, city, or hospital).\n- `(is-object-at ?x ?y)`: True if object ?x (vaccine or freezer) is at location ?y (warehouse, city, or hospital).\n- `(is-vehicle-at ?x ?y)`: True if vehicle ?x is at location ?y (warehouse, city, or hospital).\n- `(is-vaccine-in-vehicle ?x ?y)`: True if vaccine ?x is in vehicle ?y.\n\n### Actions\n- **load-vaccine <?x> <?y> <?z>**: Loads a vaccine ?x into a vehicle ?y at a location ?z.  \n  \n- **unload-vaccine <?x> <?y> <?z>**: Unloads a vaccine ?x from a vehicle ?y at a location ?z.   \n- **load-freezer <?x> <?y> <?z>**: Loads a freezer ?x into a vehicle ?y at a location ?z.  \n  \n- **travel-long <?x> <?y> <?z>**: Represents long-distance travel between cities or warehouses from ?x to ?y by a long-range vehicle ?z with a freezer. \n  \n- **travel-short <?x> <?y> <?z>**: Represents short-distance travel between cities or warehouses from ?x to ?y by a short-range vehicle ?z.",
        "pddl_domain_processed": "\n(define (domain vaccine-domain)\n    (:requirements :disjunctive-preconditions :negative-preconditions)\n\n  (:predicates\n    (WAREHOUSE ?x) \n    (CITY ?x) \n    (HOSPITAL ?x) \n    (VACCINE ?x) \n    (VEHICLE ?x) \n    (FREEZER ?x) \n    (LONG-RANGE-VEHICLE ?x) \n    (SHORT-RANGE-VEHICLE ?x) \n    (is-temperature-sensible ?x) \n    (vehicle-has-freezer ?x) \n    (connected ?x ?y) \n    (is-object-at ?x ?y) \n    (is-vehicle-at ?x ?y) \n    (is-vaccine-in-vehicle ?x ?y) \n  )\n\n  (:action load-vaccine\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (VACCINE ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-object-at ?x ?z) \n        (is-vehicle-at ?y ?z)\n        (or (not (is-temperature-sensible ?x)) (vehicle-has-freezer ?y))\n    )\n    :effect (and \n        (is-vaccine-in-vehicle ?x ?y)\n        (not (is-object-at ?x ?z))\n    )\n  )\n\n  (:action unload-vaccine\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (VACCINE ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-vaccine-in-vehicle ?x ?y) \n        (is-vehicle-at ?y ?z)\n    )\n    :effect (and \n        (not (is-vaccine-in-vehicle ?x ?y))\n        (is-object-at ?x ?z)\n    )\n  )\n\n  (:action load-freezer\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (FREEZER ?x) \n        (VEHICLE ?y) \n        (or (CITY ?z) (WAREHOUSE ?z) (HOSPITAL ?z))\n        (is-object-at ?x ?z) \n        (is-vehicle-at ?y ?z)\n    )\n    :effect (and \n        (vehicle-has-freezer ?y)\n        (not (is-object-at ?x ?z))\n    )\n  )\n\n  (:action travel-long\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (or (CITY ?x) (WAREHOUSE ?x))\n        (or (CITY ?y) (WAREHOUSE ?y))\n        (LONG-RANGE-VEHICLE ?z)\n        (connected ?x ?y) \n        (is-vehicle-at ?z ?x)\n        (vehicle-has-freezer ?z)\n    )\n    :effect (and \n        (is-vehicle-at ?z ?y)\n        (not (is-vehicle-at ?z ?x))\n    )\n  )\n\n  (:action travel-short\n    :parameters (?x ?y ?z)\n    :precondition (and \n        (or (CITY ?x) (HOSPITAL ?x))\n        (or (CITY ?y) (HOSPITAL ?y))\n        (SHORT-RANGE-VEHICLE ?z)\n        (connected ?x ?y) \n        (is-vehicle-at ?z ?x)\n    )\n    :effect (and \n        (is-vehicle-at ?z ?y)\n        (not (is-vehicle-at ?z ?x))\n    )\n  )\n\n)"
    },
    {
        "file_name": "MOHYAZZZ_ai-planning_AirCargoDomain.pddl",
        "pddl_domain": ";; PDDL domain of the Air cargo transport\n;; The author of this piece of code is: https://github.com/arii\n;; This is a simple PDDL code inspired by the book Artificial Intelligence : A Modern Approach page 369-370\n\n(define (domain air-cargo)\n    (:requirements :strips)\n    (:predicates\n        (In ?obj ?place)\n        (At ?obj ?place)\n        (Cargo ?obj)\n        (Plane ?obj)\n        (Airport ?obj)\n    )\n\n    (:action LOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (At ?c ?a)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (At ?c ?a)) (In ?c ?p))\n    )\n\n    (:action UNLOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (In ?c ?p)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (In ?c ?p)) (At ?c ?a))\n    )\n\n    (:action FLY\n        :parameters (?p ?from ?to)\n        :precondition (and (At ?p ?from)\n            (Plane ?p)\n            (Airport ?from)\n            (Airport ?to))\n        :effect (and (not (At ?p ?from)) (At ?p ?to))\n    )\n)",
        "batch_id": 3,
        "id": 229,
        "tokens": 5066,
        "corrected_description": "### General\nThis domain models an air cargo transport system where cargo can be loaded onto planes, transported between airports, and unloaded. The goal is to find a plan that moves cargo from their initial locations to their destinations using a fleet of planes.\n\n### Predicates\n- **(In ?obj ?place)**: Indicates that cargo ?obj is inside plane ?place.\n- **(At ?obj ?place)**: Indicates that an object (cargo or plane) ?obj is at airport ?place.\n- **(Cargo ?obj)**: Indicates that ?obj is a cargo.\n- **(Plane ?obj)**: Indicates that ?obj is a plane.\n- **(Airport ?obj)**: Indicates that ?obj is an airport.\n\n### Actions\n- **LOAD <?c> <?p> <?a>**: Allows loading cargo onto a plane at an airport.  \n  \n- **UNLOAD <?c> <?p> <?a>**: Allows unloading cargo from a plane at an airport.  \n  \n- **FLY <?p> <?from> <?to>**: Allows a plane to fly from one airport to another.",
        "pddl_domain_processed": "\n\n(define (domain air-cargo)\n    (:requirements :strips)\n    (:predicates\n        (In ?obj ?place)\n        (At ?obj ?place)\n        (Cargo ?obj)\n        (Plane ?obj)\n        (Airport ?obj)\n    )\n\n    (:action LOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (At ?c ?a)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (At ?c ?a)) (In ?c ?p))\n    )\n\n    (:action UNLOAD\n        :parameters (?c ?p ?a)\n        :precondition (and (In ?c ?p)\n            (At ?p ?a)\n            (Cargo ?c)\n            (Plane ?p)\n            (Airport ?a))\n        :effect (and (not (In ?c ?p)) (At ?c ?a))\n    )\n\n    (:action FLY\n        :parameters (?p ?from ?to)\n        :precondition (and (At ?p ?from)\n            (Plane ?p)\n            (Airport ?from)\n            (Airport ?to))\n        :effect (and (not (At ?p ?from)) (At ?p ?to))\n    )\n)"
    },
    {
        "file_name": "hakank_hakank_painting-domain.pddl",
        "pddl_domain": ";;;\n;;; Painting problem in PDDL.\n;;;\n;;; From Automated Planning, page 105f\n;;;\n(define (domain painting)\n   (:requirements :strips)\n   (:predicates (dip-brush ?r ?v ?c )\n                (paint ?b ?r ?k)\n                (brush ?r)\n                (can ?c)\n                (color ?c ?k)\n                (canpaint ?r ?k)\n                (dry ?r)\n                (block ?b)\n                )\n\n   (:action dip-brush\n             :parameters (?r ?c ?k)\n             :precondition \n                       (and \n                           (brush ?r)\n                           (can ?c)\n                           (color ?c ?k)\n                           (dry ?r)\n                          )\n\n             :effect \n                       (and\n                          (canpaint ?r ?k)\n                          (not (dry ?r))\n                           )\n\n    ) \n\n\n   (:action paint\n             :parameters (?b ?r ?k)\n             :precondition \n                       (and \n                          (block ?b)     \n                          (brush ?r)\n                          (canpaint ?r ?k)\n                          )\n\n             :effect \n                       (and\n                          (paint ?b ?r ?k)\n                          (not (canpaint ?r ?k))\n                          (dry ?r)\n                           )\n    ) \n\n\n)\n",
        "batch_id": 3,
        "id": 234,
        "tokens": 5111,
        "corrected_description": "### General\nThis domain is designed for a painting problem where the goal is to paint blocks with specific colors using a brush and paint cans. The actions defined in this domain allow for dipping a brush into a paint can to get paint of a certain color and then using the brush to paint a block.\n\n### Predicates\n- **(dip-brush ?r ?v ?c)**: Indicates that a brush ?r is dipped into a can ?v of color ?c.\n- **(paint ?b ?r ?k)**: Indicates that a block ?b is painted with a brush ?r of color ?k.\n- **(brush ?r)**: Indicates that ?r is a brush.\n- **(can ?c)**: Indicates that ?c is a can of paint.\n- **(color ?c ?k)**: Indicates that can ?c contains paint of color ?k.\n- **(canpaint ?r ?k)**: Indicates that brush ?r can paint with color ?k.\n- **(dry ?r)**: Indicates that brush ?r is dry.\n- **(block ?b)**: Indicates that ?b is a block.\n\n### Actions\n- **dip-brush** <?r> <?c> <?k>: Allows a brush ?r to be dipped into a paint can ?c to get paint of a certain color ?k.  \n\n- **paint** <?b> <?r> <?k>: Allows a block ?b to be painted with a brush ?r that has paint of a certain color ?k.",
        "pddl_domain_processed": "\n\n(define (domain painting)\n   (:requirements :strips)\n   (:predicates (dip-brush ?r ?v ?c )\n                (paint ?b ?r ?k)\n                (brush ?r)\n                (can ?c)\n                (color ?c ?k)\n                (canpaint ?r ?k)\n                (dry ?r)\n                (block ?b)\n                )\n\n   (:action dip-brush\n             :parameters (?r ?c ?k)\n             :precondition \n                       (and \n                           (brush ?r)\n                           (can ?c)\n                           (color ?c ?k)\n                           (dry ?r)\n                          )\n\n             :effect \n                       (and\n                          (canpaint ?r ?k)\n                          (not (dry ?r))\n                           )\n\n    ) \n\n   (:action paint\n             :parameters (?b ?r ?k)\n             :precondition \n                       (and \n                          (block ?b)     \n                          (brush ?r)\n                          (canpaint ?r ?k)\n                          )\n\n             :effect \n                       (and\n                          (paint ?b ?r ?k)\n                          (not (canpaint ?r ?k))\n                          (dry ?r)\n                           )\n    ) \n\n)\n"
    },
    {
        "file_name": "rleap-project_d2l_domain_fstrips.pddl",
        "pddl_domain": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Blocksworld domain\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The classical blocksworld problem, functional version.\n;;; Loosely based on the IPC 2008 version available at <http://ipc.informatik.uni-freiburg.de/PddlExtension>\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define (domain blocksworld-fn-cond)\n\n  (:types place - object\n          block - place\n  )\n\n  (:constants table - place)\n\n  (:predicates\n   (clear ?b - place)\n   )\n\n  (:functions\n   (loc ?b - block) - place\n   )\n\n  (:action move\n   :parameters (?b - block ?to - place)\n   :precondition (and\n\t\t(clear ?b)\n\t\t(clear ?to)\n\t\t(not (= ?b ?to))\n\t\t(not (= (loc ?b) ?to)))\n   :effect (and\n\t\t(assign (loc ?b) ?to)\n\t\t(clear (loc ?b))\n\t\t(when (not (= ?to table)) (not (clear ?to)))\n\t)\n   )\n\n)",
        "batch_id": 3,
        "id": 238,
        "tokens": 5092,
        "corrected_description": "### General\nThis domain represents a functional version of the classical blocksworld problem, where blocks can be moved from one place to another. The domain is designed to handle the movement of blocks onto other blocks or a table, ensuring that only clear blocks (those with no other blocks on top) can be moved.\n\n### Types\n- **place**: The base type for all locations in the domain. This includes both the table and any blocks that can act as a place to put another block.\n- **block**: A subtype of place. Represents the movable blocks in the blocksworld.\n- **object**: The base type for all objects in the domain.\n\n### Constants\n- **table**: A special place representing the table. It is considered a constant in this domain, serving as a potential location to move blocks to.\n\n### Predicates\n- **(clear ?b - place)**: Indicates that a place (either a block or the table) is clear of any other blocks on top of it, making it a valid target to move another block onto.\n\n### Functions\n- **(loc ?b - block) - place**: Represents the current location of a block. This function maps each block to its current place, which can be either another block or the table.\n\n### Actions\n- **move <?b> <?to>**: Allows moving a block to a new location under certain conditions.",
        "pddl_domain_processed": "\n\n(define (domain blocksworld-fn-cond)\n\n  (:types place - object\n          block - place\n  )\n\n  (:constants table - place)\n\n  (:predicates\n   (clear ?b - place)\n   )\n\n  (:functions\n   (loc ?b - block) - place\n   )\n\n  (:action move\n   :parameters (?b - block ?to - place)\n   :precondition (and\n\t\t(clear ?b)\n\t\t(clear ?to)\n\t\t(not (= ?b ?to))\n\t\t(not (= (loc ?b) ?to)))\n   :effect (and\n\t\t(assign (loc ?b) ?to)\n\t\t(clear (loc ?b))\n\t\t(when (not (= ?to table)) (not (clear ?to)))\n\t)\n   )\n\n)"
    },
    {
        "file_name": "hakank_hakank_1d-rubiks-cube2-domain.pddl",
        "pddl_domain": "(define (domain rubik-1d2)\n   (:requirements :strips :adl :typing)\n   \n   (:constants p1 p2 p3 p4 p5 p6)\n   (:predicates (pos ?p ?v) )\n\n   \n   \n   \n   (:action rot0\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and \n                           (pos p1 ?v4)              \n                           (pos p2 ?v3)              \n                           (pos p3 ?v2)              \n                           (pos p4 ?v1)              \n                           (not (pos p1 ?v1))\n                           (not (pos p2 ?v2))\n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4)))\n    ) \n\n    \n    \n    \n    \n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and \n                           (pos p2 ?v5)              \n                           (pos p3 ?v4)              \n                           (pos p4 ?v3)              \n                           (pos p5 ?v2)\n                           (not (pos p2 ?v2))\n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4))\n                           (not (pos p5 ?v5)))\n    ) \n\n    \n    \n    \n    \n    (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and           \n                           (pos p3 ?v6)              \n                           (pos p4 ?v5)              \n                           (pos p5 ?v4)              \n                           (pos p6 ?v3)              \n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4))\n                           (not (pos p5 ?v5))\n                           (not (pos p6 ?v6)))\n    ) \n\n\n)\n",
        "batch_id": 3,
        "id": 240,
        "tokens": 6110,
        "corrected_description": "### General\nThis domain models a 1D Rubik's Cube, a puzzle that consists of a line of 6 numbers that can be rotated in three different ways in groups of four. The goal is to find the shortest sequence of rotations to restore the original position of the numbers.\n\n### Predicates\n- **(pos ?p ?v)**: Indicates that position ?p contains value ?v.\n\n### Actions\n- **rot0 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: This action simulates the rotation of the first four positions of the 1D Rubik's Cube.  \n\n- **rot1 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: This action simulates the rotation of the middle four positions of the 1D Rubik's Cube.  \n\n- **rot2 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: This action simulates the rotation of the last four positions of the 1D Rubik's Cube.",
        "pddl_domain_processed": "(define (domain rubik-1d2)\n   (:requirements :strips :adl :typing)\n\n   (:constants p1 p2 p3 p4 p5 p6)\n   (:predicates (pos ?p ?v) )\n\n   (:action rot0\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and \n                           (pos p1 ?v4)              \n                           (pos p2 ?v3)              \n                           (pos p3 ?v2)              \n                           (pos p4 ?v1)              \n                           (not (pos p1 ?v1))\n                           (not (pos p2 ?v2))\n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4)))\n    ) \n\n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and \n                           (pos p2 ?v5)              \n                           (pos p3 ?v4)              \n                           (pos p4 ?v3)              \n                           (pos p5 ?v2)\n                           (not (pos p2 ?v2))\n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4))\n                           (not (pos p5 ?v5)))\n    ) \n\n    (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos p1 ?v1) \n                                (pos p2 ?v2) \n                                (pos p3 ?v3) \n                                (pos p4 ?v4) \n                                (pos p5 ?v5) \n                                (pos p6 ?v6) \n                                )\n             :effect  (and           \n                           (pos p3 ?v6)              \n                           (pos p4 ?v5)              \n                           (pos p5 ?v4)              \n                           (pos p6 ?v3)              \n                           (not (pos p3 ?v3))\n                           (not (pos p4 ?v4))\n                           (not (pos p5 ?v5))\n                           (not (pos p6 ?v6)))\n    ) \n\n)\n"
    },
    {
        "file_name": "SoarGroup_Domains-Planning-Domain-Definition-Language_springer.pddl",
        "pddl_domain": "\n;; The \"Springer Game\" is a chess puzzle (an implementation of the game\n;; came along with the -99 Springer Verlag CD-ROM catalogue).\n;; The objective is to step exactly once on each square of a chess board,\n;; using the moves of a knight (?) (\"springer\", in german, I guess). The\n;; choice of initial position is free (though it might as well be fixed,\n;; since there's (supposedly, I haven't checked) exactly one solution for\n;; each initial position).\n\n;; The predicate \"at\" encodes the piece's current position, while \"clear\"\n;; and \"mark\" keep track of visited squares. The \"inc\" and \"dec\" predicates\n;; encode addition and subtraction.\n\n;; There are four problem instance files:\n;;  - springer1.pddl is the vanilla version.\n;;  - springer1x.pddl uses separate objects for x and y coordinates, since\n;;    some planners seem to require different objects for each parameter of\n;;    an operator (which seems like a silly thing).\n;;  - springer2.pddl has a fixed initial position (upper left corner).\n;;  - springer2x.pddl is the same but using x/y objects.\n\n;; This seems to be a very hard problem; I've not found any planner that\n;; can solve it yet.\n\n(define (domain springer_game)\n  (:requirements :strips)\n  (:predicates (ready) (at ?x ?y) (clear ?x ?y) (mark ?x ?y)\n\t       (inc ?p ?pp) (dec ?p ?pp))\n\n  (:action start\n    :parameters (?px ?py)\n    :precondition (and (ready) (clear ?px ?py))\n    :effect (and (not (ready)) (at ?px ?py) (not (clear ?px ?py))\n\t\t (mark ?px ?py)))\n\n  (:action RRD ; right-right-down\n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?ix) (inc ?ix ?fx) (inc ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RRU ; right-right-up\n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?ix) (inc ?ix ?fx) (dec ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LLD ; left-left-down\n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?ix) (dec ?ix ?fx) (inc ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LLU ; left-left-up\n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?ix) (dec ?ix ?fx) (dec ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RDD ; right-down-down\n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?fx) (inc ?py ?iy) (inc ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RUU ; right-up-up\n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?fx) (dec ?py ?iy) (dec ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LDD ; left-down-down\n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?fx) (inc ?py ?iy) (inc ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LUU ; left-up-up\n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?fx) (dec ?py ?iy) (dec ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n  )\n",
        "batch_id": 3,
        "id": 241,
        "tokens": 6269,
        "corrected_description": "### General\nThe Springer Game domain models a chess puzzle where the objective is to move a knight across a chessboard, stepping exactly once on each square. The domain includes actions that represent the knight's legal moves, ensuring it only moves to clear squares and marks squares it has visited. Note: as it moves up, y increases, and as it moves down, y decreases. As it moves left, x increases, and as it moves right, x decreases.\n\n### Predicates\n- **(ready)**: Indicates that the game is ready to start, i.e., the knight has not yet been placed on the board.\n- **(at ?x ?y)**: Indicates the current position of the knight on the board.\n- **(clear ?x ?y)**: Indicates that a square at position (?x, ?y) has not been visited by the knight.\n- **(mark ?x ?y)**: Indicates that a square at position (?x, ?y) has been visited by the knight.\n- **(inc ?p ?pp)**: Represents an increment operation, where ?p is one unit greater than ?pp.\n- **(dec ?p ?pp)**: Represents a decrement operation, where ?p is one unit less than ?pp.\n\n### Actions\n- **start <?px> <?py>**: Begins the game by placing the knight at a starting position (?px, ?py) on the board.  \n- **RRD <?px> <?py> <?fx> <?fy> <?ix>**: Moves the knight right-right-down.  \n- **RRU <?px> <?py> <?fx> <?fy> <?ix>**: Moves the knight right-right-up.  \n- **LLD <?px> <?py> <?fx> <?fy> <?ix>**: Moves the knight left-left-down.  \n- **LLU <?px> <?py> <?fx> <?fy> <?ix>**: Moves the knight left-left-up.  \n- **RDD <?px> <?py> <?fx> <?fy> <?iy>**: Moves the knight right-down-down.  \n- **RUU <?px> <?py> <?fx> <?fy> <?iy>**: Moves the knight right-up-up.  \n- **LDD <?px> <?py> <?fx> <?fy> <?iy>**: Moves the knight left-down-down.  \n- **LUU <?px> <?py> <?fx> <?fy> <?iy>**: Moves the knight left-up-up.",
        "pddl_domain_processed": "\n\n(define (domain springer_game)\n  (:requirements :strips)\n  (:predicates (ready) (at ?x ?y) (clear ?x ?y) (mark ?x ?y)\n\t       (inc ?p ?pp) (dec ?p ?pp))\n\n  (:action start\n    :parameters (?px ?py)\n    :precondition (and (ready) (clear ?px ?py))\n    :effect (and (not (ready)) (at ?px ?py) (not (clear ?px ?py))\n\t\t (mark ?px ?py)))\n\n  (:action RRD \n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?ix) (inc ?ix ?fx) (inc ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RRU \n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?ix) (inc ?ix ?fx) (dec ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LLD \n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?ix) (dec ?ix ?fx) (inc ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LLU \n    :parameters (?px ?py ?fx ?fy ?ix)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?ix) (dec ?ix ?fx) (dec ?py ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RDD \n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?fx) (inc ?py ?iy) (inc ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action RUU \n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (inc ?px ?fx) (dec ?py ?iy) (dec ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LDD \n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?fx) (inc ?py ?iy) (inc ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n\n  (:action LUU \n    :parameters (?px ?py ?fx ?fy ?iy)\n    :precondition (and (at ?px ?py) (clear ?fx ?fy)\n\t\t       (dec ?px ?fx) (dec ?py ?iy) (dec ?iy ?fy))\n    :effect (and (not (at ?px ?py)) (not (clear ?fx ?fy))\n\t\t (at ?fx ?fy) (mark ?fx ?fy)))\n  )\n"
    },
    {
        "file_name": "hakank_hakank_shortest_path-domain.pddl",
        "pddl_domain": ";;;\n;;; Shortest path problem in PDDL.\n;;;\n;;; Inspired by the Graphplan problem shortestpath_ops.htm / shortestpath_facts.htm\n;;;\n\n ;; MOVE\n ;; (params (<start> <end> CONNECTED))\n ;; (preconds  (at <start>))\n ;; (effects   (at <end>) (del at <start>)))\n\n(define (domain shortest)\n   (:requirements :strips)\n   (:predicates \n                 (at ?pos)\n                 (connected ?from ?to)\n                 )\n\n   (:action move\n             :parameters (?from ?to)\n             :precondition (and \n                             (at ?from) \n                             ;;; (connected ?from ?to) \n                             (or\n                              (connected ?from ?to)\n                              (connected ?to ?from))\n                             )\n             :effect  (and \n                           (at ?to)\n                           (not (at ?from)))\n    ) \n\n\n)\n\n",
        "batch_id": 3,
        "id": 244,
        "tokens": 4920,
        "corrected_description": "### General\nThis domain models the problem of finding the shortest path in a graph. It is designed to represent the movement from one point to another in a space where certain points are connected. The goal is to navigate from a starting position to a destination by moving through connected points.\n\n### Predicates\n-  **(at ?pos)**: Indicates that the current position is ?pos.\n- **(connected ?from ?to)**: Indicates that there is a direct connection from ?from to ?to. This connection is bidirectional as implied by the use of the predicate in both directions within the action's precondition.\n\n### Actions\n- **move <?from> <?to>**: Allows moving from one point to another.",
        "pddl_domain_processed": "\n\n(define (domain shortest)\n   (:requirements :strips)\n   (:predicates \n                 (at ?pos)\n                 (connected ?from ?to)\n                 )\n\n   (:action move\n             :parameters (?from ?to)\n             :precondition (and \n                             (at ?from) \n\n                             (or\n                              (connected ?from ?to)\n                              (connected ?to ?from))\n                             )\n             :effect  (and \n                           (at ?to)\n                           (not (at ?from)))\n    ) \n\n)\n\n"
    },
    {
        "file_name": "hakank_hakank_rotation-domain.pddl",
        "pddl_domain": ";;;\n;;; Rotation permutation puzzle in PDDL.\n;;;\n;;; From GAP mailing list\n;;; http://www-groups.dcs.st-and.ac.uk/~gap/ForumArchive/Harris.1/Bob.1/Re__GAP_.59/1.html\n;;; \"\"\"\n;;; Since you asked about what the puzzle actually is, the fellow who posted it\n;;; at rec.puzzles (Kevin Buzzard <buzzard@ic.PUZZLE.ac.ELZZUP.uk>) had found it\n;;; on his nokia cell phone. It is called \"rotation\" at Nokia's web site\n;;; http://www.nokia.com/games\n;;; I think this variant is level 5.\n;;;\n;;; The puzzle is a 4x4 square of numbers. There are four operations, each of\n;;; which involves rotating the numbers in a 3x3 square clockwise. So, in the\n;;; diagram below, one move is the cycle (1,2,3,7,11,10,9,5). The numbers\n;;; maintain orientation-- they don't rotate; if they did, that would add\n;;; another layer of complexity for the solver.\n;;;\n;;;      1  2  3  4\n;;;      5  6  7  8\n;;;      9 10 11 12\n;;;     13 14 15 16\n;;;\n;;; Anyone who's interested in an archive of the discussion ofthis puzzle (it's\n;;; about a 40K byte text file), let me know. The discussion focuses primarily\n;;; on finding minimal move sequences to swap two given tiles.\n;;;\n;;; There's a very well done java applet for a similar puzzle at\n;;; http://www.microprizes.com/mp52.htm \n;;; \"\"\"\n\n;;;\n;;; Also see http://hakank.org/minizinc/rotation.mzn\n;;;\n(define (domain rotation)\n   (:requirements :strips)\n   (:predicates (pos1 ?v )\n                (pos2 ?v )\n                (pos3 ?v )\n                (pos4 ?v )\n                (pos5 ?v )\n                (pos6 ?v )\n                (pos7 ?v )\n                (pos8 ?v )\n                (pos9 ?v )\n                (pos10 ?v )\n                (pos11 ?v )\n                (pos12 ?v )\n                (pos13 ?v )\n                (pos14 ?v )\n                (pos15 ?v )\n                (pos16 ?v )\n                )\n\n   ;\n   ; Rotation: 1, 2, 3,  7, 11, 10,  9,  5\n   ;\n   ;           1  2   3  4   5   6   7   8   9   10   11   12   13   14  15   16 ->\n   ;           5  1   2  4   9   6   3   8  10   11    7   12   13   14  15   16 ->\n   ;           _  _   _      _       _      __   __   __\n\n   ; \n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n                           (pos1 ?v5)\n                           (pos2 ?v1)\n                           (pos3 ?v2)\n                           ;;;(pos4 ?v4)        \n                           (pos5 ?v9)\n                           ;;;(pos6 ?v6)              \n                           (pos7 ?v3)\n                           ;;;(pos8 ?v8)              \n                           (pos9 ?v10)\n                           (pos10 ?v11)\n                           (pos11 ?v7)\n                           ;;;(pos12 ?v12)\n                           ;;;(pos13 ?v13)\n                           ;;;(pos14 ?v14)\n                           ;;;(pos15 ?v15)\n                           ;;;(pos16 ?v16)\n                           (not (pos1 ?v1))\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           ;;: (not (pos4 ?v4))\n                           (not (pos5 ?v5))\n                           ;;;(not (pos6 ?v6))\n                           (not (pos7 ?v7))\n                           ;;;(not (pos8 ?v8))\n                           (not (pos9 ?v9))\n                           (not (pos10 ?v10))\n                           (not (pos11 ?v11))\n                           ;;;(not (pos12 ?v12))\n                           ;;;(not (pos13 ?v13))\n                           ;;;(not (pos14 ?v14))\n                           ;;;(not (pos15 ?v15))\n                           ;;;(not (pos16 ?v16))\n                           )\n\n    ) \n\n   ;;\n   ;;  rot2:  2, 3, 4,  8, 12, 11, 10,  6,\n   ;;\n   ;           1  2   3  4   5   6   7   8   9   10   11   12   13   14  15   16 ->\n   ;           1  6   2  3   5  10   7   4   9   11   12    8   13   14  15   16 ->          \n   ; \n   (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n                          ;;;(pos1 ?v1) \n                          (pos2 ?v6) \n                          (pos3 ?v2) \n                          (pos4 ?v3) \n                          ;;;(pos5 ?v5) \n                          (pos6 ?v10) \n                          ;;;(pos7 ?v7) \n                          (pos8 ?v4) \n                          ;;;(pos9 ?v9) \n                          (pos10 ?v11) \n                          (pos11 ?v12) \n                          (pos12 ?v8)\n                          ;;;(pos13 ?v13)\n                          ;;;(pos14 ?v14)\n                          ;;;(pos15 ?v15)\n                          ;;;(pos16 ?v16)\n\n                           ;;;;(not (pos1 ?v1))\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n                           ;;;(not (pos5 ?v5))\n                           (not (pos6 ?v6))\n                           ;;;(not (pos7 ?v7))\n                           (not (pos8 ?v8))\n                           ;;;(not (pos9 ?v9))\n                           (not (pos10 ?v10))\n                           (not (pos11 ?v11))\n                           (not (pos12 ?v12))\n                           ;; (not (pos13 ?v13))\n                           ;; (not (pos14 ?v14))\n                           ;; (not (pos15 ?v15))\n                           ;; (not (pos16 ?v16))\n                           )\n\n    ) \n\n\n   ;;\n   ;;  rot3:  5, 6, 7, 11, 15, 14, 13,  9,\n   ;;;\n   ;           1  2   3  4   5   6   7   8   9   10   11   12   13   14  15   16 ->\n   ;           1  2   3  4   9   5   6   8  13   10    7   12   14   15  11   16 \n   ;;\n   (:action rot3\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n                          ;; (pos1 ?v1) \n                          ;; (pos2 ?v2) \n                          ;; (pos3 ?v3) \n                          ;; (pos4 ?v4) \n                          (pos5 ?v9) \n                          (pos6 ?v5) \n                          (pos7 ?v6) \n                          ;;;(pos8 ?v8) \n                          (pos9 ?v13) \n                          ;;(pos10 ?v10) \n                          (pos11 ?v7) \n                          ;;(pos12 ?v12)\n                          (pos13 ?v14)\n                          (pos14 ?v15)\n                          (pos15 ?v11)\n                          ;;;(pos16 ?v16)\n\n                           ;; (not (pos1 ?v1))\n                           ;; (not (pos2 ?v2))\n                           ;; (not (pos3 ?v3))\n                           ;; (not (pos4 ?v4))\n                           (not (pos5 ?v5))\n                           (not (pos6 ?v6))\n                           (not (pos7 ?v7))\n                           ;; (not (pos8 ?v8))\n                           (not (pos9 ?v9))\n                           ;;;(not (pos10 ?v10))\n                           (not (pos11 ?v11))\n                           ;;;(not (pos12 ?v12))\n                           (not (pos13 ?v13))\n                           (not (pos14 ?v14))\n                           (not (pos15 ?v15))\n                           ;;;(not (pos16 ?v16))\n                           )\n\n    ) \n\n   ;;\n   ;;  rot4:  6, 7, 8, 12, 16, 15, 14, 10,\n   ;;\n   ;          1  2   3  4   5   6   7   8   9   10   11   12   13   14  15   16 ->\n   ;          1  2   3  4   5  10   6   7   9   14   11    8   13   15  16   12 \n   ;;\n   (:action rot4\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n                          ;; (pos1 ?v1) \n                          ;; (pos2 ?v2) \n                          ;; (pos3 ?v3) \n                          ;; (pos4 ?v4) \n                          ;; (pos5 ?v5) \n                          (pos6 ?v10) \n                          (pos7 ?v6) \n                          (pos8 ?v7) \n                          ;;;(pos9 ?v9) \n                          (pos10 ?v14) \n                          ;;;(pos11 ?v11) \n                          (pos12 ?v8)\n                          ;;;(pos13 ?v13)\n                          (pos14 ?v15)\n                          (pos15 ?v16)\n                          (pos16 ?v12)\n\n                           ;; (not (pos1 ?v1))\n                           ;; (not (pos2 ?v2))\n                           ;; (not (pos3 ?v3))\n                           ;; (not (pos4 ?v4))\n                           ;; (not (pos5 ?v5))\n                           (not (pos6 ?v6))\n                           (not (pos7 ?v7))\n                           (not (pos8 ?v8))\n                           ;;;(not (pos9 ?v9))\n                           (not (pos10 ?v10))\n                           ;;;(not (pos11 ?v11))\n                           (not (pos12 ?v12))\n                           ;;;(not (pos13 ?v13))\n                           (not (pos14 ?v14))\n                           (not (pos15 ?v15))\n                           (not (pos16 ?v16))\n                           )\n\n    ) \n\n\n\n)\n",
        "batch_id": 3,
        "id": 245,
        "tokens": 8370,
        "corrected_description": "### General\nThis domain represents a rotation permutation puzzle, specifically designed as a 4x4 square of numbers. The puzzle allows for four distinct rotation actions, each involving a 3x3 subset of the square, where numbers are rotated clockwise. The objective is to achieve a specific configuration of numbers through a series of these rotations.\n\n### Predicates\n- **(pos1 ?v)**: Indicates the value in position 1 of the 4x4 grid.\n- **(pos2 ?v)**: Indicates the value in position 2 of the grid.\n- **(pos3 ?v)**: Indicates the value in position 3 of the grid.\n- **(pos4 ?v)**: Indicates the value in position 4 of the grid.\n- **(pos5 ?v)**: Indicates the value in position 5 of the grid.\n- **(pos6 ?v)**: Indicates the value in position 6 of the grid.\n- **(pos7 ?v)**: Indicates the value in position 7 of the grid.\n- **(pos8 ?v)**: Indicates the value in position 8 of the grid.\n- **(pos9 ?v)**: Indicates the value in position 9 of the grid.\n- **(pos10 ?v)**: Indicates the value in position 10 of the grid.\n- **(pos11 ?v)**: Indicates the value in position 11 of the grid.\n- **(pos12 ?v)**: Indicates the value in position 12 of the grid.\n- **(pos13 ?v)**: Indicates the value in position 13 of the grid.\n- **(pos14 ?v)**: Indicates the value in position 14 of the grid.\n- **(pos15 ?v)**: Indicates the value in position 15 of the grid.\n- **(pos16 ?v)**: Indicates the value in position 16 of the grid.\n\n### Actions\n- **rot1(?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )**: Rotates the first 3x3 square clockwise.  \n\n- **rot2(?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )**: Rotates the second 3x3 square (positions 2, 3, 4, 6, 8, 12, 11, 10) clockwise.  \n\n- **rot3(?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )**: Rotates the third 3x3 square (positions 5, 6, 7, 11, 15, 14, 13, 9) clockwise.   \n\n- **rot4(?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )**: Rotates the fourth 3x3 square (positions 6, 7, 8, 12, 16, 15, 14, 10) clockwise.",
        "pddl_domain_processed": "\n\n(define (domain rotation)\n   (:requirements :strips)\n   (:predicates (pos1 ?v )\n                (pos2 ?v )\n                (pos3 ?v )\n                (pos4 ?v )\n                (pos5 ?v )\n                (pos6 ?v )\n                (pos7 ?v )\n                (pos8 ?v )\n                (pos9 ?v )\n                (pos10 ?v )\n                (pos11 ?v )\n                (pos12 ?v )\n                (pos13 ?v )\n                (pos14 ?v )\n                (pos15 ?v )\n                (pos16 ?v )\n                )\n\n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n                           (pos1 ?v5)\n                           (pos2 ?v1)\n                           (pos3 ?v2)\n\n                           (pos5 ?v9)\n\n                           (pos7 ?v3)\n\n                           (pos9 ?v10)\n                           (pos10 ?v11)\n                           (pos11 ?v7)\n\n                           (not (pos1 ?v1))\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n\n                           (not (pos5 ?v5))\n\n                           (not (pos7 ?v7))\n\n                           (not (pos9 ?v9))\n                           (not (pos10 ?v10))\n                           (not (pos11 ?v11))\n\n                           )\n\n    ) \n\n   (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n\n                          (pos2 ?v6) \n                          (pos3 ?v2) \n                          (pos4 ?v3) \n\n                          (pos6 ?v10) \n\n                          (pos8 ?v4) \n\n                          (pos10 ?v11) \n                          (pos11 ?v12) \n                          (pos12 ?v8)\n\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n\n                           (not (pos6 ?v6))\n\n                           (not (pos8 ?v8))\n\n                           (not (pos10 ?v10))\n                           (not (pos11 ?v11))\n                           (not (pos12 ?v12))\n\n                           )\n\n    ) \n\n   (:action rot3\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n\n                          (pos5 ?v9) \n                          (pos6 ?v5) \n                          (pos7 ?v6) \n\n                          (pos9 ?v13) \n\n                          (pos11 ?v7) \n\n                          (pos13 ?v14)\n                          (pos14 ?v15)\n                          (pos15 ?v11)\n\n                           (not (pos5 ?v5))\n                           (not (pos6 ?v6))\n                           (not (pos7 ?v7))\n\n                           (not (pos9 ?v9))\n\n                           (not (pos11 ?v11))\n\n                           (not (pos13 ?v13))\n                           (not (pos14 ?v14))\n                           (not (pos15 ?v15))\n\n                           )\n\n    ) \n\n   (:action rot4\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6 ?v7 ?v8 ?v9 ?v10 ?v11 ?v12 ?v13 ?v14 ?v15 ?v16 )\n             :precondition \n                       (and \n                          (pos1 ?v1) \n                          (pos2 ?v2) \n                          (pos3 ?v3) \n                          (pos4 ?v4) \n                          (pos5 ?v5) \n                          (pos6 ?v6) \n                          (pos7 ?v7) \n                          (pos8 ?v8) \n                          (pos9 ?v9) \n                          (pos10 ?v10) \n                          (pos11 ?v11) \n                          (pos12 ?v12)\n                          (pos13 ?v13)\n                          (pos14 ?v14)\n                          (pos15 ?v15)\n                          (pos16 ?v16)\n                          )\n\n             :effect \n                       (and\n\n                          (pos6 ?v10) \n                          (pos7 ?v6) \n                          (pos8 ?v7) \n\n                          (pos10 ?v14) \n\n                          (pos12 ?v8)\n\n                          (pos14 ?v15)\n                          (pos15 ?v16)\n                          (pos16 ?v12)\n\n                           (not (pos6 ?v6))\n                           (not (pos7 ?v7))\n                           (not (pos8 ?v8))\n\n                           (not (pos10 ?v10))\n\n                           (not (pos12 ?v12))\n\n                           (not (pos14 ?v14))\n                           (not (pos15 ?v15))\n                           (not (pos16 ?v16))\n                           )\n\n    ) \n\n)\n"
    },
    {
        "file_name": "hakank_hakank_monkey-domain.pddl",
        "pddl_domain": ";;;\n;;; Monkey problem in PDDL.\n;;;\n;;; From Graphplan example monkey_ops.\n;;; \"\"\"\n;;; From UCPOP [which they got from Prodigy].  Note: there is no operator \n;;; to get back down from a box...\n;;; \"\"\"\n(define (domain monkeyproblem)\n   (:requirements :adl)\n   (:constants monkey box knife bananas waterfountain glass)\n   (:predicates \n                 (goto ?x ?y) \n                 (climp ?x)\n                 (push-box ?x ?y)\n                 (get-knife ?y)\n                 (grab-bananas ?y)\n                 (pickglass ?y)\n                 (getwater ?y)\n                 (on-floor)\n                 (at ?x ?y)\n                 (hasbananas)\n                 (hasknife)\n                 (hasglass)\n                 (haswater)\n                 (onbox ?x)\n                 )\n\n   (:action goto\n             :parameters (?x ?y)\n             :precondition (and \n                             (on-floor)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (at monkey ?x)\n                           (not (at monkey ?y))\n                           )\n    ) \n\n\n   (:action climp\n             :parameters (?x)\n             :precondition (and \n                             (at box ?x)\n                             (at monkey ?x)\n                             )\n             :effect  (and \n                           (onbox ?x)\n                           (not (on-floor))\n                           )\n    ) \n\n\n   (:action push-box\n             :parameters (?x ?y)\n             :precondition (and \n                             (at box ?y)\n                             (at monkey ?y)\n                             (on-floor)\n                             )\n             :effect  (and \n                           (at monkey ?x)\n                           (at box ?x)\n                           (not (at monkey ?y))\n                           (not (at box ?y))\n                           )\n    ) \n\n   (:action get-knife\n             :parameters (?y)\n             :precondition (and \n                             (at knife ?y)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (hasknife)\n                           (not (at knife ?y))\n                           )\n    ) \n\n   (:action grab-bananas\n             :parameters (?y)\n             :precondition (and \n                             (hasknife)\n                             (at bananas ?y)\n                             (onbox ?y)\n                             )\n             :effect  (and \n                           (hasbananas)\n                           )\n    ) \n\n   (:action pickglass\n             :parameters (?y)\n             :precondition (and \n                             (at glass ?y)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (hasglass)\n                           (not (at glass ?y))\n                           )\n    ) \n\n   (:action getwater\n             :parameters (?y)\n             :precondition (and \n                             (hasglass)\n                             (at waterfountain ?y)\n                             (at monkey ?y)\n                             (onbox ?y)\n                             )\n             :effect  (and \n                           (haswater)\n                           )\n    ) \n\n)\n\n",
        "batch_id": 3,
        "id": 247,
        "tokens": 5621,
        "corrected_description": "### General\nThe Monkey Problem domain involves a monkey that can move around, climb on a box, push the box, get a knife, grab bananas, pick up a glass, and get water. The goal is to achieve a certain state, such as having the bananas or filling the glass with water, by performing a sequence of actions under specific conditions.\n\n### Predicates\n- **(goto ?x ?y)**: Represents the action of going from location ?y to ?x.\n- **(climp ?x)**: Indicates the monkey is climbing at location ?x.\n- **(push-box ?x ?y)**: Represents pushing the box from location ?y to ?x.\n- **(get-knife ?y)**: Indicates getting the knife at location ?y.\n- **(grab-bananas ?y)**: Represents grabbing bananas at location ?y.\n- **(pickglass ?y)**: Indicates picking up a glass at location ?y.\n- **(getwater ?y)**: Represents getting water at location ?y.\n- **(on-floor)**: Indicates the monkey is on the floor.\n- **(at ?x ?y)**: Represents the location of object ?x at place ?y.\n- **(hasbananas)**: Indicates the monkey has bananas.\n- **(hasknife)**: Indicates the monkey has a knife.\n- **(hasglass)**: Indicates the monkey has a glass.\n- **(haswater)**: Indicates the monkey has water in the glass.\n- **(onbox ?x)**: Indicates the monkey is on the box at location ?x.\n\n### Actions\n- **goto <?x> <?y>**: Moves the monkey from location ?y to ?x if it is on the floor and at location ?y.  \n- **climp <?x>**: Allows the monkey to climb on the box at location ?x if both the monkey and the box are at location ?x.  \n- **push-box <?x> <?y>**: Moves the box from location ?y to ?x if the monkey is at the same location as the box and on the floor.  \n- **get-knife <?y>**: The monkey gets the knife at location ?y if it is at the same location as the knife.  \n- **grab-bananas <?y>**: The monkey grabs the bananas at location ?y if it has a knife, is on the box, and at the same location as the bananas.  \n- **pickglass <?y>**: The monkey picks up a glass at location ?y if it is at the same location as the glass.  \n- **getwater <?y>**: The monkey gets water at location ?y if it has a glass, is on the box, and at the same location as the water fountain and the monkey.",
        "pddl_domain_processed": "\n\n(define (domain monkeyproblem)\n   (:requirements :adl)\n   (:constants monkey box knife bananas waterfountain glass)\n   (:predicates \n                 (goto ?x ?y) \n                 (climp ?x)\n                 (push-box ?x ?y)\n                 (get-knife ?y)\n                 (grab-bananas ?y)\n                 (pickglass ?y)\n                 (getwater ?y)\n                 (on-floor)\n                 (at ?x ?y)\n                 (hasbananas)\n                 (hasknife)\n                 (hasglass)\n                 (haswater)\n                 (onbox ?x)\n                 )\n\n   (:action goto\n             :parameters (?x ?y)\n             :precondition (and \n                             (on-floor)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (at monkey ?x)\n                           (not (at monkey ?y))\n                           )\n    ) \n\n   (:action climp\n             :parameters (?x)\n             :precondition (and \n                             (at box ?x)\n                             (at monkey ?x)\n                             )\n             :effect  (and \n                           (onbox ?x)\n                           (not (on-floor))\n                           )\n    ) \n\n   (:action push-box\n             :parameters (?x ?y)\n             :precondition (and \n                             (at box ?y)\n                             (at monkey ?y)\n                             (on-floor)\n                             )\n             :effect  (and \n                           (at monkey ?x)\n                           (at box ?x)\n                           (not (at monkey ?y))\n                           (not (at box ?y))\n                           )\n    ) \n\n   (:action get-knife\n             :parameters (?y)\n             :precondition (and \n                             (at knife ?y)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (hasknife)\n                           (not (at knife ?y))\n                           )\n    ) \n\n   (:action grab-bananas\n             :parameters (?y)\n             :precondition (and \n                             (hasknife)\n                             (at bananas ?y)\n                             (onbox ?y)\n                             )\n             :effect  (and \n                           (hasbananas)\n                           )\n    ) \n\n   (:action pickglass\n             :parameters (?y)\n             :precondition (and \n                             (at glass ?y)\n                             (at monkey ?y)\n                             )\n             :effect  (and \n                           (hasglass)\n                           (not (at glass ?y))\n                           )\n    ) \n\n   (:action getwater\n             :parameters (?y)\n             :precondition (and \n                             (hasglass)\n                             (at waterfountain ?y)\n                             (at monkey ?y)\n                             (onbox ?y)\n                             )\n             :effect  (and \n                           (haswater)\n                           )\n    ) \n\n)\n\n"
    },
    {
        "file_name": "hakank_hakank_1d-rubiks-cube-domain.pddl",
        "pddl_domain": "(define (domain rubik-1d)\n   (:requirements :strips)\n   (:predicates (pos1 ?v)\n                (pos2 ?v)\n                (pos3 ?v)\n                (pos4 ?v)\n                (pos5 ?v)\n                (pos6 ?v))\n\n   \n   \n   \n   (:action rot0\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos1 ?v4)              \n                           (pos2 ?v3)              \n                           (pos3 ?v2)              \n                           (pos4 ?v1)                    \n                           (not (pos1 ?v1))\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4)))\n    ) \n\n    \n    \n    \n    \n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos2 ?v5)              \n                           (pos3 ?v4)              \n                           (pos4 ?v3)              \n                           (pos5 ?v2)\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n                           (not (pos5 ?v5)))\n    ) \n\n    \n    \n    \n    \n    (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos3 ?v6)              \n                           (pos4 ?v5)              \n                           (pos5 ?v4)              \n                           (pos6 ?v3)              \n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n                           (not (pos5 ?v5))\n                           (not (pos6 ?v6)))\n    ) \n\n\n)\n",
        "batch_id": 3,
        "id": 259,
        "tokens": 6187,
        "corrected_description": "### General\nThis domain models a 1D Rubik's Cube puzzle, where the cube is represented as a line of 6 numbers that can be rotated in three different ways in groups of four. The goal is to find the shortest sequence of rotations to restore the original position of the numbers.\n\n### Predicates\n- **(pos1 ?v)**: Indicates the value at position 1 of the 1D Rubik's Cube.\n- **(pos2 ?v)**: Indicates the value at position 2 of the 1D Rubik's Cube.\n- **(pos3 ?v)**: Indicates the value at position 3 of the 1D Rubik's Cube.\n- **(pos4 ?v)**: Indicates the value at position 4 of the 1D Rubik's Cube.\n- **(pos5 ?v)**: Indicates the value at position 5 of the 1D Rubik's Cube.\n- **(pos6 ?v)**: Indicates the value at position 6 of the 1D Rubik's Cube.\n\n### Actions\n- **rot0 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: Rotates the first four positions of the 1D Rubik's Cube.  \n\n- **rot1 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: Rotates the middle four positions of the 1D Rubik's Cube.  \n\n- **rot2 <?v1> <?v2> <?v3> <?v4> <?v5> <?v6>**: Rotates the last four positions of the 1D Rubik's Cube.",
        "pddl_domain_processed": "(define (domain rubik-1d)\n   (:requirements :strips)\n   (:predicates (pos1 ?v)\n                (pos2 ?v)\n                (pos3 ?v)\n                (pos4 ?v)\n                (pos5 ?v)\n                (pos6 ?v))\n\n   (:action rot0\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos1 ?v4)              \n                           (pos2 ?v3)              \n                           (pos3 ?v2)              \n                           (pos4 ?v1)                    \n                           (not (pos1 ?v1))\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4)))\n    ) \n\n   (:action rot1\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos2 ?v5)              \n                           (pos3 ?v4)              \n                           (pos4 ?v3)              \n                           (pos5 ?v2)\n                           (not (pos2 ?v2))\n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n                           (not (pos5 ?v5)))\n    ) \n\n    (:action rot2\n             :parameters (?v1 ?v2 ?v3 ?v4 ?v5 ?v6)\n             :precondition (and (pos1 ?v1) \n                                (pos2 ?v2) \n                                (pos3 ?v3) \n                                (pos4 ?v4) \n                                (pos5 ?v5) \n                                (pos6 ?v6) \n                                )\n             :effect  (and \n                           (pos3 ?v6)              \n                           (pos4 ?v5)              \n                           (pos5 ?v4)              \n                           (pos6 ?v3)              \n                           (not (pos3 ?v3))\n                           (not (pos4 ?v4))\n                           (not (pos5 ?v5))\n                           (not (pos6 ?v6)))\n    ) \n\n)\n"
    }
]